cmdhistory=["(shared/add-canidates (ap/trapped-ants trial-paths))" "(def trial-paths (ap/proc-all-ants (ap/init-trail-paths)))" "(shared/add-canidates (ap/trapped-ants trial-paths))" "shared/trail-state" "(shared/update-thresh (bootstrap))" "(defn print-failure [isSuccess?, msg]\\r\\n  (do (when-not isSuccess\\r\\n        (print msg))\\r\\n    isSuccess?))" "(defn print-failure [isSuccess?, msg]\\r\\n  (do (when-not isSuccess?\\r\\n        (print msg))\\r\\n    isSuccess?))" "(print-failure false \\"test\\")" "(print-failure true \\"test\\")" "(defn print-failure [isSuccess? & msg]\\r\\n  (do (when-not isSuccess?\\r\\n        (print msg)\\r\\n    isSuccess?)))" "(shared/save-image-ref (image/image-RGB-gray (image/get-image)))" "(shared/update-thresh (bootstrap))" "(defn print-failure [isSuccess? & msg]\\r\\n  (do (when-not isSuccess?\\r\\n        (print msg)\\r\\n    isSuccess?)))" "(print-failure false \\"x\\" 1)" "(shared/update-thresh (bootstrap))" "(bootstrap)<type clojure code here>" "(bootstrap)" "(shared/update-thresh (bootstrap))" "(is false)" "(shared/update-thresh (bootstrap))" "@shared/trail-state" "(\:image @shared/trail-state)" "(. (\:image @shared/trail-state)  getRGB 1 1)" "(. (\:image @shared/trail-state)  getRGB 0 0)" "(bootstrap)" "(. (\:image @shared/trail-state)  getRGB  515 10)" "(bootstrap)" "(def tp (random-point 1000))" "(def tp (ap/random-point 1000))" "(fliter \#(< (first %) 0) tp)" "(filter \#(< (first %) 0) tp)" "(filter \#(< (second %) 0) tp)" "(filter \#(> (first %) 514) tp)" "(filter \#(> (first %) 500) tp)" "(def antp (ant-path sp))" "(def antp (ant-path tp))" "(def antp (ap/ant-path tp))" "(def antp  (map \#(ap/ant-path %) tp))" "(first antp)" "@shared/tra" "@shared/trail-state" "shared/config" "(shared/proc-ant antp)" "(def a (ap/proc-ant antp))" "(ap/proc-ant antp)" "antp" "(def a (ap/proc-ant antp))" "(shared/update-thresh (bootstrap))" "(perform-trial)" "(repeatedly (shared/get-num-trails) \#(perform-trial))" "(shared/get-num-trails)" "(repeatedly 1  \#(perform-trial))" "(perform-trial)" "(def ap trial-paths (ap/proc-all-ants (ap/init-trail-paths)))" "(def trial-paths (ap/proc-all-ants (ap/init-trail-paths)))" "(ap/proc-all-ants (ap/init-trail-paths))" "(def d (map \#(proc-ant %) (init-trail-paths))" "(def d (map \#(proc-ant %) (init-trail-paths)))" "(def d (map \#(ap/proc-ant %) (ap/init-trail-paths)))" "(ap/proc-all-ants (ap/init-trail-paths))" "(def r (ap/proc-all-ants (ap/init-trail-paths)))" "r" "(def r (ap/proc-all-ants (ap/init-trail-paths)))" "r" "(def r (ap/proc-all-ants (ap/init-trail-paths)))" "r" "(def r (ap/proc-all-ants (ap/init-trail-paths)))" "r" "(def r (ap/proc-all-ants (ap/init-trail-paths)))" "r" "(def r (ap/proc-all-ants (ap/init-trail-paths)))" "r" "(def r (ap/proc-all-ants (ap/init-trail-paths)))" "r" "(range  10)" "(def r (ap/proc-all-ants (ap/init-trail-paths)))" "r" "(rand-ant-dir [48 0])" "(ap/rand-ant-dir [48 0])" " (full-path-last-point 48 0)" " (ap/full-path-last-point 48 0)" " (ap/full-path-last-point 0 -1)" "(ap/rand-ant-dir [48 0])" "(repeatedly (shared/get-num-trails) \#(perform-trial))" "shared/config" "shared/trail-state" "(def trial-paths (ap/proc-all-ants (ap/init-trail-paths)))" "(ap/trapped-ants trial-paths)" "(ap/trap-escaped-thresh trial-paths)" "trial-paths" "  (apply min (ap/trial-min-local \\r\\n               (ap/proc-all-ants (ap/init-trail-paths)))))" "  (apply min (ap/trial-min-local \\r\\n               (ap/proc-all-ants (ap/init-trail-paths))))" "(ap/proc-all-ants (ap/init-trail-paths))" "(ap/init-trail-paths)" " (shared/save-image-ref (image/image-RGB-gray (image/get-image)))" "(shared/update-thresh (bootstrap))" "(perform-trial" "(perform-trial)" "shared/trial-state" "(perform-trial)" "shared/trial-state" "(perform-trial)" "shared/trial-state" "(ap/perform-trial)" "(perform-trial)" "shared/trial-state" "(perform-trial)" "shared/trial-state" "perform-trial" "(perform-trial)" "shared/trial-state" "(perform-trial)" "shared/trial-state" "(perform-trial)" "shared/trial-state" "(perform-trial)" "shared/trial-state" "(perform-trial)" "shared/trial-state" "(perform-trial)" "shared/trial-state" "(perform-trial)" "shared/trial-state" "(perform-trial)" "shared/trial-state" "(+ 1 1)" "(shared/save-image-ref (image/image-RGB-gray (image/get-image)))" "(shared/update-thresh (bootstrap))" "(perform-trial)" "shared/trial-state" "(perform-trial)" "shared/trial-state" "(perform-trial)" "shared/trial-state" "(perform-trial)" "shared/trial-state" "(perform-trial)" "shared/trial-state" "(shared/thresh)" "(def v trial-paths (ap/proc-all-ants (ap/init-trail-paths)))" "(def trial-paths (ap/proc-all-ants (ap/init-trail-paths)))" "(shared/add-canidates (ap/trapped-ants trial-paths))" "(def trial-thresh (ap/trap-escaped-thresh trial-paths))" "trial-thresh" "(shared/thresh)" "(when-not (> trial-thresh (shared/thresh))\\r\\n             (shared/update-thresh trial-thresh))" "trial-thresh" "(perform-trial)" "(shared/thresh)" "trial-thresh" "(< -6184543 -11842741)" "(> -6184543 -11842741)" "(perform-trial)" "(shared/thresh)" "(perform-trial)" "(shared/thresh)" "(perform-trial)" "(shared/thresh)" "(repeatedly (shared/get-num-trails) \#(perform-trial))" "(shared/thresh)" "trial-thresh" "shared/trial-state" "(def trial-paths (ap/proc-all-ants (ap/init-trail-paths)))" "(ap/trapped-ants trial-paths)" "trial-paths" "(def trial-paths (ap/proc-all-ants (ap/init-trail-paths)))" "trial-paths" "(def trial-paths (ap/proc-all-ants (ap/init-trail-paths)))" "trial-paths" "(ap/trapped-ants trial-paths)" "(shared/add-canidates (ap/trapped-ants trial-paths))" "shared/trial-state" "perform-trial" "(repeatedly (shared/get-num-trails) \#(perform-trial))" "(perform-trial)" "(def trial-thresh (ap/trap-escaped-thresh trial-paths))" "(when (> trial-thresh (shared/thresh))\\r\\n             (shared/update-thresh trial-thresh))" "(perform-trial)" "( process-image )" "(def g <)" "(g  1 1)" "(def g \=)" "(g  1 1)" "(shared/save-image-ref (image/image-RGB-gray (image/get-image)))" "(shared/update-thresh (bootstrap))" "(perform-trial)" "(shared/thresh)" "(perform-trial)" "(def trial-paths (ap/proc-all-ants (ap/init-trail-paths)))" " (ap/init-trail-paths)" " (phero-points \\r\\n           (num-of-phero-starts))" "(num-of-phero-starts)" "(ant-path/num-of-phero-starts)" "(ap/num-of-phero-starts)" "(ap/num-of-random-starts)" "  (map \#(ap/ant-path %)\\r\\n       (concat \\r\\n         (ap/random-point \\r\\n           (ap/num-of-random-starts))\\r\\n         (ap/phero-points \\r\\n           (ap/num-of-phero-starts)))))" "  (map \#(ap/ant-path %)\\r\\n       (concat \\r\\n         (ap/random-point \\r\\n           (ap/num-of-random-starts))\\r\\n         (ap/phero-points \\r\\n           (ap/num-of-phero-starts))))" "(shared/trial-num)" "(ap/random-point \\r\\n              (ap/num-of-random-starts)" "(ap/random-point \\r\\n              (ap/num-of-random-starts))" "(ap/phero-points \\r\\n           (ap/num-of-phero-starts))" "(ap/phero-points  0)" "(shared/canidates)" "(count (shared/canidates))" "(ap/phero-points  0)" "(ap/phero-points  1)" "(ap/phero-points  0\\n                  )" "(ap/phero-points  1)" " (take 1 (shuffle (shared/canidates)))" "(ant/path-loc-at-time \\r\\n        (take 1 (shuffle (shared/canidates))) \\r\\n        (rand-int (shared/max-path-length)))" "(tgaa.algo.ant/path-loc-at-time \\r\\n        (take 1 (shuffle (shared/canidates))) \\r\\n        (rand-int (shared/max-path-length)))" "(rand-int (shared/max-path-length))" "(tgaa.algo.ant/path-loc-at-time \\r\\n        (take 1 (shuffle (shared/canidates))) \\r\\n        4)" "(take 1 (shuffle (shared/canidates)))" "(apply tgaa.algo.ant/path-loc-at-time \\r\\n        (take 1 (shuffle (shared/canidates))) \\r\\n        4)" "(map \#(ant/path-loc-at-time %1 %2)\\r\\n             (take 1 (shuffle (shared/canidates))) \\r\\n             (rand-int (shared/max-path-length)))" "(map \#(tgaa.algo.ant/path-loc-at-time %1 %2)\\r\\n             (take 1 (shuffle (shared/canidates))) \\r\\n             (rand-int (shared/max-path-length)))" "(map \#(tgaa.algo.ant/path-loc-at-time %1 %2)\\r\\n             (take 1 (shuffle (shared/canidates))) \\r\\n             (repeatedly 1 \#(rand-int (shared/max-path-length))))" "(map \#(tgaa.algo.ant/path-loc-at-time %1 %2)\\r\\n             (take 2 (shuffle (shared/canidates))) \\r\\n             (repeatedly 2 \#(rand-int (shared/max-path-length))))" "(repeatedly 5 \#(rand-int (shared/max-path-length)))" "(ap/phero-points  1)" "(ap/phero-points  2)" "(ap/phero-points  0)" "(ap/phero-points  2)" "(ap/phero-points  22)" "(ap/phero-points  0)" "(perform-trial)" "(shared/thresh)" "(perform-trial)" "(shared/thresh)" "(perform-trial)" "(shared/thresh)" "(repeatedly (shared/get-num-trails) \#(perform-trial))" "(shared/thresh)" "(perform-trial)" "(shared/get-num-trails)" "(repeatedly (shared/get-num-trails) \#(perform-trial))" "(perform-trial)" "(repeatedly (shared/get-num-trails) \#(perform-trial))" "(perform-trial)" "(shared/get-num-trails)" "(shared/thresh)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(phases/perform-trial)" "(phase/perform-trial)" "(ap/init-trail-paths)" "(tgaa.algo./init-trail-paths)" "(tgaa.algo.trial /init-trail-paths)" "(tgaa.algo.trial/init-trail-paths)" "(tgaa.util.ant-path/ant-path 10)" "(rand-ant-dir start-point)" "(tgaa.util.ant/rand-ant-dir start-point)" "(tgaa.util.ant/rand-ant-dir 4)" "(tgaa.util.ant/rand-ant-dir [1 1])" "(tgaa.util.ant-path/ant-path 10)" "(tgaa.algo.trial/init-trail-paths)" "(ns-name)" "(phase/trapping)" "(trapping)" "(load-image )" "(bootstrap)" "(perform-trial )" "(ap/init-trail-paths)" "(ap/proc-all-ants (ap/init-trail-paths))" "(def trial-paths (ap/proc-all-ants (ap/init-trail-paths)))" "(shared/add-canidates (trial/trapped-ants trial-paths))" "(def trial-thresh (trial/trap-escaped-thresh trial-paths))" "(when (> trial-thresh (shared/thresh))\\r\\n             (shared/update-thresh trial-thresh))" "trial-thresh" "(trial/trap-escaped-thresh trial-paths)" "(perform-trial )" "(shared/thresh)" "(perform-trial )" "(shared/thresh)" "(trial/trap-escaped-thresh trial-paths)" "(bootstrap)" "(shared/canidates)" "(shared/add-canidates [])" "(shared/canidates)" "(shared/add-canidates [])" "(shared/canidates)" "\\n(reset\! shared/trial-state  (assoc @shared/trial-state \:cand-paths (apply conj (\:cand-paths @shared/trial-state) [])))" "\\n(reset\! shared/trial-state  (assoc @shared/trial-state \:cand-paths []))" "(shared/canidates)" "(bootstrap)" "(shared/canidates)" "(perform-trial )" "(shared/canidates)" "(shared/thresh\\n  )" "\\n(reset\! shared/trial-state  (assoc @shared/trial-state \:cand-paths []))" "(bootstrap)" "(def trial-paths (ap/proc-all-ants (ap/init-trail-paths)))" "(trial/trap-escaped-thresh trial-paths)" "trial-paths" "(bootstrap)" "\\n(reset\! shared/trial-state  (assoc @shared/trial-state \:cand-paths []))" "(perform-trial )" "(shared/thresh\\n  )" "(perform-trial )" "(shared/thresh\\n  )" "(perform-trial )" "(shared/thresh\\n  )" "(perform-trial )" "(shared/thresh\\n  )" "(perform-trial )" "(shared/thresh\\n  )" "(perform-trial )" "(shared/thresh\\n  )" "(perform-trial )" "(shared/thresh\\n  )" "(phase/load-image)" "  (use mikera.image.colours)\\r\\n  (use mikera.image.core)\\r\\n  (use mikera.image.filters)\\r\\n  (use mikera.image.spectrum)" "  (use 'mikera.image.colours)\\r\\n  (use 'mikera.image.core)\\r\\n  (use 'mikera.image.filters)\\r\\n  (use 'mikera.image.spectrum)" "(show (tgaa.util.image/get-image))" "(show ((contrast 0.5) (tgaa.util.image/get-image)))" "(ArrayColormap" "(com.jhlabs.image.ArrayColormap.)" "getColor" "(let [f (com.jhlabs.image.ArrayColormap.)]\\n  (. f getColor 0.5))" "(com.jhlabs.image.ThresholdFilter.)" "(defn laplace\\r\\n  \\"Creates an edge detection filter based on Laplace operators.\\"\\r\\n  (^Filter []\\r\\n   (Filter. (com.jhlabs.image.ThresholdFilter.))))" "(defn thresh\\r\\n  \\"Creates an edge detection filter based on Laplace operators.\\"\\r\\n  (^Filter []\\r\\n   (Filter. (com.jhlabs.image.ThresholdFilter.))))" "(defn thresh\\r\\n  \\"Creates an edge detection filter based on Laplace operators.\\"\\r\\n  (^Filter []\\r\\n   (mikera.image.filters/Filter. (com.jhlabs.image.ThresholdFilter.))))" "(defn thresh\\r\\n  \\"Creates an edge detection filter based on Laplace operators.\\"\\r\\n  (^Filter []\\r\\n   (mikera.image.filters.Filter. (com.jhlabs.image.ThresholdFilter.))))" "(defn thresh\\r\\n  \\"Creates an edge detection filter based on Laplace operators.\\"\\r\\n  (^Filter []\\r\\n   (com.jhlabs.image.Filter. (com.jhlabs.image.ThresholdFilter.))))" "(defn thresh\\r\\n  \\"Creates an edge detection filter based on Laplace operators.\\"\\r\\n  (^Filter []\\r\\n   (com.jhlabs.filter.Filter. (com.jhlabs.image.ThresholdFilter.))))" "(defn thresh\\r\\n  \\"Creates an edge detection filter based on Laplace operators.\\"\\r\\n  (^Filter []\\r\\n   (Filter. (com.jhlabs.image.ThresholdFilter.))))" "(defn thresh\\r\\n  \\"Creates an edge detection filter based on Laplace operators.\\"\\r\\n  (^Filter []\\r\\n   (mikera.image.filters.Filter. (com.jhlabs.image.ThresholdFilter.))))" "(defn thresh\\r\\n  \\"Creates an edge detection filter based on Laplace operators.\\"\\r\\n  (^Filter []\\r\\n   (mikera.image.filters/Filter. (com.jhlabs.image.ThresholdFilter.))))" "(defn thresh\\r\\n  \\"Creates an edge detection filter based on Laplace operators.\\"\\r\\n  (^Filter []\\r\\n   (mikera.image.filters/->Filter (com.jhlabs.image.ThresholdFilter.))))" "\\r\\n(deftype Filter [^BufferedImageOp image-op]\\r\\n  clojure.lang.IFn\\r\\n    (invoke [this image]\\r\\n      (let [^BufferedImage image image \\r\\n            dest-img (.createCompatibleDestImage image-op image (.getColorModel image))]\\r\\n        (.filter image-op image dest-img)\\r\\n        dest-img))\\r\\n    (applyTo [this args] \\r\\n      (clojure.lang.AFn/applyToHelper this args)))" "(defn thresh\\r\\n  \\"Creates an edge detection filter based on Laplace operators.\\"\\r\\n  (^Filter []\\r\\n   (mikera.image.filters/Filter. (com.jhlabs.image.ThresholdFilter.))))" "(defn thresh\\r\\n  \\"Creates an edge detection filter based on Laplace operators.\\"\\r\\n  (^Filter []\\r\\n   (mikera.image.filters/Filter (com.jhlabs.image.ThresholdFilter.))))" "\\r\\n   (mikera.image.filters/blur)" "(defn thresh\\r\\n  \\"Creates an edge detection filter based on Laplace operators.\\"\\r\\n  (^Filter []\\r\\n   (mikera.image.filters/Filter (com.jhlabs.image.ThresholdFilter.))))" "(Filter. nil)" "(mikera.image.filters/Filter. nil)" "(mikera.image.filters/->Filter nil)" "(let [f (com.jhlabs.image.ThresholdFilter.)\\n      _ (. f setUpperThreshold -100000)]\\n      \\n  (mikera.image.filters/->Filter f))" "(show ((let [f (com.jhlabs.image.ThresholdFilter.)\\n             _ (. f setUpperThreshold -100000)]\\n         (mikera.image.filters/->Filter f)) (tgaa.util.image/get-image)))" "(defn threshold\\n  (^mikera.image.filters/->Filter [upper-threshold]\\n   (let [f (com.jhlabs.image.ThresholdFilter.)\\n               _ (. f setUpperThreshold upper-threshold)]\\n           (mikera.image.filters/->Filter f)) (tgaa.util.image/get-image)))" "(show ((tgaa.java.util.filters/threshold -100000) (tgaa.util.image/get-image)))" "tgaa.util.shared" "tgaa.util.shared/config" "tgaa.util.shared/trial-state" "process-image" "(process-image)" "tgaa.util.shared/trial-state" "(show ((tgaa.java.util.filters/threshold -11711155) (tgaa.util.image/get-image)))" "(show ((tgaa.java.util.filters/threshold 0) (tgaa.util.image/get-image)))" "(tgaa.util.image/get-image)" "(show (tgaa.util.image/get-image))" "(show ((tgaa.java.util.filters/threshold -99999999) (tgaa.util.image/get-image)))" "(show ((let [f (com.jhlabs.image.ThresholdFilter.  -100000)]\\n         (mikera.image.filters/->Filter f)) (tgaa.util.image/get-image)))" "(show ((let [f (com.jhlabs.image.ThresholdFilter.  -11711155)]\\n         (mikera.image.filters/->Filter f)) (tgaa.util.image/get-image)))" "(show ((let [f (com.jhlabs.image.ThresholdFilter.  0)]\\n         (mikera.image.filters/->Filter f)) (tgaa.util.image/get-image)))" "(show ((let [f (com.jhlabs.image.ThresholdFilter.  -999999999)]\\n         (mikera.image.filters/->Filter f)) (tgaa.util.image/get-image)))" "(defn threshold\\n  (^mikera.image.filters/->Filter [upper-threshold]\\n   (let [f  (com.jhlabs.image.ThresholdFilter.  -999999999)\\n               _ (. f setUpperThreshold upper-threshold)]\\n           (mikera.image.filters/->Filter f)) (tgaa.util.image/get-image)))" "(let [f  (com.jhlabs.image.ThresholdFilter.  -999999999)\\n      _ (. f setUpperThreshold -100000)]\\n      \\n  (mikera.image.filters/->Filter f))" "(show (let [f  (com.jhlabs.image.ThresholdFilter.  -999999999)\\n            _ (. f setUpperThreshold -100000)]\\n      \\n        (mikera.image.filters/->Filter f)))" "(show ((let [f  (com.jhlabs.image.ThresholdFilter.  -999999999)\\n             _ (. f setUpperThreshold -100000)]\\n      \\n         (mikera.image.filters/->Filter f))) (tgaa.util.image/get-image))" "(defn threshold\\r\\n  \\"Creates a threshold filter\\"\\r\\n  (^Filter [upper-threshold]\\r\\n   (let [f (com.jhlabs.image.ThresholdFilter.)\\r\\n         _ (. f setUpperThreshold upper-threshold)]  \\r\\n     (Filter. f))))" "(show ((let [f  (com.jhlabs.image.ThresholdFilter.  -999999999)\\n             _ (. f setUpperThreshold -100000)]\\n      \\n         (mikera.image.filters/->Filter f))) (tgaa.util.image/get-image))" "(show ((tgaa.java.util.filters/threshold -99999999) (tgaa.util.image/get-image)))" "(show ((tgaa.java.util.filters/threshold 127) (tgaa.util.image/get-image)))" "(show ((tgaa.java.util.filters/threshold 130) (tgaa.util.image/get-image)))" "(show ((tgaa.java.util.filters/threshold 530) (tgaa.util.image/get-image)))" "(show ((tgaa.java.util.filters/threshold 100) (tgaa.util.image/get-image)))" "(show ((tgaa.java.util.filters/blur) (tgaa.util.image/get-image)))" "(show ((tgaa.java.util.filters/threshold 100) (tgaa.util.image/get-image)))" "(show ((tgaa.java.util.filters/edge) (tgaa.util.image/get-image)))" "(defn process-image [] \\r\\n  (do(phase/load-image)\\r\\n       (phase/bootstrap)\\r\\n       (phase/trapping)))" "(tgaa.util.shared/trial-num)" "(tgaa.util.shared/trial-state)" "(@tgaa.util.shared/trial-state)" "tgaa.util.shared/trial-state" "(phase/bootstrap)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "tgaa.util.shared/trial-state" "(process-image)" "tgaa.util.shared/trial-state" "(show ((tgaa.java.util.filters/threshold 100) (tgaa.util.image/get-image)))" "(mikera.image.core/show ((tgaa.java.util.filters/threshold 100) (tgaa.util.image/get-image)))" "(use  'mikera.image.core )" "(show ((tgaa.java.util.filters/threshold 100) (tgaa.util.image/get-image)))" " (.createCompatibleDestImage image-op (tgaa.util.image/get-image) (.getColorModel (tgaa.util.image/get-image)))" "(process-image)" "tgaa.util.shared" "tgaa.util.shared/trial-state" "(mikera.image.core/show ((tgaa.java.util.filters/threshold 100) (tgaa.util.image/get-image)))" "(use  'mikera.image.core )" "(def ti ((tgaa.java.util.filters/threshold 100) (tgaa.util.image/get-image)))" "(. getType ti)" "(class ti)" "(. ti getType )" "tgaa.util.shared" "tgaa.util.shared/trial-state" "(keys tgaa.util.shared/trial-state)" "(keys @tgaa.util.shared/trial-state)" "(. (\:image @tgaa.util.shared/trial-state) getType)" "(to-image-op (\:image @tgaa.util.shared/trial-state) getType)" "(mikera.image.filters/to-image-op (\:image @tgaa.util.shared/trial-state) getType)" "(mikera.image.filters/to-image-op (\:image @tgaa.util.shared/trial-state))" "(tgaa.java.util.filters/threshold 100)" "(class (tgaa.java.util.filters/threshold 100))" "(com.jhlabs.image.ThresholdFilter. partition-value)" "(tgaa.java.util.filters.Filter (\:image tgaa.util.shared/trial-state))" "(show ((tgaa.java.util.filters/grayscale) (tgaa.util.image/get-image)))" "(. (show ((tgaa.java.util.filters/grayscale) (tgaa.util.image/get-image))) getType )" "(. getType ti)" "(. (\:image @tgaa.util.shared/trial-state) getType)" "(. ((tgaa.java.util.filters/grayscale) (tgaa.util.image/get-image)) getType )" "(phase/load-image)" "(phase/bootstrap)" "(. (\:image @tgaa.util.shared/trial-state) getType)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.shared/thresh)" "((tgaa.java.util.filters/grayscale (tgaa.util.shared/thresh)) (\:image @tgaa.util.shared/trial-state) getType)" "((tgaa.java.util.filters/grayscale (tgaa.util.shared/thresh)) (\:image @tgaa.util.shared/trial-state))" "((tgaa.java.util.filters/threshold (tgaa.util.shared/thresh)) (\:image @tgaa.util.shared/trial-state))" "(show ((tgaa.java.util.filters/threshold (tgaa.util.shared/thresh)) (\:image @tgaa.util.shared/trial-state)))" "(use  'mikera.image.core )" "(show ((tgaa.java.util.filters/threshold (tgaa.util.shared/thresh)) (\:image @tgaa.util.shared/trial-state)))" "(show ((tgaa.java.util.filters/threshold 0) (\:image @tgaa.util.shared/trial-state)))" "(show ((tgaa.java.util.filters/threshold 256) (\:image @tgaa.util.shared/trial-state)))" "(tgaa.util.shared/thresh)" "(bit-shift-left (tgaa.util.shared/thresh) 16)" "(bit-shift-left (tgaa.util.shared/thresh) 8)" "(bit-shift-left (tgaa.util.shared/thresh))" "(bit-shift-left (tgaa.util.shared/thresh)1)" "(bit-shift-right (tgaa.util.shared/thresh)1)" "(bit-shift-right (tgaa.util.shared/thresh)16)" "(bit-shift-right (tgaa.util.shared/thresh)8)" "(show ((tgaa.java.util.filters/threshold 237) (\:image @tgaa.util.shared/trial-state)))" "(show ((tgaa.java.util.filters/threshold -237) (\:image @tgaa.util.shared/trial-state)))" "(show ((tgaa.java.util.filters/threshold 237) (\:image @tgaa.util.shared/trial-state)))" "(phase/trapping)" "(bit-shift-right (tgaa.util.shared/thresh)8)" "(bit-shift-right (tgaa.util.shared/thresh)16)" "(show ((tgaa.java.util.filters/threshold 238) (\:image @tgaa.util.shared/trial-state)))" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.shared/thresh)" "(show ((tgaa.java.util.filters/threshold 98) (\:image @tgaa.util.shared/trial-state)))" "(use  'mikera.image.core )" "(show ((tgaa.java.util.filters/threshold 98) (\:image @tgaa.util.shared/trial-state)))" "(tgaa.util.image/show-segmentaton)" "(phase/load-image)" " (phase/bootstrap)" "(phase/trapping)" "(tgaa.util.shared/thresh)" "(tgaa.util.image/show-segmentaton)" "(tgaa.util.shared/image-ref)" "(. (tgaa.util.shared/image-ref) createGraphics)" "(let [g (. (tgaa.util.shared/image-ref) createGraphics)\\n      _ (. g setBackground 0)\\n      _ (. g fillRect 0 0 100 100)])" "(let [g (. (tgaa.util.shared/image-ref) createGraphics)\\n      _ (. g setBackground Color.WHITE)\\n      _ (. g fillRect 0 0 100 100)])" "(let [g (. (tgaa.util.shared/image-ref) createGraphics)\\n      _ (. g setBackground java.awt.Color.WHITE)\\n      _ (. g fillRect 0 0 100 100)])" "(let [g (. (tgaa.util.shared/image-ref) createGraphics)\\n      _ (. g setBackground java.awt.image.Color.WHITE)\\n      _ (. g fillRect 0 0 100 100)])" "(import 'java.awt.image Color)" "(import 'java.awt.image.Color)" "(import [java.awt.image Color])" "(import [java.awt Color])" "(let [g (. (tgaa.util.shared/image-ref) createGraphics)\\n      _ (. g setBackground java.awt.image.Color.WHITE)\\n      _ (. g fillRect 0 0 100 100)])" "(let [g (. (tgaa.util.shared/image-ref) createGraphics)\\n      _ (. g setBackground Color.WHITE)\\n      _ (. g fillRect 0 0 100 100)])" "(let [g (. (tgaa.util.shared/image-ref) createGraphics)\\n      _ (. g setBackground java.awt.Color.WHITE)\\n      _ (. g fillRect 0 0 100 100)])" "(import [java.awt Color])" "java.awt.Color.WHITE" "java.awt.Color." "java.awt.Color" "(def c java.awt.Color)" "c" "c.WHITE" "(. Color WHITE)" "(Color. WHITE)" "(. Color WHITE)" "(let [g (. (tgaa.util.shared/image-ref) createGraphics)\\n      _ (. g setBackground (. Color WHITE))\\n      _ (. g fillRect 0 0 100 100)])" "(show (tgaa.util.shared/image-ref))" "\\n(use 'mikera.image.core)" "(show (tgaa.util.shared/image-ref))" "(let [g (. (tgaa.util.shared/image-ref) createGraphics)\\n      _ (. g setBackground (. Color YELLOW))\\n      _ (. g fillRect 0 0 100 100)])" "(import [java.awt BasicStroke])" "(BasicStroke. 2)" "(let [g (. (tgaa.util.shared/image-ref) createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (BasicStroke. 2))\\n      _ (map (fn[ant]  ) tgaa.util.shared/canidates)" "tgaa.util.shared/canidates" "(tgaa.util.shared/canidates)" "(map (fn [{\:start start} v] start) (tgaa.util.shared/canidates))" "(map (fn [{\:start start}] start) (tgaa.util.shared/canidates))" "(map (fn [{\:start start} val] start) (tgaa.util.shared/canidates))" "(map (fn [\:keys {\:start start}] start) (tgaa.util.shared/canidates))" "(map (fn [{\:keys [\:start start]}] start) (tgaa.util.shared/canidates))" "(map (fn [{\:keys [\:start \:end]}] start) (tgaa.util.shared/canidates))" "(let [g (. (tgaa.util.shared/image-ref) createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (BasicStroke. 2))\\n      _ (map (fn [{\:keys [start end]}] (. g drawLine (first start) (second start) (first end) (second end))) (tgaa.util.shared/canidates))])" "(show (tgaa.util.shared/image-ref))" "(let [g (. (tgaa.util.shared/image-ref) createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (BasicStroke. 2))\\n      _ (map (fn [{\:keys [start end]}] [(first start) (second start) (first end) (second end)]) (tgaa.util.shared/canidates))])" "(map (fn [{\:keys [start end]}] [(first start) (second start) (first end) (second end)]) (tgaa.util.shared/canidates))]" "(tgaa.util.shared/canidates)" "(let [g (. (tgaa.util.shared/image-ref) createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (BasicStroke. 2))\\n      _ (map (fn [{\:keys [start end]}] [(first start) (second start) (+ (first end) 30) (+ (second end) 20)]) (tgaa.util.shared/canidates))])" "(show (tgaa.util.shared/image-ref))" "(let [g (. (tgaa.util.shared/image-ref) createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (BasicStroke. 2))\\n      _ (map (fn [{\:keys [start end]}] (. g drawLine (first start) (second start) (+ (first end) 10) (+ (second end) 10))) (tgaa.util.shared/canidates))])" "(show (tgaa.util.shared/image-ref))" "(let [g (. (tgaa.util.shared/image-ref) createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (BasicStroke. 2))\\n      _ (map (fn [{\:keys [start end]}] (. g drawLine (first start) (second start) (+ (first end) 10) (+ (second end) 10))) (tgaa.util.shared/canidates))])" "(show (tgaa.util.shared/image-ref))" "(let [g (. (tgaa.util.shared/image-ref) createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (BasicStroke. 10))\\n      _ (. g drawLine 10 10 100 100)])" "(show (tgaa.util.shared/image-ref))" "(let [g (. (tgaa.util.shared/image-ref) createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (BasicStroke. 2))\\n      _ (map (fn [{\:keys [start end]}] [(first start) (second start) (+ (first end) 30) (+ (second end) 20)]) (tgaa.util.shared/canidates))])" "(map (fn [{\:keys [start end]}] [(first start) (second start) (+ (first end) 30) (+ (second end) 20)]) (tgaa.util.shared/canidates))" "(let [g (. (tgaa.util.shared/image-ref) createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (BasicStroke. 10))\\n      _ (. g drawLine  449 585 479 605)])" "(show (tgaa.util.shared/image-ref))" "(let [g (. (tgaa.util.shared/image-ref) createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (BasicStroke. 10))\\n      _ (. g drawLine  511 222 541 242)])" "(show (tgaa.util.shared/image-ref))" "(let [g (. (tgaa.util.shared/image-ref) createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (BasicStroke. 2))\\n      _ (doall (map (fn [{\:keys [start end]}] (. g drawLine (first start) (second start) (+ (first end) 10) (+ (second end) 10))) (tgaa.util.shared/canidates)))])" "(show (tgaa.util.shared/image-ref))" "\\n(->> (doto (. (tgaa.util.shared/image-ref) createGraphics)\\n       (.setColor (. Color YELLOW))\\n       (.setStroke (BasicStroke. 2)))\\n  (fn [g] (doall (map \\n                   (fn [{\:keys [start end]}] \\n                     (. g drawLine (first start) (second start) (+ (first end) 10) (+ (second end) 10))) \\n                   (tgaa.util.shared/canidates)))))" "\\n(let [g (doto (. (tgaa.util.shared/image-ref) createGraphics)\\n          (.setColor (. Color YELLOW))\\n          (.setStroke (BasicStroke. 2)))]\\n  (doall (map \\n           (fn [{\:keys [start end]}] \\n             (. g drawLine (first start) (second start) (+ (first end) 10) (+ (second end) 10))) \\n           (tgaa.util.shared/canidates))))" "\\n(let [g (doto (. (tgaa.util.shared/image-ref) createGraphics)\\n          (.setColor (. Color ORANGE))\\n          (.setStroke (BasicStroke. 2)))]\\n  (doall (map \\n           (fn [{\:keys [start end]}] \\n             (. g drawLine (first start) (second start) (+ (first end) 10) (+ (second end) 10))) \\n           (tgaa.util.shared/canidates))))" "(show (tgaa.util.shared/image-ref))" "(defn show-paths [ant-paths-filter-func]\\n  (let [g (doto (. (tgaa.util.shared/image-ref) createGraphics)\\n            (.setColor (. Color ORANGE))\\n            (.setStroke (BasicStroke. 2)))]\\n    (doall (map \\n             (fn [{\:keys [start end]}] \\n               (. g drawLine (first start) (second start) (+ (first end) 10) (+ (second end) 10))) \\n             (filter  ant-paths-filter-func (tgaa.util.shared/canidates))))))" "(defn show-paths [ant-paths-filter-func]\\n  (let [g (doto (. (tgaa.util.shared/image-ref) createGraphics)\\n            (.setColor (. Color RED))\\n            (.setStroke (BasicStroke. 2)))]\\n    (doall (map \\n             (fn [{\:keys [start end]}] \\n               (. g drawLine (first start) (second start) (+ (first end) 10) (+ (second end) 10))) \\n             (filter  ant-paths-filter-func (tgaa.util.shared/canidates))))))" "(show-paths '(fn [x] (\= (\:trial-num x) 10)))" "(filter (fn [x] (\= (\:trial-num x) 10))(tgaa.util.shared/canidates))" "(filter (fn [x] (\= (\:trial-num x) 0))(tgaa.util.shared/canidates))" "(show-paths '(fn [x] (\= (\:trial-num x) 0)))" "(defn show-paths []\\n  (let [g (doto (. (tgaa.util.shared/image-ref) createGraphics)\\n            (.setColor (. Color RED))\\n            (.setStroke (BasicStroke. 2)))]\\n    (doall (map \\n             (fn [{\:keys [start end]}] \\n               (. g drawLine (first start) (second start) (+ (first end) 10) (+ (second end) 10))) \\n             (tgaa.util.shared/canidates)))))" "(show-paths)" "(defn draw-paths []\\n  (let [g (doto (. (tgaa.util.shared/image-ref) createGraphics)\\n            (.setColor (. Color YELLOW))\\n            (.setStroke (BasicStroke. 2)))]\\n    (doall (map \\n             (fn [{\:keys [start end]}] \\n               (. g drawLine (first start) (second start) (+ (first end) 10) (+ (second end) 10))) \\n             (tgaa.util.shared/canidates)))))" "(show-paths)" "(defn show-paths [ant-paths-filter-func]\\n  (let [g (doto (. (tgaa.util.shared/image-ref) createGraphics)\\n            (.setColor (. Color RED))\\n            (.setStroke (BasicStroke. 2)))]\\n    (doall (map \\n             (fn [{\:keys [start end]}] \\n               (. g drawLine (first start) (second start) (+ (first end) 10) (+ (second end) 10))) \\n             (filter  \#ant-paths-filter-func (tgaa.util.shared/canidates))))))" "(defn show-paths [ant-paths-filter-func]\\n  (let [g (doto (. (tgaa.util.shared/image-ref) createGraphics)\\n            (.setColor (. Color RED))\\n            (.setStroke (BasicStroke. 2)))]\\n    (doall (map \\n             (fn [{\:keys [start end]}] \\n               (. g drawLine (first start) (second start) (+ (first end) 10) (+ (second end) 10))) \\n             (filter  ant-paths-filter-func (tgaa.util.shared/canidates))))))" "(defn show-paths [ant-paths-filter-func]\\n  (let [g (doto (. (tgaa.util.shared/image-ref) createGraphics)\\n            (.setColor (. Color RED))\\n            (.setStroke (BasicStroke. 2)))]\\n    (doall (map \\n             (fn [{\:keys [start end]}] \\n               (. g drawLine (first start) (second start) (+ (first end) 10) (+ (second end) 10))) \\n             (filter  \#(ant-paths-filter-func %) (tgaa.util.shared/canidates))))))" "(show-paths '(fn [x] (\= (\:trial-num x) 0)))" "(show-paths (fn [x] (\= (\:trial-num x) 0)))" "(defn show-paths [ant-paths-filter-func]\\n  (let [g (doto (. (tgaa.util.shared/image-ref) createGraphics)\\n            (.setColor (. Color RED))\\n            (.setStroke (BasicStroke. 2)))]\\n    (doall (map \\n             (fn [{\:keys [start end]}] \\n               (. g drawLine (first start) (second start) (+ (first end) 10) (+ (second end) 10))) \\n             (filter ant-paths-filter-func (tgaa.util.shared/canidates))))))" "(show-paths (fn [x] (\= (\:trial-num x) 0)))" "(defn show-paths [ant-paths-filter-func color]\\n  (let [        g (doto (. (tgaa.util.shared/image-ref) createGraphics)\\n            (.setColor (. Color color))\\n            (.setStroke (BasicStroke. 2)))]\\n    (doall (map \\n             (fn [{\:keys [start end]}] \\n               (. g drawLine (first start) (second start) (+ (first end) 10) (+ (second end) 10))) \\n             (filter ant-paths-filter-func (tgaa.util.shared/canidates))))))" "(. Color RED)" "(. Color \\"RED\\")" "(str(. Color \\"RED\\"))" "(str \\"(. Color\\" \\"RED\\")" "(str \\"(. Color \\" \\"RED\\" \\")\\")" "(eval (str \\"(. Color \\" \\"RED\\" \\")\\"))" "(eval-str (str \\"(. Color \\" \\"RED\\" \\")\\"))" "(read-string (str \\"(. Color \\" \\"RED\\" \\")\\"))" "(*read-eval* (str \\"(. Color \\" \\"RED\\" \\")\\"))" "(*read-eval* (read-string (str \\"(. Color \\" \\"RED\\" \\")\\")))" "(eval (read-string (str \\"(. Color \\" \\"RED\\" \\")\\")))" "(defn show-paths [ant-paths-filter-func color-name-str]\\n  (let [g (doto (. (tgaa.util.shared/image-ref) createGraphics)\\n            (.setColor (eval (read-string (str \\"(. Color \\" color \\")\\"))))\\n            (.setStroke (BasicStroke. 2)))]\\n    (doall (map \\n             (fn [{\:keys [start end]}] \\n               (. g drawLine (first start) (second start) (first end) (second end))) \\n             (filter ant-paths-filter-func (tgaa.util.shared/canidates))))))" "(defn show-paths [ant-paths-filter-func color-name-str]\\n  (let [g (doto (. (tgaa.util.shared/image-ref) createGraphics)\\n            (.setColor (eval (read-string (str \\"(. Color \\" color-name-str \\")\\"))))\\n            (.setStroke (BasicStroke. 2)))]\\n    (doall (map \\n             (fn [{\:keys [start end]}] \\n               (. g drawLine (first start) (second start) (first end) (second end))) \\n             (filter ant-paths-filter-func (tgaa.util.shared/canidates))))))" "(defn draw-paths [ant-paths-filter-func color-name-str img-ref]\\n  (let [g (doto (. img-ref createGraphics)\\n            (.setColor (eval (read-string (str \\"(. Color \\" color-name-str \\")\\"))))\\n            (.setStroke (BasicStroke. 2)))]\\n    (doall (map \\n             (fn [{\:keys [start end]}] \\n               (. g drawLine (first start) (second start) (first end) (second end))) \\n             (filter ant-paths-filter-func (tgaa.util.shared/canidates))))))" "(draw-paths (fn [x] true) \\"BLUE\\" (tgaa.util.shared/image-ref))" "(show (tgaa.util.shared/image-ref))" "(clojure.string/upper-case \\"t\\")" "(defn draw-paths [ant-paths-filter-func color-name-str img-ref line-width]\\r\\n  (let [g (doto (. img-ref createGraphics)\\r\\n            (.setColor (eval (read-string \\r\\n                               (str \\"(. Color \\"  \\r\\n                                    (upper-case color-name-str) \\")\\"))))\\r\\n            (.setStroke (BasicStroke. line-width)))]\\r\\n    (doall (map \\r\\n             (fn [{\:keys [start end]}] \\r\\n               (. g drawLine (first start) (second start) (first end) (second end))) \\r\\n             (filter ant-paths-filter-func (tgaa.util.shared/canidates))))))" "tgaa.util.shared" "tgaa.util.shared/canidates" "(first (tgaa.util.shared/canidates))" "(require [tgaa.algo.ant \:as a])" "(require [tgaa.util.ant \:as a])" "(require [tgaa.algo.ant \:as a])" "(shared/config)" "shared/config" "(init-trail-paths )" "(image/get-image)" "(tgaa.algo.phases/load-image)" "(init-trail-paths )" "(defn create-ant-path[]\\r\\n  {})" "(create-ant-path)" "create-ant-path" "(ant/create-ant-path)" "(-> (ant/create-ant-path) (ant/update-ant-thresh true))" "(->> (ant/create-ant-path) (ant/update-ant-thresh true))" "(->> (ant/create-ant-path) (ant/update-ant-thresh true) (ant/update-ant-end-point [10 10]))" "(->> (ant/create-ant-path) \\n  (ant/update-ant-thresh true) \\n  (ant/update-ant-start-point [10 10])\\n  (ant/update-ant-end-point [15 15])\\n  (ant/update-ant-end-point [10 10]))" "(->> (ant/create-ant-path) \\n  (ant/update-ant-thresh true) \\n  (ant/update-ant-start-point [10 10])\\n  (ant/update-ant-start-point [15 15])\\n  (ant/update-ant-end-point [10 10]))" "(->> (ant/create-ant-path) \\n  (ant/update-ant-thresh true) \\n  (ant/update-ant-dir-vec [10 10])\\n  (ant/update-ant-start-point [15 15])\\n  (ant/update-ant-end-point [10 10]))" "(->> (ant/create-ant-path) \\n  (ant/update-ant-trial-num 0)\\n  (ant/update-ant-thresh true) \\n  (ant/update-ant-dir-vec [10 10])\\n  (ant/update-ant-start-point [15 15])\\n  (ant/update-ant-end-point [10 10]))" "(defn tg [& v]\\n  (if (emtpy? v)\\n    10\\n    (assoc (second v) \:testg (first v))))" "(defn tg [& v]\\n  (if (empty? v)\\n    10\\n    (assoc (second v) \:testg (first v))))" "(g)" "(tg)" "(->> {\:one 1} (tg 33))" "(defn tc [& v]\\n  (if (empty? v)\\n    10\\n    (assoc (second v) \:testc (first v))))" "(->> {\:one 1} (tg 33) (tc 55))" "(defn attribute-set-get [key & in]\\r\\n  (let [in-flat (flatten in)]\\r\\n  (if (\= (count in-flat) 1)\\r\\n      (key-name (first in-flat))\\r\\n      (attribute-update key-name (second in-flat) key-name (first in-flat)))))" "(defn attribute-set-get [key-name & in]\\r\\n  (let [in-flat (flatten in)]\\r\\n    (if (\= (count in-flat) 1)\\r\\n      (key-name (first in-flat))\\r\\n      (attribute-update key-name (second in-flat) key-name (first in-flat)))))" "(defn attribute-set-get [key-name & in]\\r\\n  (let [in-flat (flatten in)]\\r\\n    (if (\= (count in-flat) 1)\\r\\n      (key-name (first in-flat))\\r\\n      ((second in-flat) key-name (first in-flat)))))" "(attribute-set-get \:test '((10 {})))" "(defn attribute-set-get [key-name & in]\\r\\n  (let [in-flat (flatten in)]\\r\\n    (if (\= (count in-flat) 1)\\r\\n      (key-name (first in-flat))\\r\\n      (assoc (second in-flat) key-name (first in-flat)))))" "(attribute-set-get \:test '((10 {})))" "(defn attribute-set-get [key-name & in]\\r\\n  (let [in-flat (flatten in)]\\r\\n    (if (\= (count in-flat) 1)\\r\\n      (key-name (first in-flat))\\r\\n      (assoc (second in-flat) key-name (first in-flat)))))\\r\\n\\r\\n(defn ant-thresh? [& in]\\r\\n  (attribute-set-get \:thresh? in)" "(defn ant-thresh? [& in]\\r\\n  (attribute-set-get \:thresh? in))" "(ant-thresh? {\:test 10})" "(ant-thresh? {\:thresh? 10})" "(ant-thresh? 33 {\:thresh? 10})" "(ant-path [ 22 22])" "(ant-path [22 22])" "(defn ant-path [start-point]\\r\\n  \\"Creates an ant path\\"\\r\\n  (->> (ant/create-ant-path) \\r\\n    (ant/ant-trial-num (shared/trial-num))\\r\\n    (ant/ant-thresh? false) \\r\\n    (ant/ant-dir-vec (rand-ant-dir start-point))\\r\\n    (ant/ant-start-point (rand-ant-dir start-point))))" "(ant-path [22 22])" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "tgaa.util.shared" "tgaa.util.shared/thresh" "(tgaa.util.shared/thresh)" "(phase/trapping)" "(tgaa.util.shared/thresh)" "(phase/trapping)" "(tgaa.util.shared/thresh)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.shared/thresh)" "(phase/trapping)" "(tgaa.util.shared/thresh)" "(phase/trapping)" "(tgaa.util.shared/thresh)" "(phase/trapping)" "(tgaa.util.shared/thresh)" "(phase/trapping)" "(tgaa.util.shared/thresh)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.shared/thresh)" "(tgaa.util.image/draw-all-can-paths)" "\\njava.awt.Color" "\\n(java.awt.Color.)" "(. Color WHiTE)" "(java.awt.Color WHiTE)" "(java.awt.Color WHITE)" "(import 'java.awt.Color)" "(java.awt.Color WHITE)" "(. Color WHiTE)" "(. Color WHITE)" "(str \\"(. Color \\"  \\r\\n                                    (upper-case color-name-str) \\")\\")" "(str \\"(. Color \\"  \\r\\n                                    \\"YELLOW\\" \\")\\")" "(tgaa.util.image/draw-all-can-paths)" "(tgaa.util.image/show-image)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/draw-all-can-paths)" "(import  'java.awt.Color)" "(tgaa.util.image/draw-all-can-paths)" "(phase/load-image)" "(phase/trapping)" "(tgaa.util.image/draw-all-can-paths)" "(tgaa.util.image/show-image)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(required tgaa.util.image)" "(required 'tgaa.util.image)" "(require 'tgaa.util.image)" "(tgaa.util.image/show-image)" "(tgaa.util.image/draw-all-can-paths)" "(import 'java.awt.Color)" "(tgaa.util.image/draw-all-can-paths)" "(tgaa.util.image/show-image)" "(require  [mikera.image.core \:as mi])" "(use [mikera.image.core \:as mi])" "(use 'mikera.image.core)" "(require  'mikera.image.core)" "mikera.image.core/copy" "(show (draw-all-can-paths))" "(show (tgaa.util.image/draw-all-can-paths))" "(tgaa.util.image/draw-all-can-paths)" "(show (tgaa.util.image/draw-all-can-paths))" "(phase/load-image)" " (phase/bootstrap)" " (phase/trapping)" "(use 'mikera.image.core)" "(show (tgaa.util.shared/image-ref))" "(show (tgaa.util.image/show-segmentaton))" "(tgaa.util.image/show-segmentaton)" "(tgaa.util.image/show-all-cann-path)" "(tgaa.util.image/draw-all-can-paths)" "(import 'java.awt.Color)" "(tgaa.util.image/draw-all-can-paths)" "(tgaa.util.image/show-all-cann-path)" "(show (tgaa.util.shared/image-ref))" "(tgaa.util.image/show-all-cann-path)" "(phase/load-image)" "(phase/bootstrap)" " (phase/trapping)" "(tgaa.util.image/show-image)" "(tgaa.util.image/show-segmentaton)" "(tgaa.util.image/show-all-cann-path)" "(improt 'java.awt.Color)" "(import 'java.awt.Color)" "(tgaa.util.image/show-all-cann-path)" "tgaa.algo.ant" "tgaa.algo.ant/ant-trial-num" "(draw-can-paths)" "(tgaa.util.image/draw-can-paths)" "((tgaa.util.image/show-cann-path)" "(tgaa.util.image/show-cann-path)" "(tgaa.util.image/show-cann-path 1)" "(tgaa.util.image/show-cann-path 2)" "(tgaa.util.image/show-cann-path 3)" "(tgaa.util.image/show-cann-path 4)" "(tgaa.util.image/show-cann-path 5\\n                                )" "(tgaa.util.image/show-cann-path 10)" "(tgaa.util.image/show-cann-path 15)" "(tgaa.util.image/show-cann-path 20\\n                                )" "(tgaa.util.image/show-cann-path 50\\n                                )" "(tgaa.util.image/show-cann-path 10)" "(def config (get-config))" "(delay (print 101010) 10)" "(def dt (delay (print 101010) 10))" "@dt" "(def dt (delay (print 101010) 100))" "@dt" "(def dt (delay (print 101010) 10000))" "@dt" "(def dtt (delay (print 101010) 10000))" "@dtt" "(force dtt)" "(force @dtt)" "@dtt" "(do (Thread/sleep 500)(print 444))" "(do (Thread/sleep 5000)(print 444))" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.image/show-cann-path 10)" "(phase/load-image)" "(phase/bootstrap)" " (phase/trapping)" "(tgaa.util.image/show-cann-path 10)" "(tgaa.util.image/anim-trail-paths)" "(process-image)" "(tgaa.util.image/show-segmentaton)" "(tgaa.util.image/anim-trail-paths)" "(import 'java.awt.Color)" "(tgaa.util.image/anim-trail-paths)" "(process-image)" "(tgaa.util.image/anim-trail-paths)" "(import 'java.awt.Color)" "(tgaa.util.image/anim-trail-paths)" "(process-image)" "(import 'java.awt.Color)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.image/show-cann-path 1)" "(tgaa.util.image/show-cann-path 2)" "(tgaa.util.image/show-cann-path 3\\n                                )" "  (let [[start-x-1 start-y-1] [0 0]\\r\\n        [end-x-1 end-y-1] [4 4]\\r\\n        [start-x-2 start-y-2] [0 4]\\r\\n        [end-x-2 end-y-2] [4 0]]\\r\\n    (if (< start-x-1 start-x-2)\\r\\n      (if (> end-x-1 end-x-2)\\r\\n        (if (< start-y-1 start-y-2)\\r\\n          (> end-y-1 end-y-2)))))" "  (let [[start-x-1 start-y-1] [0 0]\\r\\n        [end-x-1 end-y-1] [4 4]\\r\\n        [start-x-2 start-y-2] [0 4]\\r\\n        [end-x-2 end-y-2] [4 0]]\\r\\n    (if (< start-x-1 start-x-2)\\r\\n      (if (> end-x-1 end-x-2)\\r\\n        (if (< start-y-1 start-y-2)\\r\\n          (> end-y-1 end-y-2) \\n          true))))" "  (let [[start-x-1 start-y-1] [3 1]\\r\\n        [end-x-1 end-y-1] [150 168]\\r\\n        [start-x-2 start-y-2] [148 3]\\r\\n        [end-x-2 end-y-2] [5 164]]\\r\\n    (if (< start-x-1 start-x-2)\\r\\n      (if (> end-x-1 end-x-2)\\r\\n        (if (< start-y-1 start-y-2)\\r\\n          (> end-y-1 end-y-2) \\n          true))))" "  (let [[start-x-1 start-y-1] [3 1]\\r\\n        [end-x-1 end-y-1] [121 119]\\r\\n        [start-x-2 start-y-2] [148 3]\\r\\n        [end-x-2 end-y-2] [5 164]]\\r\\n    (if (< start-x-1 start-x-2)\\r\\n      (if (> end-x-1 end-x-2)\\r\\n        (if (< start-y-1 start-y-2)\\r\\n          (> end-y-1 end-y-2) \\n          true))))" "  (let [[start-x-1 start-y-1] [3 1]\\r\\n        [end-x-1 end-y-1] [121 119]\\r\\n        [start-x-2 start-y-2] [148 3]\\r\\n        [end-x-2 end-y-2] [5 164]]\\r\\n    (if (< start-x-1 start-x-2)\\r\\n      (if (> end-x-1 end-x-2)\\r\\n        (if (< start-y-1 start-y-2)\\r\\n          (> end-y-1 end-y-2) \\n          true\\n          \\"test\\"))))" "  (let [[start-x-1 start-y-1] [3 1]\\r\\n        [end-x-1 end-y-1] [150 168]\\r\\n        [start-x-2 start-y-2] [148 3]\\r\\n        [end-x-2 end-y-2] [5 164]]\\r\\n    (if (< start-x-1 start-x-2)\\r\\n      (if (> end-x-1 end-x-2)\\r\\n        (if (< start-y-1 start-y-2)\\r\\n          (> end-y-1 end-y-2) \\n          true))))" "  (let [[start-x-1 start-y-1] [3 1]\\r\\n        [end-x-1 end-y-1] [121 119]\\r\\n        [start-x-2 start-y-2] [148 3]\\r\\n        [end-x-2 end-y-2] [5 164]]\\r\\n    (if (< start-x-1 start-x-2)\\r\\n      (if (> end-x-1 end-x-2)\\r\\n        (if (< start-y-1 start-y-2)\\r\\n          (> end-y-1 end-y-2) \\n          true))))" "  (let [[start-x-1 start-y-1] [3 1]\\r\\n        [end-x-1 end-y-1] [121 119]\\r\\n        [start-x-2 start-y-2] [148 3]\\r\\n        [end-x-2 end-y-2] [5 164]]\\r\\n    (if (< start-x-1 start-x-2)\\r\\n      (if (> end-x-1 end-x-2)\\r\\n        (if (< start-y-1 start-y-2)\\r\\n          (> end-y-1 end-y-2) \\n          true\\n          true))))" "  (let [[start-x-1 start-y-1] [3 1]\\r\\n        [end-x-1 end-y-1] [121 119]\\r\\n        [start-x-2 start-y-2] [148 3]\\r\\n        [end-x-2 end-y-2] [5 164]]\\r\\n    (if (< start-x-1 start-x-2)\\r\\n      (if (> end-x-1 end-x-2)\\r\\n        (if (< start-y-1 start-y-2)\\r\\n          (if (> end-y-1 end-y-2) \\n          true))))" "  (let [[start-x-1 start-y-1] [3 1]\\r\\n        [end-x-1 end-y-1] [121 119]\\r\\n        [start-x-2 start-y-2] [148 3]\\r\\n        [end-x-2 end-y-2] [5 164]]\\r\\n    (if (< start-x-1 start-x-2)\\r\\n      (if (> end-x-1 end-x-2)\\r\\n        (if (< start-y-1 start-y-2)\\r\\n          (if (> end-y-1 end-y-2) \\n          true)))))" "  (let [[start-x-1 start-y-1] [3 1]\\r\\n        [end-x-1 end-y-1] [150 168]\\r\\n        [start-x-2 start-y-2] [148 3]\\r\\n        [end-x-2 end-y-2] [5 164]]\\r\\n    (if (< start-x-1 start-x-2)\\r\\n      (if (> end-x-1 end-x-2)\\r\\n        (if (< start-y-1 start-y-2)\\r\\n          (if (> end-y-1 end-y-2) \\n          true)))))" "  (let [[start-x-1 start-y-1] [3 1]\\r\\n        [end-x-1 end-y-1] [121 119]\\r\\n        [start-x-2 start-y-2] [148 3]\\r\\n        [end-x-2 end-y-2] [5 164]]\\r\\n    (if (< start-x-1 start-x-2)\\r\\n      (if (> end-x-1 end-x-2)\\r\\n        (if (< start-y-1 start-y-2)\\r\\n          (if (> end-y-1 end-y-2) \\n          true)))))" "  (let [[start-x-1 start-y-1] [3 1]\\r\\n        [end-x-1 end-y-1] [121 119]\\r\\n        [start-x-2 start-y-2] [148 3]\\r\\n        [end-x-2 end-y-2] [5 164]]\\r\\n    (if (< start-x-1 start-x-2)\\r\\n      (if (> end-x-1 end-x-2)\\r\\n        (if (< start-y-1 start-y-2)\\r\\n          (if (> end-y-1 end-y-2) \\n          true\\n          \\"tet\\")))))" "  (let [[start-x-1 start-y-1] [3 1]\\r\\n        [end-x-1 end-y-1] [121 119]\\r\\n        [start-x-2 start-y-2] [148 3]\\r\\n        [end-x-2 end-y-2] [5 164]]\\r\\n    (if (< start-x-1 start-x-2)\\r\\n      (if (> end-x-1 end-x-2)\\r\\n        (if (< start-y-1 start-y-2)) \\n          true\\n          )))" "  (let [[start-x-1 start-y-1] [3 1]\\r\\n        [end-x-1 end-y-1] [121 119]\\r\\n        [start-x-2 start-y-2] [148 3]\\r\\n        [end-x-2 end-y-2] [5 164]]\\r\\n    (if (< start-x-1 start-x-2)\\r\\n      (if (> end-x-1 end-x-2)\\r\\n        (if (< start-y-1 start-y-2)) \\n          true\\n          \\"more\\"\\n          )))" "  (let [[start-x-1 start-y-1] [3 1]\\r\\n        [end-x-1 end-y-1] [121 119]\\r\\n        [start-x-2 start-y-2] [148 3]\\r\\n        [end-x-2 end-y-2] [5 164]]\\r\\n    (if (< start-x-1 start-x-2)\\r\\n      (if (> end-x-1 end-x-2)\\r\\n        (if (< start-y-1 start-y-2))\\n          true\\n          \\"more\\"\\n          )))" "  (let [[start-x-1 start-y-1] [3 1]\\r\\n        [end-x-1 end-y-1] [121 119]\\r\\n        [start-x-2 start-y-2] [148 3]\\r\\n        [end-x-2 end-y-2] [5 164]]\\r\\n    (if (< start-x-1 start-x-2)\\r\\n      (if (> end-x-1 end-x-2)\\r\\n        (if (< start-y-1 start-y-2)\\n          true\\n          \\"more\\"\\n          )))" "  (let [[start-x-1 start-y-1] [3 1]\\r\\n        [end-x-1 end-y-1] [121 119]\\r\\n        [start-x-2 start-y-2] [148 3]\\r\\n        [end-x-2 end-y-2] [5 164]]\\r\\n    (if (< start-x-1 start-x-2)\\r\\n      (if (> end-x-1 end-x-2)\\r\\n        (if (< start-y-1 start-y-2)\\r\\n          (if (> end-y-1 end-y-2) \\n          true)))))" "  (let [[start-x-1 start-y-1] [3 1]\\r\\n        [end-x-1 end-y-1] [121 119]\\r\\n        [start-x-2 start-y-2] [148 3]\\r\\n        [end-x-2 end-y-2] [5 164]]\\r\\n    (if (< start-x-1 start-x-2)\\r\\n      (if (> end-x-1 end-x-2)\\r\\n        (if (< start-y-1 start-y-2)\\r\\n          true))))" "  (let [[start-x-1 start-y-1] [3 1]\\r\\n        [end-x-1 end-y-1] [52 52]\\r\\n        [start-x-2 start-y-2] [148 3]\\r\\n        [end-x-2 end-y-2] [5 164]]\\r\\n    (if (< start-x-1 start-x-2)\\r\\n      (if (> end-x-1 end-x-2)\\r\\n        (if (< start-y-1 start-y-2)\\r\\n          true))))" "(keys tgaa.util.shared/trial-state)" "(keys @tgaa.util.shared/trial-state)" "(first (\:cand-paths` @tgaa.util.shared/trial-state))" "(\:cand-paths` @tgaa.util.shared/trial-state)" "  (let [[start-x-1 start-y-1] [3 1]\\r\\n        [end-x-1 end-y-1] [52 52]\\r\\n        [start-x-2 start-y-2] [148 3]\\r\\n        [end-x-2 end-y-2] [5 164]]\\r\\n    (and (<\= start-x-1 end-x-2)\\n         (>\= end-x-1 start-x-2)\\n         (<\= start-y-1 end-y-2)\\n         (>\= end-y-1 start-y-2)))" "  (let [[start-x-1 start-y-1] [3 1]\\r\\n        [end-x-1 end-y-1] [121 119]\\r\\n        [start-x-2 start-y-2] [148 3]\\r\\n        [end-x-2 end-y-2] [5 164]]\\r\\n    (and (<\= start-x-1 end-x-2)\\n         (>\= end-x-1 start-x-2)\\n         (<\= start-y-1 end-y-2)\\n         (>\= end-y-1 start-y-2)))" "(defn is-crossed [path-1 path-2]\\r\\n  (let [[start-x-1 start-y-1] (ant/ant-start-point path-1)\\r\\n        [end-x-1 end-y-1] (ant/ant-end-point path-1)\\r\\n        [start-x-2 start-y-2] (ant/ant-start-point path-2)\\r\\n        [end-x-2 end-y-2] (ant/ant-end-point path-2)]\\r\\n    (and (<\= start-x-1 end-x-2)\\r\\n         (>\= end-x-1 start-x-2)\\r\\n         (<\= start-y-1 end-y-2)\\r\\n         (>\= end-y-1 start-y-2))))" "(first (\:cand-paths` @tgaa.util.shared/trial-state))" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(first (\:cand-paths` @tgaa.util.shared/trial-state))" "((\:cand-paths` @tgaa.util.shared/trial-state)" "(\:cand-paths` @tgaa.util.shared/trial-state)" "(first (\:cand-paths @tgaa.util.shared/trial-state))" "(filter \#(\= (\:trail-num %) 50) (\:cand-paths @tgaa.util.shared/trial-state))" "(filter \#(\= (\:trail-num %) 49) (\:cand-paths @tgaa.util.shared/trial-state))" "(filter \#(\= (\:trial-num %) 49) (\:cand-paths @tgaa.util.shared/trial-state))" "(count (filter \#(\= (\:trial-num %) 49) (\:cand-paths @tgaa.util.shared/trial-state)))" "(count (filter \#(\= (\:trial-num %) 50) (\:cand-paths @tgaa.util.shared/trial-state)))" "(count (filter \#(\= (\:trial-num %) 48) (\:cand-paths @tgaa.util.shared/trial-state)))" "(apply count (filter \#(\= (\:trial-num %) 50) (\:cand-paths @tgaa.util.shared/trial-state)))" "(filter \#(\= (\:trial-num %) 50) (\:cand-paths @tgaa.util.shared/trial-state))" "(filter \#(\= (\:trial-num %) 0) (\:cand-paths @tgaa.util.shared/trial-state))" "(filter \#(\= (\:trial-num %) 1) (\:cand-paths @tgaa.util.shared/trial-state))" "(tgaa.util.image/anim-trail-paths)" "(filter \#(\= (\:trial-num %) 25) (\:cand-paths @tgaa.util.shared/trial-state))" "(tgaa.util.image/show-cann-path 25)" "(filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (\:cand-paths @tgaa.util.shared/trial-state))" "(let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (\:cand-paths @tgaa.util.shared/trial-state))\\n      len (dec (count est-can))]\\n  (loop [i 0 grouped est-can]\\n    (if (> i len)\\n      grouped\\n      (recur (inc i) \\n             (map \#(tgaa.algo.ant/ant-group i)" "(in-ns 'tgaa.util.ant-path)" "(ns)" "(ns-name)" "(let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (\:cand-paths @tgaa.util.shared/trial-state))]\\n  (" "(defn is-boxed [path-1 path-2]\\r\\n  (let [[start-x-1 start-y-1] (ant/ant-start-point path-1)\\r\\n        [end-x-1 end-y-1] (ant/ant-end-point path-1)\\r\\n        [start-x-2 start-y-2] (ant/ant-start-point path-2)\\r\\n        [end-x-2 end-y-2] (ant/ant-end-point path-2)]\\r\\n    (and (<\= start-x-1 end-x-2)\\r\\n         (>\= end-x-1 start-x-2)\\r\\n         (<\= start-y-1 end-y-2)\\r\\n         (>\= end-y-1 start-y-2))))\\r\\n\\r\\n(defn group-path [ref-path cann]\\r\\n  (split-with \#(is-boxed ref-path %) cann))" "(let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (\:cand-paths @tgaa.util.shared/trial-state))]\\n  (group-path (first est-can) est-can))" "(let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (\:cand-paths @tgaa.util.shared/trial-state))]\\n  (apply count (group-path (first est-can) est-can)))" "(let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (\:cand-paths @tgaa.util.shared/trial-state))]\\n  (map count (group-path (first est-can) est-can)))" "(let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (\:cand-paths @tgaa.util.shared/trial-state))]\\n  (map count (group-path (second est-can) est-can)))" "(let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (\:cand-paths @tgaa.util.shared/trial-state))]\\n  (map count (group-path (nth est-can 5) est-can)))" "(let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (\:cand-paths @tgaa.util.shared/trial-state))]\\n  (map count (group-path (nth est-can 10) est-can)))" "(let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (\:cand-paths @tgaa.util.shared/trial-state))]\\n  (map count (group-path (nth est-can 14) est-can)))" "(let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (\:cand-paths @tgaa.util.shared/trial-state))]\\n  (map count (group-path (nth est-can 20) est-can)))" "(count (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25))" "(count (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25)))" "(count (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (\:cand-paths @tgaa.util.shared/trial-state)))" "(let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (\:cand-paths @tgaa.util.shared/trial-state))]\\n  (map count (group-path (nth est-can 20) est-can)))" "(defn est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (\:cand-paths @tgaa.util.shared/trial-state)))" "(def est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (\:cand-paths @tgaa.util.shared/trial-state)))" "(is-boxed (first est-can) (first est-can))" "(is-boxed (first est-can) (second est-can))" "(is-boxed (second est-can) (first est-can))" "(is-boxed (second est-can) (second est-can))" "(second est-can)" "(defn is-boxed [path-1 path-2]\\r\\n  (let [[start-x-1 start-y-1] (ant/ant-start-point path-1)\\r\\n        [end-x-1 end-y-1] (ant/ant-end-point path-1)\\r\\n        [start-x-2 start-y-2] (ant/ant-start-point path-2)\\r\\n        [end-x-2 end-y-2] (ant/ant-end-point path-2)\\n        [leftmost-x-1 rightmost-x-1] (if (< start-x-1 end-x-1) [start-x-1 end-x-1] [end-x-1 start-x-1])\\n        [highest-y-1 lowest-y-1] (if (< start-y-1 end-y-1) [start-y-1 end-y-1] [end-y-1 start-y-1])\\n        [leftmost-x-2 rightmost-x-2] (if (< start-x-2 end-x-2) [start-x-2 end-x-2] [end-x-2 start-x-2])\\r\\n        [highest-y-2 lowest-y-2] (if (< start-y-2 end-y-2) [start-y-2 end-y-2] [end-y-2 start-y-2])]\\r\\n    (and (<\= leftmost-x-1 rightmost-x-2)\\r\\n         (>\= rightmost-x-1 leftmost-x-2)\\r\\n         (<\= highest-y-1 lowest-y-2)\\r\\n         (>\= lowest-y-1 highest-y-2))))" "(is-boxed (second est-can) (second est-can))" "(is-boxed (second est-can) (first est-can))" "(let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (\:cand-paths @tgaa.util.shared/trial-state))]\\n  (map count (group-path (nth est-can 20) est-can)))" "(is-boxed (second est-can) (first est-can))" "(is-boxed (second est-can) (second est-can))" "(is-boxed (first est-can) (first est-can))" "(let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (\:cand-paths @tgaa.util.shared/trial-state))]\\n  (map count (group-path (nth est-can 1) est-can)))" "(let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (\:cand-paths @tgaa.util.shared/trial-state))]\\n  (map count (group-path (nth est-can 0) est-can)))" "(let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (\:cand-paths @tgaa.util.shared/trial-state))]\\n  (map count (group-path (nth est-can 2) est-can)))" "(group-path (nth est-can 2) est-can)" "(count (group-path (nth est-can 2) est-can))" "(apply count (group-path (nth est-can 2) est-can))" "(map count (group-path (nth est-can 2) est-can))" "(map count (group-path (nth est-can 0) est-can))" "(is-boxed (nth est-can 0) est-can)" "(is-boxed (nth est-can 0) (nth est-can 0))" "(is-boxed (nth est-can 0) (nth est-can 1))" "(is-boxed (nth est-can 0) (nth est-can 2))" "(is-boxed (nth est-can 0) (nth est-can 3))" "(is-boxed (nth est-can 0) (nth est-can 4))" "(is-boxed (nth est-can 0) (nth est-can 5))" "(is-boxed (nth est-can 0) (nth est-can 6))" "(is-boxed (nth est-can 6) (nth est-can 6))" "(map count (group-path (nth est-can 6) est-can))" "(split-with \#(> 5 %) (range 10))" "(map count (split-with \#(> 5 %) (range 10)))" "(map count (group-path (nth est-can 2) est-can))" "(map count (group-path (nth est-can 0) est-can))" "(map count (group-path (nth est-can 10) est-can))" "(map count (group-path (nth est-can 27) est-can))" "(map count (group-path (nth est-can 26) est-can))" "(map count (filter  \#(is-boxed (nth est-can 0) %) est-can))" "(filter  \#(is-boxed (nth est-can 0) %) est-can)" "(map count (filter  \#(is-boxed (nth est-can 0) %) est-can))" "(map count (filter  \#(is-boxed (nth est-can 1) %) est-can))" "(count (filter  \#(is-boxed (nth est-can 1) %) est-can))" "(count (filter  \#(is-boxed (nth est-can 0) %) est-can))" "(count (filter  \#(is-boxed (nth est-can 10) %) est-can))" "(apply count (filter  \#(split-with (nth est-can 10) %) est-can))" "( count (filter  \#(split-with (nth est-can 10) %) est-can))" "( count (filter  \#(split-by (nth est-can 10) %) est-can))" "(apply count (filter  \#(split-by (nth est-can 10) %) est-can))" "(apply count (split-with  \#(is-boxed (nth est-can 10) %) est-can))" "(map count (split-with  \#(is-boxed (nth est-can 10) %) est-can))" "(map count (split-with  (partial is-boxed (nth est-can 10)) est-can))" "(apply count (filter  \#(split-by (nth est-can 10) %) est-can))" "( count (filter  \#(split-by (nth est-can 10) %) est-can))" "(count (filter  \#(is-boxed (nth est-can 0) %) est-can))" "(count (filter  \#(is-boxed (nth est-can 1) %) est-can))" "(count (split-with  \#(is-boxed (nth est-can 1) %) est-can))" "(apply count (split-with  \#(is-boxed (nth est-can 1) %) est-can))" "(map count (split-with  \#(is-boxed (nth est-can 1) %) est-can))" "(map count (filter  \#(is-boxed (nth est-can 1) %) est-can))" "(map count (split-with  (partial is-boxed (nth est-can 1)) est-can))" "(nth est-can 1)" "(map count (split-with  (partial is-boxed {\:path-length 31,\\r\\n \:local-max [184 376],\\r\\n \:local-min [214 376],\\r\\n \:end [184 376],\\r\\n \:start [214 376],\\r\\n \:dir [-1 0],\\r\\n \:thresh? true,\\r\\n \:trial-num 25}) est-can))" "(map count (split-with  (partial is-boxed (nth est-can 1)) est-can))" "(map count (filter  \#(is-boxed (nth est-can 1) %) est-can))" "(count (filter  \#(is-boxed (nth est-can 1) %) est-can))" "(count (filter  \#(is-boxed (nth est-can 10) %) est-can))" "(class est-can)" "(count (filter  \#(is-boxed (nth est-can 10) %) est-can))" "(count (take-while  \#(is-boxed (nth est-can 10) %) est-can))" "(defn drop-one\\r\\n  [coll]\\r\\n  (when-let [s (seq coll)]\\r\\n    (rest s)))" "(drop-one [1 2 3])" "(when-let [s [1 2 3]]\\r\\n  (rest s))" "(count (filter  \#(is-boxed (nth est-can 10) %) est-can))" "(map  \#(is-boxed (nth est-can 10) %) est-can)" "(count (filter  \#(is-boxed (nth est-can 10) %) est-can))" "(count (split-with  (fn [x] (is-boxed (nth est-can 10) x)) est-can))" "(map count (split-with  (fn [x] (is-boxed (nth est-can 10) x)) est-can))" "(loop [to-group est-can class [] non-class est-can]\\n   (if (empty? cann)\\n     {\:class class  \:non-class non-class}\\n     (recur (rest to-group) \\n            (cons(filter  \#(is-boxed (first to-group) %) non-class)" "(const [1] [1 2])" "(cons\\n  [1] [1 2])" "(apply cons [1] [1 2])" "(apply conj [1] [1 2])" "(apply conj [1 4] [1 2])" "(loop [to-group est-can class [] non-class est-can]\\n   (if (empty? cann)\\n     {\:class class  \:non-class non-class}\\n     (recur (rest to-group) \\n            (conj class (filter  \#(is-boxed (first to-group) %) non-class))\\n            (conj class (filter  \#(not (is-boxed (first to-group) %)) non-class))" "(loop [to-group est-can class [] non-class est-can]\\n   (if (empty? cann)\\n     {\:class class  \:non-class non-class}\\n     (recur (rest to-group) \\n            (conj class (filter  \#(is-boxed (first to-group) %) non-class))\\n            (conj class (filter  \#(not (is-boxed (first to-group) %)) non-class)))))" "(loop [to-group est-can class [] non-class est-can]\\n   (if (empty? to-group)\\n     {\:class class  \:non-class non-class}\\n     (recur (rest to-group) \\n            (conj class (filter  \#(is-boxed (first to-group) %) non-class))\\n            (conj class (filter  \#(not (is-boxed (first to-group) %)) non-class)))))" "(loop [to-group est-can class [] non-class est-can]\\n   (if (empty? to-group)\\n     {\:class class  \:non-class non-class}\\n     (recur (rest to-group) \\n            (conj class (filter  \#(is-boxed (first to-group) %) non-class))\\n            (filter  \#(not (is-boxed (first to-group) %)) non-class))))" "(loop [to-group est-can class [] non-class est-can]\\n   (if (empty? to-group)\\n     {\:class class  \:non-class non-class}\\n            (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)]\\n              (if (not (empty? filter-group)\\n                  (recur (rest to-group) \\n                         (conj class (filter  \#(is-boxed (first to-group) %) non-class))\\n                         (filter  \#(not (is-boxed (first to-group) %)) non-class))\\n                  (recur (rest to-group)\\n                         non-class\\n                         est-can))))))" "(loop [to-group est-can class [] non-class est-can]\\n   (if (empty? to-group)\\n     {\:class class  \:non-class non-class}\\n            (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)]\\n              (if (not (empty? filter-group))\\n                  (recur (rest to-group) \\n                         (conj class (filter  \#(is-boxed (first to-group) %) non-class))\\n                         (filter  \#(not (is-boxed (first to-group) %)) non-class))\\n                  (recur (rest to-group)\\n                         non-class\\n                         est-can)))))" "(loop [to-group est-can class [] non-class est-can]\\n   (if (empty? to-group)\\n     {\:class class  \:non-class non-class}\\n            (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)]\\n              (if (not (empty? filter-group))\\n                  (recur (rest to-group) \\n                         (conj class filter-group)\\n                         (filter  \#(not (is-boxed (first to-group) %)) non-class))\\n                  (recur (rest to-group)\\n                         non-class\\n                         est-can)))))" "(def t (loop [to-group est-can class [] non-class est-can]\\n          (if (empty? to-group)\\n            {\:class class  \:non-class non-class}\\n                   (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)]\\n                     (if (not (empty? filter-group))\\n                         (recur (rest to-group) \\n                                (conj class filter-group)\\n                                (filter  \#(not (is-boxed (first to-group) %)) non-class))\\n                         (recur (rest to-group)\\n                                non-class\\n                                est-can))))))" "(map count t)" "(map (\:class t))" "(count count t)" "(count (\:class t))" "(count (\:non-class t))" "(count est-can)" "(def t (loop [to-group est-can class [] non-class est-can]\\n          (if (empty? to-group)\\n            {\:class class  \:non-class non-class}\\n                   (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)\\n                         _ (print \\"found \: \\" (count filter-group))]\\n                     (if (not (empty? filter-group))\\n                         (recur (rest to-group) \\n                                (conj class filter-group)\\n                                (filter  \#(not (is-boxed (first to-group) %)) non-class))\\n                         (recur (rest to-group)\\n                                non-class\\n                                est-can))))))" "(def t (loop [to-group est-can class [] non-class est-can]\\n          (if (empty? to-group)\\n            {\:class class  \:non-class non-class}\\n                   (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)]\\n                     (if (not (empty? filter-group))\\n                         (recur (rest to-group) \\n                                (apply conj class filter-group)\\n                                (filter  \#(not (is-boxed (first to-group) %)) non-class))\\n                         (recur (rest to-group)\\n                                non-class\\n                                est-can))))))" "(count (\:non-class t))" "(count (\:class t))" "t" "(def t \\n  (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 10) (tgaa.util.shared/canidates))]\\n  (loop [to-group est-can class [] non-class est-can]\\n     (if (empty? to-group)\\n       {\:class class  \:non-class non-class}\\n              (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)]\\n                (if (not (empty? filter-group))\\n                    (recur (rest to-group) \\n                           (apply conj class filter-group)\\n                           (filter  \#(not (is-boxed (first to-group) %)) non-class))\\n                    (recur (rest to-group)\\n                           non-class\\n                           est-can)))))))" "(count (\:class t))" "(count (\:non-class t))" "(def t \\n  (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 5) (tgaa.util.shared/canidates))]\\n  (loop [to-group est-can class [] non-class est-can]\\n     (if (empty? to-group)\\n       {\:class class  \:non-class non-class}\\n              (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)]\\n                (if (not (empty? filter-group))\\n                    (recur (rest to-group) \\n                           (apply conj class filter-group)\\n                           (filter  \#(not (is-boxed (first to-group) %)) non-class))\\n                    (recur (rest to-group)\\n                           non-class\\n                           est-can)))))))" "(count (\:non-class t))" "(count (\:class t))" "(tgaa.util.image/show-cann-path 5)" "(import 'java.awt.Color)" "(tgaa.util.image/show-cann-path 5)" "(tgaa.util.image/show-cann-path 10)" "(def t \\n  (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 15) (tgaa.util.shared/canidates))]\\n  (loop [to-group est-can class [] non-class est-can]\\n     (if (empty? to-group)\\n       {\:class class  \:non-class non-class}\\n              (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)]\\n                (if (not (empty? filter-group))\\n                    (recur (rest to-group) \\n                           (apply conj class filter-group)\\n                           (filter  \#(not (is-boxed (first to-group) %)) non-class))\\n                    (recur (rest to-group)\\n                           non-class\\n                           est-can)))))))" "(count (\:class t))" "(count (\:non-class t))" "(tgaa.util.image/show-cann-path 15)" "(def t \\n  (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 15) (tgaa.util.shared/canidates))]\\n  (loop [to-group (first est-can) class [] non-class est-can]\\n     (if (empty? to-group)\\n       {\:class class  \:non-class non-class}\\n              (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)]\\n                (if (not (empty? filter-group))\\n                    (recur (apply conj filter-group (rest to-group))\\n                           (apply conj class filter-group)\\n                           (filter  \#(not (is-boxed (first to-group) %)) non-class))\\n                    (recur (rest to-group)\\n                           non-class\\n                           est-can)))))))" "(def t \\n  (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 15) (tgaa.util.shared/canidates))]\\n  (loop [to-group (first est-can) class [] non-class est-can]\\n     (if (empty? to-group)\\n       {\:class class  \:non-class non-class}\\n              (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)\\n                    _ (print \\"hear\\")]\\n                (if (not (empty? filter-group))\\n                    (recur (apply conj filter-group (rest to-group))\\n                           (apply conj class filter-group)\\n                           (filter  \#(not (is-boxed (first to-group) %)) non-class))\\n                    (recur (rest to-group)\\n                           non-class\\n                           est-can)))))))" "(def t \\n  (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 15) (tgaa.util.shared/canidates))]\\n  (loop [to-group [(first est-can)] class [] non-class est-can]\\n     (if (empty? to-group)\\n       {\:class class  \:non-class non-class}\\n              (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)\\n                    _ (print \\"hear\\")]\\n                (if (not (empty? filter-group))\\n                    (recur (apply conj filter-group (rest to-group))\\n                           (apply conj class filter-group)\\n                           (filter  \#(not (is-boxed (first to-group) %)) non-class))\\n                    (recur (rest to-group)\\n                           non-class\\n                           est-can)))))))" "(def t \\n  (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 15) (tgaa.util.shared/canidates))]\\n  (loop [to-group [(first est-can)] class [] non-class est-can]\\n     (if (empty? to-group)\\n       {\:class class  \:non-class non-class}\\n              (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)\\n                    _ (print \\"hear\\" (rest to-group))]\\n                (if (not (empty? filter-group))\\n                    (recur (apply conj filter-group (rest to-group))\\n                           (apply conj class filter-group)\\n                           (filter  \#(not (is-boxed (first to-group) %)) non-class))\\n                    (recur (rest to-group)\\n                           non-class\\n                           est-can)))))))" "(def t \\n  (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (tgaa.util.shared/canidates))]\\n  (loop [to-group [(first est-can)] class [] non-class est-can]\\n     (if (empty? to-group)\\n       {\:class class  \:non-class non-class}\\n              (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)\\n                    _ (print \\"hear\\" (rest to-group))]\\n                (if (not (empty? filter-group))\\n                    (recur (apply conj filter-group (rest to-group))\\n                           (apply conj class filter-group)\\n                           (filter  \#(not (is-boxed (first to-group) %)) non-class))\\n                    (recur (rest to-group)\\n                           non-class\\n                           est-can)))))))" "(apply conj [1 2 2] [])" "(apply conj [][1 2 2])" "(def t \\n  (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (tgaa.util.shared/canidates))]\\n  (loop [to-group [(first est-can)] class [] non-class est-can]\\n     (if (empty? to-group)\\n       {\:class class  \:non-class non-class}\\n              (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)\\n                    _ (print \\"hear\\" (rest to-group))]\\n                (if (not (empty? filter-group))\\n                    (recur (apply conj  (rest to-group) filter-group )\\n                           (apply conj class filter-group)\\n                           (filter  \#(not (is-boxed (first to-group) %)) non-class))\\n                    (recur (rest to-group)\\n                           non-class\\n                           est-can)))))))" "\=> (def t \\n     (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (tgaa.util.shared/canidates))]\\n     (loop [to-group [(first est-can)] class [] non-class (rest est-can)]\\n        (if (empty? to-group)\\n          {\:class class  \:non-class non-class}\\n                 (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)\\n                       _ (print \\"test\\")]\\n                   (if (not (empty? filter-group))\\n                       (recur (apply conj  (rest to-group) filter-group )\\n                              (apply conj class filter-group)\\n                              (filter  \#(not (is-boxed (first to-group) %)) non-class))\\n                       (recur (rest to-group)\\n                              non-class\\n                              est-can)))))))" "\=> (def t \\n     (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (tgaa.util.shared/canidates))]\\n     (loop [to-group [(first est-can)] class [] non-class (rest est-can)]\\n        (if (empty? to-group)\\n          {\:class class  \:non-class non-class}\\n                 (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)\\n                       _ (println \\"test\:\\" (count filter-group))]\\n                   (if (not (empty? filter-group))\\n                       (recur (apply conj  (rest to-group) filter-group )\\n                              (apply conj class filter-group)\\n                              (filter  \#(not (is-boxed (first to-group) %)) non-class))\\n                       (recur (rest to-group)\\n                              non-class\\n                              est-can)))))))" "\=> (def t \\n     (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (tgaa.util.shared/canidates))]\\n     (loop [to-group [(first est-can)] class [] non-class (rest est-can)]\\n        (if (empty? to-group)\\n          {\:class class  \:non-class non-class}\\n                 (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)\\n                       _ (println \\"test\:\\" (count filter-group))]\\n                   (if (not (empty? filter-group))\\n                       (recur (apply conj  (rest to-group) filter-group )\\n                              (apply conj class filter-group)\\n                              (filter  \#(not (is-boxed (first to-group) %)) non-class))\\n                       (recur (rest to-group)\\n                              class\\n                              non-class)))))))" "(+ 1 1)" "\=> (def t \\r\\n     (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (tgaa.util.shared/canidates))]\\r\\n     (loop [to-group [(first est-can)] class [] non-class (rest est-can)]\\r\\n        (if (empty? to-group)\\r\\n          {\:class class  \:non-class non-class}\\r\\n                 (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)\\r\\n                       _ (println \\"test\:\\" (count filter-group))]\\r\\n                   (if (not (empty? filter-group))\\r\\n                       (recur (apply conj  (rest to-group) filter-group )\\r\\n                              (apply conj class filter-group)\\r\\n                              (filter  \#(not (is-boxed (first to-group) %)) non-class))\\r\\n                       (recur (rest to-group)\\r\\n                              class\\r\\n                              non-class)))))))" "(process-image)" "\=> (def t \\r\\n     (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (tgaa.util.shared/canidates))]\\r\\n     (loop [to-group [(first est-can)] class [] non-class (rest est-can)]\\r\\n        (if (empty? to-group)\\r\\n          {\:class class  \:non-class non-class}\\r\\n                 (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)\\r\\n                       _ (println \\"test\:\\" (count filter-group))]\\r\\n                   (if (not (empty? filter-group))\\r\\n                       (recur (apply conj  (rest to-group) filter-group )\\r\\n                              (apply conj class filter-group)\\r\\n                              (filter  \#(not (is-boxed (first to-group) %)) non-class))\\r\\n                       (recur (rest to-group)\\r\\n                              class\\r\\n                              non-class)))))))" "(def t \\r\\n     (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (tgaa.util.shared/canidates))]\\r\\n     (loop [to-group [(first est-can)] class [] non-class (rest est-can)]\\r\\n        (if (empty? to-group)\\r\\n          {\:class class  \:non-class non-class}\\r\\n                 (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)\\r\\n                       _ (println \\"test\:\\" (count filter-group))]\\r\\n                   (if (not (empty? filter-group))\\r\\n                       (recur (apply conj  (rest to-group) filter-group )\\r\\n                              (apply conj class filter-group)\\r\\n                              (filter  \#(not (is-boxed (first to-group) %)) non-class))\\r\\n                       (recur (rest to-group)\\r\\n                              class\\r\\n                              non-class)))))))" "(def t \\r\\n     (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (tgaa.util.shared/canidates))]\\r\\n     (loop [to-group [(first est-can)] class [] non-class (rest est-can)]\\r\\n        (if (empty? to-group)\\r\\n          {\:class class  \:non-class non-class}\\r\\n                 (let [filter-group (filter  \#(tgaa.algo.trial/is-boxed (first to-group) %) non-class)\\r\\n                       _ (println \\"test\:\\" (count filter-group))]\\r\\n                   (if (not (empty? filter-group))\\r\\n                       (recur (apply conj  (rest to-group) filter-group )\\r\\n                              (apply conj class filter-group)\\r\\n                              (filter  \#(not (tgaa.algo.trial/is-boxed (first to-group) %)) non-class))\\r\\n                       (recur (rest to-group)\\r\\n                              class\\r\\n                              non-class)))))))" "(def t \\r\\n     (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (tgaa.util.shared/canidates))]\\r\\n     (loop [to-group [(first est-can)] class [] non-class (rest est-can)]\\r\\n        (if (empty? to-group)\\r\\n          {\:class class  \:non-class non-class}\\r\\n                 (let [filter-group (filter  \#(tgaa.algo.trial/is-boxed (first to-group) %) non-class)]\\r\\n                   (if (not (empty? filter-group))\\r\\n                       (recur (apply conj  (rest to-group) filter-group )\\r\\n                              (apply conj class filter-group)\\r\\n                              (filter  \#(not (tgaa.algo.trial/is-boxed (first to-group) %)) non-class))\\r\\n                       (recur (rest to-group)\\r\\n                              class\\r\\n                              non-class)))))))" "(count (\:non-class t))" "(count (\:class t))" "(tgaa.util.image/show-cann-path 25)" "(import 'java.awt.Color)" "(tgaa.util.image/show-cann-path 25)" "(def t \\r\\n     (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 10) (tgaa.util.shared/canidates))]\\r\\n     (loop [to-group [(first est-can)] class [] non-class (rest est-can)]\\r\\n        (if (empty? to-group)\\r\\n          {\:class class  \:non-class non-class}\\r\\n                 (let [filter-group (filter  \#(tgaa.algo.trial/is-boxed (first to-group) %) non-class)]\\r\\n                   (if (not (empty? filter-group))\\r\\n                       (recur (apply conj  (rest to-group) filter-group )\\r\\n                              (apply conj class filter-group)\\r\\n                              (filter  \#(not (tgaa.algo.trial/is-boxed (first to-group) %)) non-class))\\r\\n                       (recur (rest to-group)\\r\\n                              class\\r\\n                              non-class)))))))" "(count (\:class t))" "(count (\:non-class t))" "(tgaa.util.image/show-cann-path 10)" "(def t \\r\\n     (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 10) (tgaa.util.shared/canidates))]\\r\\n     (loop [to-group [(first est-can)] class [(first est-can)] non-class (rest est-can)]\\r\\n        (if (empty? to-group)\\r\\n          {\:class class  \:non-class non-class}\\r\\n                 (let [filter-group (filter  \#(tgaa.algo.trial/is-boxed (first to-group) %) non-class)]\\r\\n                   (if (not (empty? filter-group))\\r\\n                       (recur (apply conj  (rest to-group) filter-group )\\r\\n                              (apply conj class filter-group)\\r\\n                              (filter  \#(not (tgaa.algo.trial/is-boxed (first to-group) %)) non-class))\\r\\n                       (recur (rest to-group)\\r\\n                              class\\r\\n                              non-class)))))))" "(count (\:class t))" "(def t \\r\\n     (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 1) (tgaa.util.shared/canidates))]\\r\\n     (loop [to-group [(first est-can)] class [(first est-can)] non-class (rest est-can)]\\r\\n        (if (empty? to-group)\\r\\n          {\:class class  \:non-class non-class}\\r\\n                 (let [filter-group (filter  \#(tgaa.algo.trial/is-boxed (first to-group) %) non-class)]\\r\\n                   (if (not (empty? filter-group))\\r\\n                       (recur (apply conj  (rest to-group) filter-group )\\r\\n                              (apply conj class filter-group)\\r\\n                              (filter  \#(not (tgaa.algo.trial/is-boxed (first to-group) %)) non-class))\\r\\n                       (recur (rest to-group)\\r\\n                              class\\r\\n                              non-class)))))))" "(count (\:class t))" "(count (\:non-class t))" "(tgaa.util.image/show-cann-path 1)" "(tgaa.util.image/show-cann-path 2)" "(def t \\r\\n     (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 2) (tgaa.util.shared/canidates))]\\r\\n     (loop [to-group [(first est-can)] class [(first est-can)] non-class (rest est-can)]\\r\\n        (if (empty? to-group)\\r\\n          {\:class class  \:non-class non-class}\\r\\n                 (let [filter-group (filter  \#(tgaa.algo.trial/is-boxed (first to-group) %) non-class)]\\r\\n                   (if (not (empty? filter-group))\\r\\n                       (recur (apply conj  (rest to-group) filter-group )\\r\\n                              (apply conj class filter-group)\\r\\n                              (filter  \#(not (tgaa.algo.trial/is-boxed (first to-group) %)) non-class))\\r\\n                       (recur (rest to-group)\\r\\n                              class\\r\\n                              non-class)))))))" "(count (\:non-class t))" "(count (\:class t))" "(tgaa.util.image/show-cann-path 2)" "(tgaa.util.image/show-cann-path 3)" "(def t \\r\\n     (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 3) (tgaa.util.shared/canidates))]\\r\\n     (loop [to-group [(first est-can)] class [(first est-can)] non-class (rest est-can)]\\r\\n        (if (empty? to-group)\\r\\n          {\:class class  \:non-class non-class}\\r\\n                 (let [filter-group (filter  \#(tgaa.algo.trial/is-boxed (first to-group) %) non-class)]\\r\\n                   (if (not (empty? filter-group))\\r\\n                       (recur (apply conj  (rest to-group) filter-group )\\r\\n                              (apply conj class filter-group)\\r\\n                              (filter  \#(not (tgaa.algo.trial/is-boxed (first to-group) %)) non-class))\\r\\n                       (recur (rest to-group)\\r\\n                              class\\r\\n                              non-class)))))))" "(count (\:class t))" "(count (\:non-class t))" "(tgaa.util.image/show-cann-path 3)" "(defn group [non-group]\\r\\n     (loop [to-group [(first non-group)] grouping [(first non-group)] working-non-group (rest non-group)]\\r\\n        (if (empty? to-group)\\r\\n          {\:group grouping  \:non-group working-non-group}\\r\\n                 (let [filter-group (filter  \#(tgaa.algo.trial/is-boxed (first to-group) %) working-non-group)]\\r\\n                   (if (not (empty? filter-group))\\r\\n                       (recur (apply conj  (rest to-group) filter-group )\\r\\n                              (apply conj grouping filter-group)\\r\\n                              (filter  \#(not (tgaa.algo.trial/is-boxed (first to-group) %)) working-non-group))\\r\\n                       (recur (rest to-group)\\r\\n                              grouping\\r\\n                              working-non-group))))))" "(def t (group (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 3) (tgaa.util.shared/canidates))))" "(count (\:grouping t))" "(count (\:group\\n         t))" "(count (\:non-group\\n         t))" "(def t \\r\\n  (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 2) (tgaa.util.shared/canidates))]\\r\\n    (loop [non-group est-can groups [] group-id 0]\\n      (if (empty? non-group)\\n        group\\n        (let [[group-res non-group-res  ] (make-group non-group)]\\n        (recur non-group-res  \\n               (apply conj groups (map \#(assoc % \:group group-id) group-res))\\n               (inc group-id)))))))" "\\r\\n(defn make-group [non-group]\\r\\n  (loop [to-group [(first non-group)] grouping [(first non-group)] working-non-group (rest non-group)]\\r\\n    (if (empty? to-group)\\r\\n      [grouping  working-non-group]\\r\\n      (let [filter-group (filter  \#(tgaa.algo.trial/is-boxed (first to-group) %) working-non-group)]\\r\\n        (if (not (empty? filter-group))\\r\\n          (recur (apply conj  (rest to-group) filter-group )\\r\\n                 (apply conj grouping filter-group)\\r\\n                 (filter  \#(not (tgaa.algo.trial/is-boxed (first to-group) %)) working-non-group))\\r\\n          (recur (rest to-group)\\r\\n                 grouping\\r\\n                 working-non-group))))))" "(def t \\r\\n  (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 2) (tgaa.util.shared/canidates))]\\r\\n    (loop [non-group est-can groups [] group-id 0]\\n      (if (empty? non-group)\\n        group\\n        (let [[group-res non-group-res  ] (make-group non-group)]\\n        (recur non-group-res  \\n               (apply conj groups (map \#(assoc % \:group group-id) group-res))\\n               (inc group-id)))))))" "t" "(def t \\r\\n  (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 2) (tgaa.util.shared/canidates))]\\r\\n    (loop [non-group est-can groups [] group-id 0]\\n      (if (empty? non-group)\\n        groups\\n        (let [[group-res non-group-res  ] (make-group non-group)]\\n        (recur non-group-res  \\n               (apply conj groups (map \#(assoc % \:group group-id) group-res))\\n               (inc group-id)))))))" "t" "\\r\\n(defn make-groups [cann-path]\\r\\n  (loop [non-group cann-path groups [] group-id 0]\\n    (if (empty? non-group)\\n      groups\\n      (let [[group-res non-group-res  ] (make-group non-group)]\\n        (recur non-group-res  \\n               (apply conj groups (map \#(assoc % \:group group-id) group-res))\\n               (inc group-id))))))" "(make-groups)" "(make-groups (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 2) (tgaa.util.shared/canidates)))" "\\r\\n(key 1)" "\\r\\n(key \\"1\\")" "\\r\\n(keyword 1)" "\\r\\n(keyword \\"1\\")" "\\r\\n(keyword (str 1))" "(defn make-groups [cann-path]\\r\\n  (loop [non-group cann-path groups [] meta-data {} group-id 0]\\r\\n    (if (empty? non-group)\\r\\n      [groups meta-data]\\r\\n      (let [[group-res non-group-res  ] (make-group non-group)]\\r\\n        (recur non-group-res  \\r\\n               (apply conj groups (map \#(assoc % \:group group-id) group-res))\\r\\n               (assoc meta-data (keyword (str group-id)) (count group-res))\\r\\n               (inc group-id))))))" "(make-groups (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 2) (tgaa.util.shared/canidates)))" "(defn make-groups [cann-path]\\r\\n  (loop [non-group cann-path groups [] meta-data {} group-id 0]\\r\\n    (if (empty? non-group)\\r\\n      [\:groups groups \:group-data meta-data]\\r\\n      (let [[group-res non-group-res  ] (make-group non-group)]\\r\\n        (recur non-group-res  \\r\\n               (apply conj groups (map \#(assoc % \:group group-id) group-res))\\r\\n               (assoc meta-data (keyword (str group-id)) (count group-res))\\r\\n               (inc group-id))))))" "(make-groups (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 2) (tgaa.util.shared/canidates)))" "(make-groups (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (tgaa.util.shared/canidates)))"]
eclipse.preferences.version=1
