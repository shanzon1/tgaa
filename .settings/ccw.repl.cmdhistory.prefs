cmdhistory=["(let [ i (tgaa.util.image/get-image)]\\n  (proc-ant \\n    {\:start [100 111] \:dir [1 1]} i))" "(defn compare-two-points [point-ref point-comp image compare-type]\\r\\n  \\"returns point-comp if point-ref is null; point-compare returned on if true given compare-type \:less \:great\\"\\r\\n  (if (nil? point-ref)\\r\\n    point-comp\\r\\n    (let [ref-val (. image getRGB (first point-ref)(second point-ref))\\r\\n          comp-val (. image getRGB (first point-comp)(second point-comp))\\r\\n          - (println ref-val \\" \\" comp-val)] \\r\\n      (if (\:less compare-type)\\r\\n        (if (> ref-val comp-val)\\r\\n          point-comp\\r\\n          point-ref)\\r\\n         (if (< ref-val comp-val)\\r\\n          point-comp\\r\\n          point-ref)))))" "(let [ i (tgaa.util.image/get-image)]\\n  (proc-ant \\n    {\:start [100 111] \:dir [1 1]} i))" "(defn compare-two-points [point-ref point-comp image compare-type]\\r\\n  \\"returns point-comp if point-ref is null; point-compare returned on if true given compare-type \:less \:great\\"\\r\\n  (if (nil? point-ref)\\r\\n    point-comp\\r\\n    (let [ref-val (. image getRGB (first point-ref)(second point-ref))\\r\\n          comp-val (. image getRGB (first point-comp)(second point-comp))\\r\\n          - (println ref-val \\" \\" comp-val)] \\r\\n      (if (\= \:less compare-type)\\r\\n        (if (> ref-val comp-val)\\r\\n          point-comp\\r\\n          point-ref)\\r\\n         (if (< ref-val comp-val)\\r\\n          point-comp\\r\\n          point-ref))))" "(defn compare-two-points [point-ref point-comp image compare-type]\\r\\n  \\"returns point-comp if point-ref is null; point-compare returned on if true given compare-type \:less \:great\\"\\r\\n  (if (nil? point-ref)\\r\\n    point-comp\\r\\n    (let [ref-val (. image getRGB (first point-ref)(second point-ref))\\r\\n          comp-val (. image getRGB (first point-comp)(second point-comp))\\r\\n          - (println ref-val \\" \\" comp-val)] \\r\\n      (if (\= \:less compare-type)\\r\\n        (if (> ref-val comp-val)\\r\\n          point-comp\\r\\n          point-ref)\\r\\n         (if (< ref-val comp-val)\\r\\n          point-comp\\r\\n          point-ref)))))" "(let [ i (tgaa.util.image/get-image)]\\n  (proc-ant \\n    {\:start [100 111] \:dir [1 1]} i))" "(let [ i (tgaa.util.image/get-image)]\\n  (proc-ant \\n    {\:start [100 111] \:dir [-1 -1]} i))" "(let [ i (tgaa.util.image/get-image)]\\n  (proc-ant \\n    {\:start [130 111] \:dir [-1 -1]} i))" "(let [ i (tgaa.util.image/get-image)]\\n  (proc-ant \\n    {\:start [130 111] \:dir [1 -1]} i))" "(let [ i (tgaa.util.image/get-image)]\\n  (proc-ant \\n    {\:start [130 111] \:dir [-1 -1]} i))" "(let [ i (tgaa.util.image/get-image)]\\n  (proc-ant \\n    {\:start [130 111] \:dir [0 -1]} i))" "(let [ i (tgaa.util.image/get-image)]\\n  (proc-ant \\n    {\:start [136 111] \:dir [0 -1]} i))" "(let [ i (tgaa.util.image/get-image)]\\n  (proc-ant \\n    {\:start [136 111] \:dir [1 -1]} i))" "(defn compare-two-points [point-ref point-comp image compare-type]\\r\\n  \\"returns point-comp if point-ref is null; point-compare returned on if true given compare-type \:less \:great\\"\\r\\n  (if (nil? point-ref)\\r\\n    point-comp\\r\\n    (let [ref-val (. image getRGB (first point-ref)(second point-ref))\\r\\n          comp-val (. image getRGB (first point-comp)(second point-comp))\\r\\n          - (println ref-val \\" \\" comp-val compare-type)] \\r\\n      (if (\= \:less compare-type)\\r\\n        (if (> ref-val comp-val)\\r\\n          point-comp\\r\\n          point-ref)\\r\\n         (if (< ref-val comp-val)\\r\\n          point-comp\\r\\n          point-ref)))))" "(let [ i (tgaa.util.image/get-image)]\\n  (proc-ant \\n    {\:start [136 111] \:dir [1 -1]} i))" "(defn proc-ant [ant-path image]\\r\\n  \\"Takes ants and image and generates logical paths\\"\\r\\n  (loop [i 0 thresh? false end-pont nil local-min nil local-max nil]\\r\\n    (if (or (>\= i (\:max-path-length config)) thresh?)\\r\\n      (assoc ant-path \:thresh thresh? \:end end-pont \:local-min local-min \:local-max local-max)\\r\\n      (let [[x y] (path-loc-at-time ant-path i)]\\r\\n        (recur (inc i) \\r\\n               (if (< (\:thresh @session) (. image getRGB x y))\\r\\n                 true false)\\r\\n               [x y]\\r\\n               (compare-two-points local-min [x y] image \:less)\\r\\n               (compare-two-points local-max [x y] image \:great))))))" "(let [ i (tgaa.util.image/get-image)]\\n  (proc-ant \\n    {\:start [136 111] \:dir [1 -1]} i))" "(defn compare-two-points [point-ref point-comp image compare-type]\\r\\n  \\"returns point-comp if point-ref is null; point-compare returned on if true given compare-type \:less \:great\\"\\r\\n  (if (nil? point-ref)\\r\\n    point-comp\\r\\n    (let [ref-val (. image getRGB (first point-ref)(second point-ref))\\r\\n          comp-val (. image getRGB (first point-comp)(second point-comp))\\r\\n          - (println ref-val \\" \\" comp-val compare-type (> ref-val comp-val) (< ref-val comp-val) )] \\r\\n      (if (\= \:less compare-type)\\r\\n        (if (> ref-val comp-val)\\r\\n          point-comp\\r\\n          point-ref)\\r\\n         (if (< ref-val comp-val)\\r\\n          point-comp\\r\\n          point-ref)))))" "(let [ i (tgaa.util.image/get-image)]\\n  (proc-ant \\n    {\:start [136 111] \:dir [1 -1]} i))" "(let [ i (tgaa.util.image/get-image)]\\n  (proc-ant \\n    {\:start [136 121] \:dir [1 -1]} i))" "(ns tgaa.util.ant-path\\r\\n  (\:require [tgaa.util.shared \:refer \:all])\\r\\n  (\:import [java.awt.image BufferedImage]))\\r\\n\\r\\n(def dir-opt [[0 1][0 -1][1 0][-1 0][1 1][-1 -1][1 -1][-1 1]])\\r\\n\\r\\n(defn path-loc-at-time [ant-path time]\\r\\n  [(+ (first (\:start ant-path)) (* (first (\:dir ant-path)) time))\\r\\n  (+ (second (\:start ant-path)) (* (second (\:dir ant-path)) time))])\\r\\n  \\r\\n(defn full-path-last-point [start dir]\\r\\n  \\"Get last points of gen axis of a path for performance\\"\\r\\n    (cond \\r\\n      (\= 0 dir)\\r\\n      start\\r\\n      (\= 1 dir)\\r\\n      (+ start (- (\:max-path-length config) 1))\\r\\n      \:else\\r\\n      (+ (- start  (\:max-path-length config) ) 1)))\\r\\n  \\r\\n(defn rand-ant-dir \\r\\n  \\"Creates safe random direction at 45 deg increments with starting point x y\\"\\r\\n  [point ^BufferedImage image] \\r\\n   (\:dir-opt (first \\r\\n               (filter \#(let [lx (first (\:last %))\\r\\n                              ly (second (\:last %))]\\r\\n                          (and (> lx 0) (> ly 0)) (< lx (. image getWidth)) (< ly (. image getHeight)))\\r\\n                       (map (fn [d] {\:last [(full-path-last-point (first point)(first d)) \\r\\n                                            (full-path-last-point (second point) (second d))] \\r\\n                                          \:dir-opt d})  (shuffle dir-opt))))))\\r\\n\\r\\n(defn random-point \\r\\n  \\"Get random set of coordinates\\"\\r\\n  [num-loc ^BufferedImage image]\\r\\n  (partition 2\\r\\n             (interleave \\r\\n               (repeatedly \\r\\n                      num-loc\\r\\n                      \#(rand-int \\r\\n                         (. image getWidth)))\\r\\n        (repeatedly \\r\\n               num-loc \\r\\n               \#(rand-int \\r\\n                  (. image getHeight))))))\\r\\n\\r\\n(defn ant-path [start-point ^BufferedImage image]\\r\\n  \\"Creates a logical ant path\\"\\r\\n  (let [dir-opt (rand-ant-dir start-point image)]\\r\\n    {\:start start-point \:end nil \:dir dir-opt \:thresh false}))\\r\\n\\r\\n\\r\\n(defn num-of-phero-starts []\\r\\n  \\"Creates number of pheromone starts based on config and session values\\"\\r\\n  (int \\r\\n    (* \\r\\n      (\:trial-num @session) \\r\\n      (\:plac-heur config) \\r\\n      (\:num-ants config))))\\r\\n \\r\\n(defn num-of-random-starts []\\r\\n  \\"Creates number of random starts based on config and session values\\"\\r\\n     (int\\r\\n       (- (\:num-ants config)\\r\\n       (* \\r\\n         (\:trial-num @session) \\r\\n         (\:plac-heur config)\\r\\n         (\:num-ants config)))))\\r\\n\\r\\n(defn phero-points [num]\\r\\n               (do (print \\"not implemented\\")\\r\\n                 (repeat num [100 100])))\\r\\n\\r\\n(defn get-trail-paths [^BufferedImage image]\\r\\n  \\"Gets ant paths for a trail based on session and config\\"\\r\\n  (map \#(ant-path % image)\\r\\n       (concat \\r\\n         (random-point \\r\\n           (num-of-random-starts) image)\\r\\n         (phero-points \\r\\n           (num-of-phero-starts)))))\\r\\n\\r\\n(defn compare-two-points [point-ref point-comp image compare-type]\\r\\n  \\"returns point-comp if point-ref is null; point-compare returned on if true given compare-type \:less \:great\\"\\r\\n  (if (nil? point-ref)\\r\\n    point-comp\\r\\n    (let [ref-val (. image getRGB (first point-ref)(second point-ref))\\r\\n          comp-val (. image getRGB (first point-comp)(second point-comp))] \\r\\n      (if (\= \:less compare-type)\\r\\n        (if (> ref-val comp-val)\\r\\n          point-comp\\r\\n          point-ref)\\r\\n         (if (< ref-val comp-val)\\r\\n          point-comp\\r\\n          point-ref)))))     \\r\\n     \\r\\n\\r\\n(defn proc-ant [ant-path image]\\r\\n  \\"Takes ants and image and generates logical paths\\"\\r\\n  (loop [i 0 thresh? false end-pont nil local-min nil local-max nil]\\r\\n    (if (or (>\= i (\:max-path-length config)) thresh?)\\r\\n      (assoc ant-path \:thresh thresh? \:end end-pont \:local-min local-min \:local-max local-max)\\r\\n      (let [[x y] (path-loc-at-time ant-path i)]\\r\\n        (recur (inc i) \\r\\n               (if (< (\:thresh @session) (. image getRGB x y))\\r\\n                 true false)\\r\\n               [x y]\\r\\n               (compare-two-points local-min [x y] image \:less)\\r\\n               (compare-two-points local-max [x y] image \:great))))))\\r\\n\\r\\n\\r\\n(defn proc-all-ants [ants image]\\r\\n  (loop [ants-to-proc ants ants-process []]\\r\\n    (if (empty? ants-to-proc)\\r\\n    ants-process\\r\\n    (recur (rest ants-to-proc) \\r\\n           (conj ants-process \\r\\n                 (proc-ant (first ants-to-proc) image))))))" "(let [ i (tgaa.util.image/get-image)]\\n  (proc-ant \\n    {\:start [136 121] \:dir [1 -1]} i))" "(def res-ant (let [ i (tgaa.util.image/get-image)]\\n               (proc-ant \\n                 {\:start [136 121] \:dir [1 -1]} i)))" "res-ant" "(map \#(let [[x y] (\:local-max %)] (. image getRGB x y)) res-ant)" "(map \#(let [[x y] (\:local-max %)] (. (tgaa.util.image/get-image) getRGB x y)) res-ant)" "(map \#(let [[x y] (\:local-max %)] (println x y)) res-ant)" "res-ant" "(map \#(let [[x y] (\:local-max %)] (println x y)) res-ant)" "(map (fn [[x y] (\:local-max %)] (println x y)) res-ant)" "(map \#(let [{\:local-max local-max} %] local-max) res-ant)" "(map \#(let [{ local-max \:local-max } %] local-max) res-ant)" "(map (fn [x] (let [{ local-max \:local-max } x] local-max)) res-ant)" "res-ant" "(def res-ant (let [ i (tgaa.util.image/get-image)]\\n               (proc-all-ants (proc-ant \\n                 {\:start [136 121] \:dir [1 -1]} i))) i)" "(def res-ant (let [ i (tgaa.util.image/get-image)]\\n               (proc-all-ants (proc-ant \\n                 {\:start [136 121] \:dir [1 -1]} i) i)))" "(def res-ant (let [ i (tgaa.util.image/get-image)]\\n                (proc-all-ants (get-trail-paths i) i)))" "(get-trail-paths i)" "(def  i (tgaa.util.image/get-image))" "(get-trail-paths i)" "(proc-all-ants (get-trail-paths i) i)" "(let [ i (tgaa.util.image/get-image)]\\n  (proc-ant \\n    {\:start [136 111] \:dir [1 -1]} i))" "(get-trail-paths i)" "(def ant-init(get-trail-paths i))" "(count ant-init)" "(map \#(proc-ant % i) ant-init)" "(defn proc-all-ants [ant-init image]\\r\\n  (map \#(proc-ant % image) ant-init))" "(map (fn [x] (let [{ local-max \:local-max } x] local-max)) ant-init)" "(map (fn [x] (let [{ local-max \:local-max } x] local-max)) (proc-all-ants ant-init i))" "(map (fn [ant-path] (let [{ local-max \:local-max } ant-path\\n                      [x y] local-max] x y )) (proc-all-ants ant-init i))" "(map (fn [ant-path] (let [{ local-max \:local-max } ant-path\\n                      [x y] local-max] (. i getRGB x y ))) (proc-all-ants ant-init i))" "(defn ant-path-point-val[ant-paths att-key image]\\r\\n  \\"gets attribute values of an image\\"\\r\\n  (map (fn [ant-path] \\r\\n         (let [{ local-max att-key} ant-path\\r\\n               [x y] local-max] (. image getRGB x y ))) ant-paths))" "(defn trial-min-local[ant-paths  image]\\n  (trial-path-point-vals ant-paths \:local-min image))" "(defn trial-path-point-vals[ant-paths att-key image]\\r\\n  \\"gets attribute values of an image\\"\\r\\n  (map (fn [ant-path] \\r\\n         (let [{ local-max att-key} ant-path\\r\\n               [x y] local-max] (. image getRGB x y ))) ant-paths))" "(defn trial-min-local[ant-paths  image]\\n  (trial-path-point-vals ant-paths \:local-min image))" "(defn trial-min-local[ant-paths  image]\\n  (trial-path-point-vals ant-paths \:local-max image))" "(proc-all-ants (get-trail-paths i))" "(proc-all-ants (get-trail-paths i) i)" "(trial-min-local (proc-all-ants (get-trail-paths i) i) i)" "(min (trial-min-local (proc-all-ants (get-trail-paths i) i) i))" "(applly min (trial-min-local (proc-all-ants (get-trail-paths i) i) i))" "(min (trial-min-local (proc-all-ants (get-trail-paths i) i) i))" "(apply min (trial-min-local (proc-all-ants (get-trail-paths i) i) i))" "(trial-min-local (proc-all-ants (get-trail-paths i) i) i)" "(Math/min (trial-min-local (proc-all-ants (get-trail-paths i) i) i)" "(Math/min (trial-min-local (proc-all-ants (get-trail-paths i) i) i))" "(def m (trial-min-local (proc-all-ants (get-trail-paths i) i) i))" "m" "(min m)" "(apply min m)" "(apply min (trial-min-local (proc-all-ants (get-trail-paths i) i) i))" "(comp trial-min-local  proc-all-ants get-trail-paths)" "((comp trial-min-local  proc-all-ants get-trail-paths) i)" "((comp get-trail-paths proc-all-ants trial-min-local   ) i)" "(def m (trial-min-local (proc-all-ants (get-trail-paths i) i) i))" "(apply min (trial-min-local (proc-all-ants (get-trail-paths i) i) i))" "(apply min (trial-min-local (proc-all-ants (init-trail-paths i) i) i))" "(def i (tgaa.util.image/get-image))\\n(apply min (trial-min-local (proc-all-ants (init-trail-paths i) i) i))" "(process-image)" "shared/session" "(ap/proc-all-ants (ap/init-trail-paths image) image)" "(def i image ^BufferedImage (image/image-RGB-gray (image/get-image)))" "(def  image ^BufferedImage (image/image-RGB-gray (image/get-image)))" "(ap/proc-all-ants (ap/init-trail-paths image) image) image)))" "(ap/proc-all-ants (ap/init-trail-paths image) image)" "(def p(ap/proc-all-ants (ap/init-trail-paths image) image))" "(trial-min-local p image)" "(tgaa.util.ant-path/trial-min-local trial-min-local p image)" "(tgaa.util.ant-path/trial-min-local  p image)" "(tgaa.util.ant-path/trial-max-local  p image)" "(tgaa.util.ant-path/trial-min-local  p image)" "(tgaa.util.ant-path/trial-max-local  p image)" "(tgaa.util.ant-path/trail-max-of-min  p image)" "(tgaa.util.ant-path/trail-min-of-max  p image)" "(tgaa.util.ant-path/escaped-ants p)" "(defn trap-ants [ant-paths image]\\n  (trail-max-of-min (escaped-ants ant-paths image)))" "(defn trap-ants [ant-paths image]\\n  (tgaa.util.ant-path/trail-max-of-min (tgaa.util.ant-path/escaped-ants ant-paths image)))" "(trap-ants p image)" "(defn trap-ants [ant-paths image]\\n  (tgaa.util.ant-path/trail-max-of-min (tgaa.util.ant-path/escaped-ants ant-paths) image))" "(trap-ants p image)" "(process-image)" "(defn add-canidates\\r\\n  \\"\\"\\r\\n  [cand-paths-list]\\r\\n  (reset\! session  (assoc @session \:cand-paths (conj (\:cand-paths @session) cand-paths-list))))" "(def session (atom {\:trial-num 0\\r\\n                    \:image-location \\"C\:\\\\\\\\Users\\\\\\\\erudi\\\\\\\\OneDrive\\\\\\\\Activity Organizer\\\\\\\\Projects\\\\\\\\Active\\\\\\\\TAA Research\\\\\\\\Project Resources\\\\\\\\images\\\\\\\\unprocessed\\\\\\\\3\\\\\\\\1\\\\\\\\3_1_1.jpg\\"\\r\\n                    \:cand-paths []\\r\\n                    \:thresh 0}))" "(defn add-canidates\\r\\n  \\"\\"\\r\\n  [cand-paths-list]\\r\\n  (reset\! session  (assoc @session \:cand-paths (conj (\:cand-paths @session) cand-paths-list))))" "(add-canidates [{\:one 1} {\:two 2}])" "(defn add-canidates\\r\\n  \\"\\"\\r\\n  [cand-paths-list]\\r\\n  (reset\! session  (assoc @session \:cand-paths (apply conj (\:cand-paths @session) cand-paths-list))))" "(add-canidates [{\:one 1} {\:two 2}])" "(def session (atom {\:trial-num 0\\r\\n                    \:image-location \\"C\:\\\\\\\\Users\\\\\\\\erudi\\\\\\\\OneDrive\\\\\\\\Activity Organizer\\\\\\\\Projects\\\\\\\\Active\\\\\\\\TAA Research\\\\\\\\Project Resources\\\\\\\\images\\\\\\\\unprocessed\\\\\\\\3\\\\\\\\1\\\\\\\\3_1_1.jpg\\"\\r\\n                    \:cand-paths []\\r\\n                    \:thresh 0}))" "(add-canidates [{\:one 1} {\:two 2}])" "(defn get-image [& abs-path]\\r\\n  \\"Takes a map with \:imageLocation and returns assocated BufferedImage\\"\\r\\n  let [ path (if (empty? abs-path) \\r\\n               (shared/image-loc) \\r\\n               (first abs-path))]\\r\\n  (try\\r\\n    (. ImageIO read (File. path))\\r\\n    (catch Exception e \\r\\n      (do (println \\"Image not found. Check location is correct\\")\\r\\n        (throw (Exception.  e))))))" "(get-image)" "(shared/save-image-ref (image/image-RGB-gray (image/get-image)))" "(shared/update-thresh (bootstrap))" "(perform-trial)" "(def trial-paths (ap/proc-ant (ap/init-trail-paths)))" "(ap/init-trail-paths)" "(ap/proc-ant (ap/init-trail-paths))" "(\:max-path-length shared/config)" "(path-loc-at-time {\:dir [1 1] \:start-pos [100 100]} i)" "(ap/path-loc-at-time {\:dir [1 1] \:start-pos [100 100]} 5)" "( ant-path  1 1)" "(ap/ant-path  1 1)" "(ap/ant-path  [1 1])" "(ap/path-loc-at-time {\:start [1 1],\\r\\n \:end nil,\\r\\n \:dir [1 -1],\\r\\n \:thresh false,\\r\\n \:trial-num 0} 5)" "(ap/proc-ant (ap/init-trail-paths))" "(ap/init-trail-paths)" "(ap/proc-all-ants (ap/init-trail-paths))" "(def trial-paths (ap/proc-all-ants (ap/init-trail-paths))0" "(def trial-paths (ap/proc-all-ants (ap/init-trail-paths)))" "(shared/add-canidates (ap/trapped-ants trial-paths))" "(ap/trapped-ants trial-paths)" "(shared/add-canidates (ap/trapped-ants trial-paths))" "(shared/update-thresh  (ap/trap-escaped-thresh trial-paths))" " (ap/trap-escaped-thresh trial-paths)" "trial-paths" " (ap/trap-escaped-thresh trial-paths)" "trial-paths" " (ap/escaped-ants trial-paths)" " (ap/trail-max-of-min (ap/escaped-ants trial-paths))" "(ap/escaped-ants trial-paths)" " (def e (escaped-ants ant-paths))" " (def e (ap/escaped-ants ant-paths))" " (def e (ap/escaped-ants trial-paths))" "e" "(ap/trail-max-of-min e)" "(apply max (trial-min-local e))" "(apply max (ap/trial-min-local e))" "(ap/trial-min-local e)" "e" "(ap/trial-path-point-vals e \:local-min)" "(ap/trial-path-point-vals e \:local-max)" "(empty? e)" "(if-not (empty? e) \\"true\\")" "(map (fn [ant-path] \\r\\n           (let [{ local-max att-key} ant-path\\r\\n                 [x y] local-max] (. (shared/image-ref) getRGB x y ))) e)" "(map (fn [ant-path] \\r\\n           (let [{ local-max \:local-min} ant-path\\r\\n                 [x y] local-max] (. (shared/image-ref) getRGB x y ))) e)" "(shared/image-ref)" "(shared/save-image-ref (image/image-RGB-gray (image/get-image)))" "(shared/image-ref)" "(ap/escaped-ants trial-paths)" "(perform-trial)" "@shared/trail-state" "(keys  @shared/trail-state)" "(\:image  @shared/trail-state)" "(\:thresh  @shared/trail-state)" "(\:image-location  @shared/trail-state)" "(\:thresh  @shared/trail-state)" "(shared/save-image-ref (image/image-RGB-gray (image/get-image)))" "(shared/update-thresh (bootstrap))" " (bootstrap)" "(ap/init-trail-paths)" "(ap/proc-all-ants (ap/init-trail-paths))" "(map \#(shared/proc-ant %) (ap/init-trail-paths))" "(map \#(proc-ant %) (ap/init-trail-paths))" "ns" "(ns)" "(map \#(shared/proc-ant %) (ap/init-trail-paths))" "(map \#(ap/proc-ant %) (ap/init-trail-paths))" "(first (ap/init-trail-paths))" "(ap/proc-ant (first (ap/init-trail-paths)))" "(shared/thresh)" "   \\r\\n\\r\\n(defn proc-ant [ant-path]\\r\\n  \\"Takes ants and image and generates logical paths\\"\\r\\n  (loop [i 0 thresh? false end-pont nil local-min nil local-max nil]\\r\\n    (if (or (>\= i  (shared/num-ants)) thresh?)\\r\\n      ; needs to be extracted to shared only\\r\\n      (assoc ant-path \:thresh thresh? \:end end-pont \:local-min local-min \:local-max local-max)\\r\\n      (let [[x y] (path-loc-at-time ant-path i)]\\r\\n        (recur (inc i) \\r\\n               (if (and (nil? (shared/thresh)) (> (shared/thresh) (. (shared/image-ref) getRGB x y)))\\r\\n                 true false)\\r\\n               [x y]\\r\\n               (compare-two-points local-min [x y]  \:less)\\r\\n               (compare-two-points local-max [x y]  \:great))))))" "(ap/proc-ant (first (ap/init-trail-paths)))" "(ns-name)" "(ap/proc-ant (first (ap/init-trail-paths)))" "ap/proc-ant" "(print ap/proc-ant)" "(ap/proc-ant (first (ap/init-trail-paths)))" "(shared/update-thresh 10)" "(ap/proc-ant (first (ap/init-trail-paths)))" "(first (ap/init-trail-paths))" "(ap/init-trail-paths)" "(init-trail-paths)" "(num-of-random-starts)" "(random-point \\r\\n           (num-of-random-starts))" "(shared/save-image-ref (image/image-RGB-gray (image/get-image)))" "(save-image-ref (image/image-RGB-gray (image/get-image)))" "(shared/save-image-ref (image/image-RGB-gray (image/get-image)))" "(image/get-image)" "(shared/save-image-ref (image/image-RGB-gray (image/get-image)))" "(shared/update-thresh (bootstrap))" "@shared/config" "shared/config" "(not (nil? (\:num-ants @shared/trail-state)))" "(\:num-ants @shared/trail-state)" " @shared/trail-state" "(\:num-ants @shared/trail-state)" "(shared/get-config)" "(\:num-ants @shared/trail-state)" "(shared/config)" "(def config (shared/get-config))" "config" "@shared/config" "shared/config" "(shared/save-image-ref (image/image-RGB-gray (image/get-image)))" "(shared/update-thresh (bootstrap))" "perform-trial" "(perform-trial)" "@shared/trial-num" "@shared/trail-state" "(ap/proc-all-ants (ap/init-trail-paths))" "(def e (ap/proc-all-ants (ap/init-trail-paths)))" "(ap/trapped-ants e)" "(ap/trap-escaped-thresh e)" "(shared/update-thresh  (ap/trap-escaped-thresh trial-paths))" "(shared/update-thresh  (ap/trap-escaped-thresh e))" "(def e (ap/proc-all-ants (ap/init-trail-paths)))" "(ap/trap-escaped-thresh e)" "(ap/trapped-ants e)" "(shared/update-thresh  (ap/trap-escaped-thresh trial-paths))" "(shared/update-thresh  (ap/trap-escaped-thresh e))" "(def e (ap/proc-all-ants (ap/init-trail-paths)))" "(ap/trapped-ants e)" "(shared/thresh)" "(repeatedly (shared/get-num-trails) 10)" "(repeatedly (shared/get-num-trails) \#(print 10))" "(shared/save-image-ref (image/image-RGB-gray (image/get-image)))" "(shared/update-thresh (bootstrap))" "(shared/save-image-ref (image/image-RGB-gray (image/get-image)))" "(shared/update-thresh (bootstrap))" "(ap/init-trail-paths)" "(vec)" "(vector)" "(canidates)" "(shared/canidates)" "(defn phero-points [num]\\r\\n  (if-not (empty? (shared/canidates))\\r\\n    (let [num (if (> num (count (shared/canidates))\\r\\n                     (count (shared/canidates))\\r\\n                     num))]\\r\\n      (path-loc-at-time (take num (shuffle (shared/canidates))) (rand-int shared/max-path-length)))))" "(defn phero-points [num]\\r\\n  (when-not (empty? (shared/canidates))\\r\\n    (let [num (if (> num (count (shared/canidates))\\r\\n                     (count (shared/canidates))\\r\\n                     num))]\\r\\n      (path-loc-at-time (take num (shuffle (shared/canidates))) (rand-int shared/max-path-length)))))" "(defn phero-points [num]\\r\\n  (if-not (empty? (shared/canidates))\\r\\n    (let [num (if (> num (count (shared/canidates)))\\r\\n                     (count (shared/canidates))\\r\\n                     num)]\\r\\n      (path-loc-at-time (take num (shuffle (shared/canidates))) (rand-int shared/max-path-length))))\\n  (vector))" "(shared/save-image-ref (image/image-RGB-gray (image/get-image)))" "(shared/update-thresh (bootstrap))" "(repeatedly (shared/get-num-trails) \#(perform-trial))" "(defn pix-value[x y image]\\r\\n  {\:pre (and (< x (. image getWidth)) (< 0 x) (< y (. image getHeight)) (< 0 y))}\\r\\n  (. image getRGB x y))" "(defn pix-value[x y image]\\r\\n  {\:pre [(and (< x (. image getWidth)) (< 0 x) (< y (. image getHeight)) (< 0 y))]}\\r\\n  (. image getRGB x y))" "(shared/save-image-ref (image/image-RGB-gray (image/get-image)))" "shared/trail-state" "(shared/add-canidates (ap/trapped-ants trial-paths))" "(def trial-paths (ap/proc-all-ants (ap/init-trail-paths)))" "(shared/add-canidates (ap/trapped-ants trial-paths))" "shared/trail-state" "(shared/update-thresh (bootstrap))" "(defn print-failure [isSuccess?, msg]\\r\\n  (do (when-not isSuccess\\r\\n        (print msg))\\r\\n    isSuccess?))" "(defn print-failure [isSuccess?, msg]\\r\\n  (do (when-not isSuccess?\\r\\n        (print msg))\\r\\n    isSuccess?))" "(print-failure false \\"test\\")" "(print-failure true \\"test\\")" "(defn print-failure [isSuccess? & msg]\\r\\n  (do (when-not isSuccess?\\r\\n        (print msg)\\r\\n    isSuccess?)))" "(shared/save-image-ref (image/image-RGB-gray (image/get-image)))" "(shared/update-thresh (bootstrap))" "(defn print-failure [isSuccess? & msg]\\r\\n  (do (when-not isSuccess?\\r\\n        (print msg)\\r\\n    isSuccess?)))" "(print-failure false \\"x\\" 1)" "(shared/update-thresh (bootstrap))" "(bootstrap)<type clojure code here>" "(bootstrap)" "(shared/update-thresh (bootstrap))" "(is false)" "(shared/update-thresh (bootstrap))" "@shared/trail-state" "(\:image @shared/trail-state)" "(. (\:image @shared/trail-state)  getRGB 1 1)" "(. (\:image @shared/trail-state)  getRGB 0 0)" "(bootstrap)" "(. (\:image @shared/trail-state)  getRGB  515 10)" "(bootstrap)" "(def tp (random-point 1000))" "(def tp (ap/random-point 1000))" "(fliter \#(< (first %) 0) tp)" "(filter \#(< (first %) 0) tp)" "(filter \#(< (second %) 0) tp)" "(filter \#(> (first %) 514) tp)" "(filter \#(> (first %) 500) tp)" "(def antp (ant-path sp))" "(def antp (ant-path tp))" "(def antp (ap/ant-path tp))" "(def antp  (map \#(ap/ant-path %) tp))" "(first antp)" "@shared/tra" "@shared/trail-state" "shared/config" "(shared/proc-ant antp)" "(def a (ap/proc-ant antp))" "(ap/proc-ant antp)" "antp" "(def a (ap/proc-ant antp))" "(shared/update-thresh (bootstrap))" "(perform-trial)" "(repeatedly (shared/get-num-trails) \#(perform-trial))" "(shared/get-num-trails)" "(repeatedly 1  \#(perform-trial))" "(perform-trial)" "(def ap trial-paths (ap/proc-all-ants (ap/init-trail-paths)))" "(def trial-paths (ap/proc-all-ants (ap/init-trail-paths)))" "(ap/proc-all-ants (ap/init-trail-paths))" "(def d (map \#(proc-ant %) (init-trail-paths))" "(def d (map \#(proc-ant %) (init-trail-paths)))" "(def d (map \#(ap/proc-ant %) (ap/init-trail-paths)))" "(ap/proc-all-ants (ap/init-trail-paths))" "(def r (ap/proc-all-ants (ap/init-trail-paths)))" "r" "(def r (ap/proc-all-ants (ap/init-trail-paths)))" "r" "(def r (ap/proc-all-ants (ap/init-trail-paths)))" "r" "(def r (ap/proc-all-ants (ap/init-trail-paths)))" "r" "(def r (ap/proc-all-ants (ap/init-trail-paths)))" "r" "(def r (ap/proc-all-ants (ap/init-trail-paths)))" "r" "(def r (ap/proc-all-ants (ap/init-trail-paths)))" "r" "(range  10)" "(def r (ap/proc-all-ants (ap/init-trail-paths)))" "r" "(rand-ant-dir [48 0])" "(ap/rand-ant-dir [48 0])" " (full-path-last-point 48 0)" " (ap/full-path-last-point 48 0)" " (ap/full-path-last-point 0 -1)" "(ap/rand-ant-dir [48 0])" "(repeatedly (shared/get-num-trails) \#(perform-trial))" "shared/config" "shared/trail-state" "(def trial-paths (ap/proc-all-ants (ap/init-trail-paths)))" "(ap/trapped-ants trial-paths)" "(ap/trap-escaped-thresh trial-paths)" "trial-paths" "  (apply min (ap/trial-min-local \\r\\n               (ap/proc-all-ants (ap/init-trail-paths)))))" "  (apply min (ap/trial-min-local \\r\\n               (ap/proc-all-ants (ap/init-trail-paths))))" "(ap/proc-all-ants (ap/init-trail-paths))" "(ap/init-trail-paths)" " (shared/save-image-ref (image/image-RGB-gray (image/get-image)))" "(shared/update-thresh (bootstrap))" "(perform-trial" "(perform-trial)" "shared/trial-state" "(perform-trial)" "shared/trial-state" "(perform-trial)" "shared/trial-state" "(ap/perform-trial)" "(perform-trial)" "shared/trial-state" "(perform-trial)" "shared/trial-state" "perform-trial" "(perform-trial)" "shared/trial-state" "(perform-trial)" "shared/trial-state" "(perform-trial)" "shared/trial-state" "(perform-trial)" "shared/trial-state" "(perform-trial)" "shared/trial-state" "(perform-trial)" "shared/trial-state" "(perform-trial)" "shared/trial-state" "(perform-trial)" "shared/trial-state" "(+ 1 1)" "(shared/save-image-ref (image/image-RGB-gray (image/get-image)))" "(shared/update-thresh (bootstrap))" "(perform-trial)" "shared/trial-state" "(perform-trial)" "shared/trial-state" "(perform-trial)" "shared/trial-state" "(perform-trial)" "shared/trial-state" "(perform-trial)" "shared/trial-state" "(shared/thresh)" "(def v trial-paths (ap/proc-all-ants (ap/init-trail-paths)))" "(def trial-paths (ap/proc-all-ants (ap/init-trail-paths)))" "(shared/add-canidates (ap/trapped-ants trial-paths))" "(def trial-thresh (ap/trap-escaped-thresh trial-paths))" "trial-thresh" "(shared/thresh)" "(when-not (> trial-thresh (shared/thresh))\\r\\n             (shared/update-thresh trial-thresh))" "trial-thresh" "(perform-trial)" "(shared/thresh)" "trial-thresh" "(< -6184543 -11842741)" "(> -6184543 -11842741)" "(perform-trial)" "(shared/thresh)" "(perform-trial)" "(shared/thresh)" "(perform-trial)" "(shared/thresh)" "(repeatedly (shared/get-num-trails) \#(perform-trial))" "(shared/thresh)" "trial-thresh" "shared/trial-state" "(def trial-paths (ap/proc-all-ants (ap/init-trail-paths)))" "(ap/trapped-ants trial-paths)" "trial-paths" "(def trial-paths (ap/proc-all-ants (ap/init-trail-paths)))" "trial-paths" "(def trial-paths (ap/proc-all-ants (ap/init-trail-paths)))" "trial-paths" "(ap/trapped-ants trial-paths)" "(shared/add-canidates (ap/trapped-ants trial-paths))" "shared/trial-state" "perform-trial" "(repeatedly (shared/get-num-trails) \#(perform-trial))" "(perform-trial)" "(def trial-thresh (ap/trap-escaped-thresh trial-paths))" "(when (> trial-thresh (shared/thresh))\\r\\n             (shared/update-thresh trial-thresh))" "(perform-trial)" "( process-image )" "(def g <)" "(g  1 1)" "(def g \=)" "(g  1 1)" "(shared/save-image-ref (image/image-RGB-gray (image/get-image)))" "(shared/update-thresh (bootstrap))" "(perform-trial)" "(shared/thresh)" "(perform-trial)" "(def trial-paths (ap/proc-all-ants (ap/init-trail-paths)))" " (ap/init-trail-paths)" " (phero-points \\r\\n           (num-of-phero-starts))" "(num-of-phero-starts)" "(ant-path/num-of-phero-starts)" "(ap/num-of-phero-starts)" "(ap/num-of-random-starts)" "  (map \#(ap/ant-path %)\\r\\n       (concat \\r\\n         (ap/random-point \\r\\n           (ap/num-of-random-starts))\\r\\n         (ap/phero-points \\r\\n           (ap/num-of-phero-starts)))))" "  (map \#(ap/ant-path %)\\r\\n       (concat \\r\\n         (ap/random-point \\r\\n           (ap/num-of-random-starts))\\r\\n         (ap/phero-points \\r\\n           (ap/num-of-phero-starts))))" "(shared/trial-num)" "(ap/random-point \\r\\n              (ap/num-of-random-starts)" "(ap/random-point \\r\\n              (ap/num-of-random-starts))" "(ap/phero-points \\r\\n           (ap/num-of-phero-starts))" "(ap/phero-points  0)" "(shared/canidates)" "(count (shared/canidates))" "(ap/phero-points  0)" "(ap/phero-points  1)" "(ap/phero-points  0\\n                  )" "(ap/phero-points  1)" " (take 1 (shuffle (shared/canidates)))" "(ant/path-loc-at-time \\r\\n        (take 1 (shuffle (shared/canidates))) \\r\\n        (rand-int (shared/max-path-length)))" "(tgaa.algo.ant/path-loc-at-time \\r\\n        (take 1 (shuffle (shared/canidates))) \\r\\n        (rand-int (shared/max-path-length)))" "(rand-int (shared/max-path-length))" "(tgaa.algo.ant/path-loc-at-time \\r\\n        (take 1 (shuffle (shared/canidates))) \\r\\n        4)" "(take 1 (shuffle (shared/canidates)))" "(apply tgaa.algo.ant/path-loc-at-time \\r\\n        (take 1 (shuffle (shared/canidates))) \\r\\n        4)" "(map \#(ant/path-loc-at-time %1 %2)\\r\\n             (take 1 (shuffle (shared/canidates))) \\r\\n             (rand-int (shared/max-path-length)))" "(map \#(tgaa.algo.ant/path-loc-at-time %1 %2)\\r\\n             (take 1 (shuffle (shared/canidates))) \\r\\n             (rand-int (shared/max-path-length)))" "(map \#(tgaa.algo.ant/path-loc-at-time %1 %2)\\r\\n             (take 1 (shuffle (shared/canidates))) \\r\\n             (repeatedly 1 \#(rand-int (shared/max-path-length))))" "(map \#(tgaa.algo.ant/path-loc-at-time %1 %2)\\r\\n             (take 2 (shuffle (shared/canidates))) \\r\\n             (repeatedly 2 \#(rand-int (shared/max-path-length))))" "(repeatedly 5 \#(rand-int (shared/max-path-length)))" "(ap/phero-points  1)" "(ap/phero-points  2)" "(ap/phero-points  0)" "(ap/phero-points  2)" "(ap/phero-points  22)" "(ap/phero-points  0)" "(perform-trial)" "(shared/thresh)" "(perform-trial)" "(shared/thresh)" "(perform-trial)" "(shared/thresh)" "(repeatedly (shared/get-num-trails) \#(perform-trial))" "(shared/thresh)" "(perform-trial)" "(shared/get-num-trails)" "(repeatedly (shared/get-num-trails) \#(perform-trial))" "(perform-trial)" "(repeatedly (shared/get-num-trails) \#(perform-trial))" "(perform-trial)" "(shared/get-num-trails)" "(shared/thresh)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(phases/perform-trial)" "(phase/perform-trial)" "(ap/init-trail-paths)" "(tgaa.algo./init-trail-paths)" "(tgaa.algo.trial /init-trail-paths)" "(tgaa.algo.trial/init-trail-paths)" "(tgaa.util.ant-path/ant-path 10)" "(rand-ant-dir start-point)" "(tgaa.util.ant/rand-ant-dir start-point)" "(tgaa.util.ant/rand-ant-dir 4)" "(tgaa.util.ant/rand-ant-dir [1 1])" "(tgaa.util.ant-path/ant-path 10)" "(tgaa.algo.trial/init-trail-paths)" "(ns-name)" "(phase/trapping)" "(trapping)" "(load-image )" "(bootstrap)" "(perform-trial )" "(ap/init-trail-paths)" "(ap/proc-all-ants (ap/init-trail-paths))" "(def trial-paths (ap/proc-all-ants (ap/init-trail-paths)))" "(shared/add-canidates (trial/trapped-ants trial-paths))" "(def trial-thresh (trial/trap-escaped-thresh trial-paths))" "(when (> trial-thresh (shared/thresh))\\r\\n             (shared/update-thresh trial-thresh))" "trial-thresh" "(trial/trap-escaped-thresh trial-paths)" "(perform-trial )" "(shared/thresh)" "(perform-trial )" "(shared/thresh)" "(trial/trap-escaped-thresh trial-paths)" "(bootstrap)" "(shared/canidates)" "(shared/add-canidates [])" "(shared/canidates)" "(shared/add-canidates [])" "(shared/canidates)" "\\n(reset\! shared/trial-state  (assoc @shared/trial-state \:cand-paths (apply conj (\:cand-paths @shared/trial-state) [])))" "\\n(reset\! shared/trial-state  (assoc @shared/trial-state \:cand-paths []))" "(shared/canidates)" "(bootstrap)" "(shared/canidates)" "(perform-trial )" "(shared/canidates)" "(shared/thresh\\n  )" "\\n(reset\! shared/trial-state  (assoc @shared/trial-state \:cand-paths []))" "(bootstrap)" "(def trial-paths (ap/proc-all-ants (ap/init-trail-paths)))" "(trial/trap-escaped-thresh trial-paths)" "trial-paths" "(bootstrap)" "\\n(reset\! shared/trial-state  (assoc @shared/trial-state \:cand-paths []))" "(perform-trial )" "(shared/thresh\\n  )" "(perform-trial )" "(shared/thresh\\n  )" "(perform-trial )" "(shared/thresh\\n  )" "(perform-trial )" "(shared/thresh\\n  )" "(perform-trial )" "(shared/thresh\\n  )" "(perform-trial )" "(shared/thresh\\n  )" "(perform-trial )" "(shared/thresh\\n  )" "(phase/load-image)" "  (use mikera.image.colours)\\r\\n  (use mikera.image.core)\\r\\n  (use mikera.image.filters)\\r\\n  (use mikera.image.spectrum)" "  (use 'mikera.image.colours)\\r\\n  (use 'mikera.image.core)\\r\\n  (use 'mikera.image.filters)\\r\\n  (use 'mikera.image.spectrum)" "(show (tgaa.util.image/get-image))" "(show ((contrast 0.5) (tgaa.util.image/get-image)))" "(ArrayColormap" "(com.jhlabs.image.ArrayColormap.)" "getColor" "(let [f (com.jhlabs.image.ArrayColormap.)]\\n  (. f getColor 0.5))" "(com.jhlabs.image.ThresholdFilter.)" "(defn laplace\\r\\n  \\"Creates an edge detection filter based on Laplace operators.\\"\\r\\n  (^Filter []\\r\\n   (Filter. (com.jhlabs.image.ThresholdFilter.))))" "(defn thresh\\r\\n  \\"Creates an edge detection filter based on Laplace operators.\\"\\r\\n  (^Filter []\\r\\n   (Filter. (com.jhlabs.image.ThresholdFilter.))))" "(defn thresh\\r\\n  \\"Creates an edge detection filter based on Laplace operators.\\"\\r\\n  (^Filter []\\r\\n   (mikera.image.filters/Filter. (com.jhlabs.image.ThresholdFilter.))))" "(defn thresh\\r\\n  \\"Creates an edge detection filter based on Laplace operators.\\"\\r\\n  (^Filter []\\r\\n   (mikera.image.filters.Filter. (com.jhlabs.image.ThresholdFilter.))))" "(defn thresh\\r\\n  \\"Creates an edge detection filter based on Laplace operators.\\"\\r\\n  (^Filter []\\r\\n   (com.jhlabs.image.Filter. (com.jhlabs.image.ThresholdFilter.))))" "(defn thresh\\r\\n  \\"Creates an edge detection filter based on Laplace operators.\\"\\r\\n  (^Filter []\\r\\n   (com.jhlabs.filter.Filter. (com.jhlabs.image.ThresholdFilter.))))" "(defn thresh\\r\\n  \\"Creates an edge detection filter based on Laplace operators.\\"\\r\\n  (^Filter []\\r\\n   (Filter. (com.jhlabs.image.ThresholdFilter.))))" "(defn thresh\\r\\n  \\"Creates an edge detection filter based on Laplace operators.\\"\\r\\n  (^Filter []\\r\\n   (mikera.image.filters.Filter. (com.jhlabs.image.ThresholdFilter.))))" "(defn thresh\\r\\n  \\"Creates an edge detection filter based on Laplace operators.\\"\\r\\n  (^Filter []\\r\\n   (mikera.image.filters/Filter. (com.jhlabs.image.ThresholdFilter.))))" "(defn thresh\\r\\n  \\"Creates an edge detection filter based on Laplace operators.\\"\\r\\n  (^Filter []\\r\\n   (mikera.image.filters/->Filter (com.jhlabs.image.ThresholdFilter.))))" "\\r\\n(deftype Filter [^BufferedImageOp image-op]\\r\\n  clojure.lang.IFn\\r\\n    (invoke [this image]\\r\\n      (let [^BufferedImage image image \\r\\n            dest-img (.createCompatibleDestImage image-op image (.getColorModel image))]\\r\\n        (.filter image-op image dest-img)\\r\\n        dest-img))\\r\\n    (applyTo [this args] \\r\\n      (clojure.lang.AFn/applyToHelper this args)))" "(defn thresh\\r\\n  \\"Creates an edge detection filter based on Laplace operators.\\"\\r\\n  (^Filter []\\r\\n   (mikera.image.filters/Filter. (com.jhlabs.image.ThresholdFilter.))))" "(defn thresh\\r\\n  \\"Creates an edge detection filter based on Laplace operators.\\"\\r\\n  (^Filter []\\r\\n   (mikera.image.filters/Filter (com.jhlabs.image.ThresholdFilter.))))" "\\r\\n   (mikera.image.filters/blur)" "(defn thresh\\r\\n  \\"Creates an edge detection filter based on Laplace operators.\\"\\r\\n  (^Filter []\\r\\n   (mikera.image.filters/Filter (com.jhlabs.image.ThresholdFilter.))))" "(Filter. nil)" "(mikera.image.filters/Filter. nil)" "(mikera.image.filters/->Filter nil)" "(let [f (com.jhlabs.image.ThresholdFilter.)\\n      _ (. f setUpperThreshold -100000)]\\n      \\n  (mikera.image.filters/->Filter f))" "(show ((let [f (com.jhlabs.image.ThresholdFilter.)\\n             _ (. f setUpperThreshold -100000)]\\n         (mikera.image.filters/->Filter f)) (tgaa.util.image/get-image)))" "(defn threshold\\n  (^mikera.image.filters/->Filter [upper-threshold]\\n   (let [f (com.jhlabs.image.ThresholdFilter.)\\n               _ (. f setUpperThreshold upper-threshold)]\\n           (mikera.image.filters/->Filter f)) (tgaa.util.image/get-image)))" "(show ((tgaa.java.util.filters/threshold -100000) (tgaa.util.image/get-image)))" "tgaa.util.shared" "tgaa.util.shared/config" "tgaa.util.shared/trial-state" "process-image" "(process-image)" "tgaa.util.shared/trial-state" "(show ((tgaa.java.util.filters/threshold -11711155) (tgaa.util.image/get-image)))" "(show ((tgaa.java.util.filters/threshold 0) (tgaa.util.image/get-image)))" "(tgaa.util.image/get-image)" "(show (tgaa.util.image/get-image))" "(show ((tgaa.java.util.filters/threshold -99999999) (tgaa.util.image/get-image)))" "(show ((let [f (com.jhlabs.image.ThresholdFilter.  -100000)]\\n         (mikera.image.filters/->Filter f)) (tgaa.util.image/get-image)))" "(show ((let [f (com.jhlabs.image.ThresholdFilter.  -11711155)]\\n         (mikera.image.filters/->Filter f)) (tgaa.util.image/get-image)))" "(show ((let [f (com.jhlabs.image.ThresholdFilter.  0)]\\n         (mikera.image.filters/->Filter f)) (tgaa.util.image/get-image)))" "(show ((let [f (com.jhlabs.image.ThresholdFilter.  -999999999)]\\n         (mikera.image.filters/->Filter f)) (tgaa.util.image/get-image)))" "(defn threshold\\n  (^mikera.image.filters/->Filter [upper-threshold]\\n   (let [f  (com.jhlabs.image.ThresholdFilter.  -999999999)\\n               _ (. f setUpperThreshold upper-threshold)]\\n           (mikera.image.filters/->Filter f)) (tgaa.util.image/get-image)))" "(let [f  (com.jhlabs.image.ThresholdFilter.  -999999999)\\n      _ (. f setUpperThreshold -100000)]\\n      \\n  (mikera.image.filters/->Filter f))" "(show (let [f  (com.jhlabs.image.ThresholdFilter.  -999999999)\\n            _ (. f setUpperThreshold -100000)]\\n      \\n        (mikera.image.filters/->Filter f)))" "(show ((let [f  (com.jhlabs.image.ThresholdFilter.  -999999999)\\n             _ (. f setUpperThreshold -100000)]\\n      \\n         (mikera.image.filters/->Filter f))) (tgaa.util.image/get-image))" "(defn threshold\\r\\n  \\"Creates a threshold filter\\"\\r\\n  (^Filter [upper-threshold]\\r\\n   (let [f (com.jhlabs.image.ThresholdFilter.)\\r\\n         _ (. f setUpperThreshold upper-threshold)]  \\r\\n     (Filter. f))))" "(show ((let [f  (com.jhlabs.image.ThresholdFilter.  -999999999)\\n             _ (. f setUpperThreshold -100000)]\\n      \\n         (mikera.image.filters/->Filter f))) (tgaa.util.image/get-image))" "(show ((tgaa.java.util.filters/threshold -99999999) (tgaa.util.image/get-image)))" "(show ((tgaa.java.util.filters/threshold 127) (tgaa.util.image/get-image)))" "(show ((tgaa.java.util.filters/threshold 130) (tgaa.util.image/get-image)))" "(show ((tgaa.java.util.filters/threshold 530) (tgaa.util.image/get-image)))" "(show ((tgaa.java.util.filters/threshold 100) (tgaa.util.image/get-image)))" "(show ((tgaa.java.util.filters/blur) (tgaa.util.image/get-image)))" "(show ((tgaa.java.util.filters/threshold 100) (tgaa.util.image/get-image)))" "(show ((tgaa.java.util.filters/edge) (tgaa.util.image/get-image)))" "(defn process-image [] \\r\\n  (do(phase/load-image)\\r\\n       (phase/bootstrap)\\r\\n       (phase/trapping)))" "(tgaa.util.shared/trial-num)" "(tgaa.util.shared/trial-state)" "(@tgaa.util.shared/trial-state)" "tgaa.util.shared/trial-state" "(phase/bootstrap)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "tgaa.util.shared/trial-state" "(process-image)" "tgaa.util.shared/trial-state" "(show ((tgaa.java.util.filters/threshold 100) (tgaa.util.image/get-image)))" "(mikera.image.core/show ((tgaa.java.util.filters/threshold 100) (tgaa.util.image/get-image)))" "(use  'mikera.image.core )" "(show ((tgaa.java.util.filters/threshold 100) (tgaa.util.image/get-image)))" " (.createCompatibleDestImage image-op (tgaa.util.image/get-image) (.getColorModel (tgaa.util.image/get-image)))" "(process-image)" "tgaa.util.shared" "tgaa.util.shared/trial-state" "(mikera.image.core/show ((tgaa.java.util.filters/threshold 100) (tgaa.util.image/get-image)))" "(use  'mikera.image.core )" "(def ti ((tgaa.java.util.filters/threshold 100) (tgaa.util.image/get-image)))" "(. getType ti)" "(class ti)" "(. ti getType )" "tgaa.util.shared" "tgaa.util.shared/trial-state" "(keys tgaa.util.shared/trial-state)" "(keys @tgaa.util.shared/trial-state)" "(. (\:image @tgaa.util.shared/trial-state) getType)" "(to-image-op (\:image @tgaa.util.shared/trial-state) getType)" "(mikera.image.filters/to-image-op (\:image @tgaa.util.shared/trial-state) getType)" "(mikera.image.filters/to-image-op (\:image @tgaa.util.shared/trial-state))" "(tgaa.java.util.filters/threshold 100)" "(class (tgaa.java.util.filters/threshold 100))" "(com.jhlabs.image.ThresholdFilter. partition-value)" "(tgaa.java.util.filters.Filter (\:image tgaa.util.shared/trial-state))" "(show ((tgaa.java.util.filters/grayscale) (tgaa.util.image/get-image)))" "(. (show ((tgaa.java.util.filters/grayscale) (tgaa.util.image/get-image))) getType )" "(. getType ti)" "(. (\:image @tgaa.util.shared/trial-state) getType)" "(. ((tgaa.java.util.filters/grayscale) (tgaa.util.image/get-image)) getType )" "(phase/load-image)" "(phase/bootstrap)" "(. (\:image @tgaa.util.shared/trial-state) getType)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.shared/thresh)" "((tgaa.java.util.filters/grayscale (tgaa.util.shared/thresh)) (\:image @tgaa.util.shared/trial-state) getType)" "((tgaa.java.util.filters/grayscale (tgaa.util.shared/thresh)) (\:image @tgaa.util.shared/trial-state))" "((tgaa.java.util.filters/threshold (tgaa.util.shared/thresh)) (\:image @tgaa.util.shared/trial-state))" "(show ((tgaa.java.util.filters/threshold (tgaa.util.shared/thresh)) (\:image @tgaa.util.shared/trial-state)))" "(use  'mikera.image.core )" "(show ((tgaa.java.util.filters/threshold (tgaa.util.shared/thresh)) (\:image @tgaa.util.shared/trial-state)))" "(show ((tgaa.java.util.filters/threshold 0) (\:image @tgaa.util.shared/trial-state)))" "(show ((tgaa.java.util.filters/threshold 256) (\:image @tgaa.util.shared/trial-state)))" "(tgaa.util.shared/thresh)" "(bit-shift-left (tgaa.util.shared/thresh) 16)" "(bit-shift-left (tgaa.util.shared/thresh) 8)" "(bit-shift-left (tgaa.util.shared/thresh))" "(bit-shift-left (tgaa.util.shared/thresh)1)" "(bit-shift-right (tgaa.util.shared/thresh)1)" "(bit-shift-right (tgaa.util.shared/thresh)16)" "(bit-shift-right (tgaa.util.shared/thresh)8)" "(show ((tgaa.java.util.filters/threshold 237) (\:image @tgaa.util.shared/trial-state)))" "(show ((tgaa.java.util.filters/threshold -237) (\:image @tgaa.util.shared/trial-state)))" "(show ((tgaa.java.util.filters/threshold 237) (\:image @tgaa.util.shared/trial-state)))" "(phase/trapping)" "(bit-shift-right (tgaa.util.shared/thresh)8)" "(bit-shift-right (tgaa.util.shared/thresh)16)" "(show ((tgaa.java.util.filters/threshold 238) (\:image @tgaa.util.shared/trial-state)))" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.shared/thresh)" "(show ((tgaa.java.util.filters/threshold 98) (\:image @tgaa.util.shared/trial-state)))" "(use  'mikera.image.core )" "(show ((tgaa.java.util.filters/threshold 98) (\:image @tgaa.util.shared/trial-state)))" "(tgaa.util.image/show-segmentaton)" "(phase/load-image)" " (phase/bootstrap)" "(phase/trapping)" "(tgaa.util.shared/thresh)" "(tgaa.util.image/show-segmentaton)" "(tgaa.util.shared/image-ref)" "(. (tgaa.util.shared/image-ref) createGraphics)" "(let [g (. (tgaa.util.shared/image-ref) createGraphics)\\n      _ (. g setBackground 0)\\n      _ (. g fillRect 0 0 100 100)])" "(let [g (. (tgaa.util.shared/image-ref) createGraphics)\\n      _ (. g setBackground Color.WHITE)\\n      _ (. g fillRect 0 0 100 100)])" "(let [g (. (tgaa.util.shared/image-ref) createGraphics)\\n      _ (. g setBackground java.awt.Color.WHITE)\\n      _ (. g fillRect 0 0 100 100)])" "(let [g (. (tgaa.util.shared/image-ref) createGraphics)\\n      _ (. g setBackground java.awt.image.Color.WHITE)\\n      _ (. g fillRect 0 0 100 100)])" "(import 'java.awt.image Color)" "(import 'java.awt.image.Color)" "(import [java.awt.image Color])" "(import [java.awt Color])" "(let [g (. (tgaa.util.shared/image-ref) createGraphics)\\n      _ (. g setBackground java.awt.image.Color.WHITE)\\n      _ (. g fillRect 0 0 100 100)])" "(let [g (. (tgaa.util.shared/image-ref) createGraphics)\\n      _ (. g setBackground Color.WHITE)\\n      _ (. g fillRect 0 0 100 100)])" "(let [g (. (tgaa.util.shared/image-ref) createGraphics)\\n      _ (. g setBackground java.awt.Color.WHITE)\\n      _ (. g fillRect 0 0 100 100)])" "(import [java.awt Color])" "java.awt.Color.WHITE" "java.awt.Color." "java.awt.Color" "(def c java.awt.Color)" "c" "c.WHITE" "(. Color WHITE)" "(Color. WHITE)" "(. Color WHITE)" "(let [g (. (tgaa.util.shared/image-ref) createGraphics)\\n      _ (. g setBackground (. Color WHITE))\\n      _ (. g fillRect 0 0 100 100)])" "(show (tgaa.util.shared/image-ref))" "\\n(use 'mikera.image.core)" "(show (tgaa.util.shared/image-ref))" "(let [g (. (tgaa.util.shared/image-ref) createGraphics)\\n      _ (. g setBackground (. Color YELLOW))\\n      _ (. g fillRect 0 0 100 100)])" "(import [java.awt BasicStroke])" "(BasicStroke. 2)" "(let [g (. (tgaa.util.shared/image-ref) createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (BasicStroke. 2))\\n      _ (map (fn[ant]  ) tgaa.util.shared/canidates)" "tgaa.util.shared/canidates" "(tgaa.util.shared/canidates)" "(map (fn [{\:start start} v] start) (tgaa.util.shared/canidates))" "(map (fn [{\:start start}] start) (tgaa.util.shared/canidates))" "(map (fn [{\:start start} val] start) (tgaa.util.shared/canidates))" "(map (fn [\:keys {\:start start}] start) (tgaa.util.shared/canidates))" "(map (fn [{\:keys [\:start start]}] start) (tgaa.util.shared/canidates))" "(map (fn [{\:keys [\:start \:end]}] start) (tgaa.util.shared/canidates))" "(let [g (. (tgaa.util.shared/image-ref) createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (BasicStroke. 2))\\n      _ (map (fn [{\:keys [start end]}] (. g drawLine (first start) (second start) (first end) (second end))) (tgaa.util.shared/canidates))])" "(show (tgaa.util.shared/image-ref))" "(let [g (. (tgaa.util.shared/image-ref) createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (BasicStroke. 2))\\n      _ (map (fn [{\:keys [start end]}] [(first start) (second start) (first end) (second end)]) (tgaa.util.shared/canidates))])" "(map (fn [{\:keys [start end]}] [(first start) (second start) (first end) (second end)]) (tgaa.util.shared/canidates))]" "(tgaa.util.shared/canidates)" "(let [g (. (tgaa.util.shared/image-ref) createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (BasicStroke. 2))\\n      _ (map (fn [{\:keys [start end]}] [(first start) (second start) (+ (first end) 30) (+ (second end) 20)]) (tgaa.util.shared/canidates))])" "(show (tgaa.util.shared/image-ref))" "(let [g (. (tgaa.util.shared/image-ref) createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (BasicStroke. 2))\\n      _ (map (fn [{\:keys [start end]}] (. g drawLine (first start) (second start) (+ (first end) 10) (+ (second end) 10))) (tgaa.util.shared/canidates))])" "(show (tgaa.util.shared/image-ref))" "(let [g (. (tgaa.util.shared/image-ref) createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (BasicStroke. 2))\\n      _ (map (fn [{\:keys [start end]}] (. g drawLine (first start) (second start) (+ (first end) 10) (+ (second end) 10))) (tgaa.util.shared/canidates))])" "(show (tgaa.util.shared/image-ref))" "(let [g (. (tgaa.util.shared/image-ref) createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (BasicStroke. 10))\\n      _ (. g drawLine 10 10 100 100)])" "(show (tgaa.util.shared/image-ref))" "(let [g (. (tgaa.util.shared/image-ref) createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (BasicStroke. 2))\\n      _ (map (fn [{\:keys [start end]}] [(first start) (second start) (+ (first end) 30) (+ (second end) 20)]) (tgaa.util.shared/canidates))])" "(map (fn [{\:keys [start end]}] [(first start) (second start) (+ (first end) 30) (+ (second end) 20)]) (tgaa.util.shared/canidates))" "(let [g (. (tgaa.util.shared/image-ref) createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (BasicStroke. 10))\\n      _ (. g drawLine  449 585 479 605)])" "(show (tgaa.util.shared/image-ref))" "(let [g (. (tgaa.util.shared/image-ref) createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (BasicStroke. 10))\\n      _ (. g drawLine  511 222 541 242)])" "(show (tgaa.util.shared/image-ref))" "(let [g (. (tgaa.util.shared/image-ref) createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (BasicStroke. 2))\\n      _ (doall (map (fn [{\:keys [start end]}] (. g drawLine (first start) (second start) (+ (first end) 10) (+ (second end) 10))) (tgaa.util.shared/canidates)))])" "(show (tgaa.util.shared/image-ref))" "\\n(->> (doto (. (tgaa.util.shared/image-ref) createGraphics)\\n       (.setColor (. Color YELLOW))\\n       (.setStroke (BasicStroke. 2)))\\n  (fn [g] (doall (map \\n                   (fn [{\:keys [start end]}] \\n                     (. g drawLine (first start) (second start) (+ (first end) 10) (+ (second end) 10))) \\n                   (tgaa.util.shared/canidates)))))" "\\n(let [g (doto (. (tgaa.util.shared/image-ref) createGraphics)\\n          (.setColor (. Color YELLOW))\\n          (.setStroke (BasicStroke. 2)))]\\n  (doall (map \\n           (fn [{\:keys [start end]}] \\n             (. g drawLine (first start) (second start) (+ (first end) 10) (+ (second end) 10))) \\n           (tgaa.util.shared/canidates))))" "\\n(let [g (doto (. (tgaa.util.shared/image-ref) createGraphics)\\n          (.setColor (. Color ORANGE))\\n          (.setStroke (BasicStroke. 2)))]\\n  (doall (map \\n           (fn [{\:keys [start end]}] \\n             (. g drawLine (first start) (second start) (+ (first end) 10) (+ (second end) 10))) \\n           (tgaa.util.shared/canidates))))" "(show (tgaa.util.shared/image-ref))" "(defn show-paths [ant-paths-filter-func]\\n  (let [g (doto (. (tgaa.util.shared/image-ref) createGraphics)\\n            (.setColor (. Color ORANGE))\\n            (.setStroke (BasicStroke. 2)))]\\n    (doall (map \\n             (fn [{\:keys [start end]}] \\n               (. g drawLine (first start) (second start) (+ (first end) 10) (+ (second end) 10))) \\n             (filter  ant-paths-filter-func (tgaa.util.shared/canidates))))))" "(defn show-paths [ant-paths-filter-func]\\n  (let [g (doto (. (tgaa.util.shared/image-ref) createGraphics)\\n            (.setColor (. Color RED))\\n            (.setStroke (BasicStroke. 2)))]\\n    (doall (map \\n             (fn [{\:keys [start end]}] \\n               (. g drawLine (first start) (second start) (+ (first end) 10) (+ (second end) 10))) \\n             (filter  ant-paths-filter-func (tgaa.util.shared/canidates))))))" "(show-paths '(fn [x] (\= (\:trial-num x) 10)))" "(filter (fn [x] (\= (\:trial-num x) 10))(tgaa.util.shared/canidates))" "(filter (fn [x] (\= (\:trial-num x) 0))(tgaa.util.shared/canidates))" "(show-paths '(fn [x] (\= (\:trial-num x) 0)))" "(defn show-paths []\\n  (let [g (doto (. (tgaa.util.shared/image-ref) createGraphics)\\n            (.setColor (. Color RED))\\n            (.setStroke (BasicStroke. 2)))]\\n    (doall (map \\n             (fn [{\:keys [start end]}] \\n               (. g drawLine (first start) (second start) (+ (first end) 10) (+ (second end) 10))) \\n             (tgaa.util.shared/canidates)))))" "(show-paths)" "(defn draw-paths []\\n  (let [g (doto (. (tgaa.util.shared/image-ref) createGraphics)\\n            (.setColor (. Color YELLOW))\\n            (.setStroke (BasicStroke. 2)))]\\n    (doall (map \\n             (fn [{\:keys [start end]}] \\n               (. g drawLine (first start) (second start) (+ (first end) 10) (+ (second end) 10))) \\n             (tgaa.util.shared/canidates)))))" "(show-paths)" "(defn show-paths [ant-paths-filter-func]\\n  (let [g (doto (. (tgaa.util.shared/image-ref) createGraphics)\\n            (.setColor (. Color RED))\\n            (.setStroke (BasicStroke. 2)))]\\n    (doall (map \\n             (fn [{\:keys [start end]}] \\n               (. g drawLine (first start) (second start) (+ (first end) 10) (+ (second end) 10))) \\n             (filter  \#ant-paths-filter-func (tgaa.util.shared/canidates))))))" "(defn show-paths [ant-paths-filter-func]\\n  (let [g (doto (. (tgaa.util.shared/image-ref) createGraphics)\\n            (.setColor (. Color RED))\\n            (.setStroke (BasicStroke. 2)))]\\n    (doall (map \\n             (fn [{\:keys [start end]}] \\n               (. g drawLine (first start) (second start) (+ (first end) 10) (+ (second end) 10))) \\n             (filter  ant-paths-filter-func (tgaa.util.shared/canidates))))))" "(defn show-paths [ant-paths-filter-func]\\n  (let [g (doto (. (tgaa.util.shared/image-ref) createGraphics)\\n            (.setColor (. Color RED))\\n            (.setStroke (BasicStroke. 2)))]\\n    (doall (map \\n             (fn [{\:keys [start end]}] \\n               (. g drawLine (first start) (second start) (+ (first end) 10) (+ (second end) 10))) \\n             (filter  \#(ant-paths-filter-func %) (tgaa.util.shared/canidates))))))" "(show-paths '(fn [x] (\= (\:trial-num x) 0)))" "(show-paths (fn [x] (\= (\:trial-num x) 0)))" "(defn show-paths [ant-paths-filter-func]\\n  (let [g (doto (. (tgaa.util.shared/image-ref) createGraphics)\\n            (.setColor (. Color RED))\\n            (.setStroke (BasicStroke. 2)))]\\n    (doall (map \\n             (fn [{\:keys [start end]}] \\n               (. g drawLine (first start) (second start) (+ (first end) 10) (+ (second end) 10))) \\n             (filter ant-paths-filter-func (tgaa.util.shared/canidates))))))" "(show-paths (fn [x] (\= (\:trial-num x) 0)))" "(defn show-paths [ant-paths-filter-func color]\\n  (let [        g (doto (. (tgaa.util.shared/image-ref) createGraphics)\\n            (.setColor (. Color color))\\n            (.setStroke (BasicStroke. 2)))]\\n    (doall (map \\n             (fn [{\:keys [start end]}] \\n               (. g drawLine (first start) (second start) (+ (first end) 10) (+ (second end) 10))) \\n             (filter ant-paths-filter-func (tgaa.util.shared/canidates))))))" "(. Color RED)" "(. Color \\"RED\\")" "(str(. Color \\"RED\\"))" "(str \\"(. Color\\" \\"RED\\")" "(str \\"(. Color \\" \\"RED\\" \\")\\")" "(eval (str \\"(. Color \\" \\"RED\\" \\")\\"))" "(eval-str (str \\"(. Color \\" \\"RED\\" \\")\\"))" "(read-string (str \\"(. Color \\" \\"RED\\" \\")\\"))" "(*read-eval* (str \\"(. Color \\" \\"RED\\" \\")\\"))" "(*read-eval* (read-string (str \\"(. Color \\" \\"RED\\" \\")\\")))" "(eval (read-string (str \\"(. Color \\" \\"RED\\" \\")\\")))" "(defn show-paths [ant-paths-filter-func color-name-str]\\n  (let [g (doto (. (tgaa.util.shared/image-ref) createGraphics)\\n            (.setColor (eval (read-string (str \\"(. Color \\" color \\")\\"))))\\n            (.setStroke (BasicStroke. 2)))]\\n    (doall (map \\n             (fn [{\:keys [start end]}] \\n               (. g drawLine (first start) (second start) (first end) (second end))) \\n             (filter ant-paths-filter-func (tgaa.util.shared/canidates))))))" "(defn show-paths [ant-paths-filter-func color-name-str]\\n  (let [g (doto (. (tgaa.util.shared/image-ref) createGraphics)\\n            (.setColor (eval (read-string (str \\"(. Color \\" color-name-str \\")\\"))))\\n            (.setStroke (BasicStroke. 2)))]\\n    (doall (map \\n             (fn [{\:keys [start end]}] \\n               (. g drawLine (first start) (second start) (first end) (second end))) \\n             (filter ant-paths-filter-func (tgaa.util.shared/canidates))))))" "(defn draw-paths [ant-paths-filter-func color-name-str img-ref]\\n  (let [g (doto (. img-ref createGraphics)\\n            (.setColor (eval (read-string (str \\"(. Color \\" color-name-str \\")\\"))))\\n            (.setStroke (BasicStroke. 2)))]\\n    (doall (map \\n             (fn [{\:keys [start end]}] \\n               (. g drawLine (first start) (second start) (first end) (second end))) \\n             (filter ant-paths-filter-func (tgaa.util.shared/canidates))))))" "(draw-paths (fn [x] true) \\"BLUE\\" (tgaa.util.shared/image-ref))" "(show (tgaa.util.shared/image-ref))" "(clojure.string/upper-case \\"t\\")" "(defn draw-paths [ant-paths-filter-func color-name-str img-ref line-width]\\r\\n  (let [g (doto (. img-ref createGraphics)\\r\\n            (.setColor (eval (read-string \\r\\n                               (str \\"(. Color \\"  \\r\\n                                    (upper-case color-name-str) \\")\\"))))\\r\\n            (.setStroke (BasicStroke. line-width)))]\\r\\n    (doall (map \\r\\n             (fn [{\:keys [start end]}] \\r\\n               (. g drawLine (first start) (second start) (first end) (second end))) \\r\\n             (filter ant-paths-filter-func (tgaa.util.shared/canidates))))))" "tgaa.util.shared" "tgaa.util.shared/canidates" "(first (tgaa.util.shared/canidates))" "(require [tgaa.algo.ant \:as a])" "(require [tgaa.util.ant \:as a])" "(require [tgaa.algo.ant \:as a])" "(shared/config)" "shared/config" "(init-trail-paths )" "(image/get-image)" "(tgaa.algo.phases/load-image)" "(init-trail-paths )" "(defn create-ant-path[]\\r\\n  {})" "(create-ant-path)" "create-ant-path" "(ant/create-ant-path)" "(-> (ant/create-ant-path) (ant/update-ant-thresh true))" "(->> (ant/create-ant-path) (ant/update-ant-thresh true))" "(->> (ant/create-ant-path) (ant/update-ant-thresh true) (ant/update-ant-end-point [10 10]))" "(->> (ant/create-ant-path) \\n  (ant/update-ant-thresh true) \\n  (ant/update-ant-start-point [10 10])\\n  (ant/update-ant-end-point [15 15])\\n  (ant/update-ant-end-point [10 10]))" "(->> (ant/create-ant-path) \\n  (ant/update-ant-thresh true) \\n  (ant/update-ant-start-point [10 10])\\n  (ant/update-ant-start-point [15 15])\\n  (ant/update-ant-end-point [10 10]))" "(->> (ant/create-ant-path) \\n  (ant/update-ant-thresh true) \\n  (ant/update-ant-dir-vec [10 10])\\n  (ant/update-ant-start-point [15 15])\\n  (ant/update-ant-end-point [10 10]))" "(->> (ant/create-ant-path) \\n  (ant/update-ant-trial-num 0)\\n  (ant/update-ant-thresh true) \\n  (ant/update-ant-dir-vec [10 10])\\n  (ant/update-ant-start-point [15 15])\\n  (ant/update-ant-end-point [10 10]))" "(defn tg [& v]\\n  (if (emtpy? v)\\n    10\\n    (assoc (second v) \:testg (first v))))" "(defn tg [& v]\\n  (if (empty? v)\\n    10\\n    (assoc (second v) \:testg (first v))))" "(g)" "(tg)" "(->> {\:one 1} (tg 33))" "(defn tc [& v]\\n  (if (empty? v)\\n    10\\n    (assoc (second v) \:testc (first v))))" "(->> {\:one 1} (tg 33) (tc 55))" "(defn attribute-set-get [key & in]\\r\\n  (let [in-flat (flatten in)]\\r\\n  (if (\= (count in-flat) 1)\\r\\n      (key-name (first in-flat))\\r\\n      (attribute-update key-name (second in-flat) key-name (first in-flat)))))" "(defn attribute-set-get [key-name & in]\\r\\n  (let [in-flat (flatten in)]\\r\\n    (if (\= (count in-flat) 1)\\r\\n      (key-name (first in-flat))\\r\\n      (attribute-update key-name (second in-flat) key-name (first in-flat)))))" "(defn attribute-set-get [key-name & in]\\r\\n  (let [in-flat (flatten in)]\\r\\n    (if (\= (count in-flat) 1)\\r\\n      (key-name (first in-flat))\\r\\n      ((second in-flat) key-name (first in-flat)))))" "(attribute-set-get \:test '((10 {})))" "(defn attribute-set-get [key-name & in]\\r\\n  (let [in-flat (flatten in)]\\r\\n    (if (\= (count in-flat) 1)\\r\\n      (key-name (first in-flat))\\r\\n      (assoc (second in-flat) key-name (first in-flat)))))" "(attribute-set-get \:test '((10 {})))" "(defn attribute-set-get [key-name & in]\\r\\n  (let [in-flat (flatten in)]\\r\\n    (if (\= (count in-flat) 1)\\r\\n      (key-name (first in-flat))\\r\\n      (assoc (second in-flat) key-name (first in-flat)))))\\r\\n\\r\\n(defn ant-thresh? [& in]\\r\\n  (attribute-set-get \:thresh? in)" "(defn ant-thresh? [& in]\\r\\n  (attribute-set-get \:thresh? in))" "(ant-thresh? {\:test 10})" "(ant-thresh? {\:thresh? 10})" "(ant-thresh? 33 {\:thresh? 10})" "(ant-path [ 22 22])" "(ant-path [22 22])" "(defn ant-path [start-point]\\r\\n  \\"Creates an ant path\\"\\r\\n  (->> (ant/create-ant-path) \\r\\n    (ant/ant-trial-num (shared/trial-num))\\r\\n    (ant/ant-thresh? false) \\r\\n    (ant/ant-dir-vec (rand-ant-dir start-point))\\r\\n    (ant/ant-start-point (rand-ant-dir start-point))))" "(ant-path [22 22])" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "tgaa.util.shared" "tgaa.util.shared/thresh" "(tgaa.util.shared/thresh)" "(phase/trapping)" "(tgaa.util.shared/thresh)" "(phase/trapping)" "(tgaa.util.shared/thresh)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.shared/thresh)" "(phase/trapping)" "(tgaa.util.shared/thresh)" "(phase/trapping)" "(tgaa.util.shared/thresh)" "(phase/trapping)" "(tgaa.util.shared/thresh)" "(phase/trapping)" "(tgaa.util.shared/thresh)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.shared/thresh)" "(tgaa.util.image/draw-all-can-paths)" "\\njava.awt.Color" "\\n(java.awt.Color.)" "(. Color WHiTE)" "(java.awt.Color WHiTE)" "(java.awt.Color WHITE)" "(import 'java.awt.Color)" "(java.awt.Color WHITE)" "(. Color WHiTE)" "(. Color WHITE)" "(str \\"(. Color \\"  \\r\\n                                    (upper-case color-name-str) \\")\\")" "(str \\"(. Color \\"  \\r\\n                                    \\"YELLOW\\" \\")\\")" "(tgaa.util.image/draw-all-can-paths)" "(tgaa.util.image/show-image)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/draw-all-can-paths)" "(import  'java.awt.Color)" "(tgaa.util.image/draw-all-can-paths)" "(phase/load-image)" "(phase/trapping)" "(tgaa.util.image/draw-all-can-paths)" "(tgaa.util.image/show-image)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(required tgaa.util.image)" "(required 'tgaa.util.image)" "(require 'tgaa.util.image)" "(tgaa.util.image/show-image)" "(tgaa.util.image/draw-all-can-paths)" "(import 'java.awt.Color)" "(tgaa.util.image/draw-all-can-paths)" "(tgaa.util.image/show-image)" "(require  [mikera.image.core \:as mi])" "(use [mikera.image.core \:as mi])" "(use 'mikera.image.core)" "(require  'mikera.image.core)" "mikera.image.core/copy" "(show (draw-all-can-paths))" "(show (tgaa.util.image/draw-all-can-paths))" "(tgaa.util.image/draw-all-can-paths)" "(show (tgaa.util.image/draw-all-can-paths))" "(phase/load-image)" " (phase/bootstrap)" " (phase/trapping)" "(use 'mikera.image.core)" "(show (tgaa.util.shared/image-ref))" "(show (tgaa.util.image/show-segmentaton))" "(tgaa.util.image/show-segmentaton)" "(tgaa.util.image/show-all-cann-path)" "(tgaa.util.image/draw-all-can-paths)" "(import 'java.awt.Color)" "(tgaa.util.image/draw-all-can-paths)" "(tgaa.util.image/show-all-cann-path)" "(show (tgaa.util.shared/image-ref))" "(tgaa.util.image/show-all-cann-path)" "(phase/load-image)" "(phase/bootstrap)" " (phase/trapping)" "(tgaa.util.image/show-image)" "(tgaa.util.image/show-segmentaton)" "(tgaa.util.image/show-all-cann-path)" "(improt 'java.awt.Color)" "(import 'java.awt.Color)" "(tgaa.util.image/show-all-cann-path)" "tgaa.algo.ant" "tgaa.algo.ant/ant-trial-num" "(draw-can-paths)" "(tgaa.util.image/draw-can-paths)" "((tgaa.util.image/show-cann-path)" "(tgaa.util.image/show-cann-path)" "(tgaa.util.image/show-cann-path 1)" "(tgaa.util.image/show-cann-path 2)" "(tgaa.util.image/show-cann-path 3)" "(tgaa.util.image/show-cann-path 4)" "(tgaa.util.image/show-cann-path 5\\n                                )" "(tgaa.util.image/show-cann-path 10)" "(tgaa.util.image/show-cann-path 15)" "(tgaa.util.image/show-cann-path 20\\n                                )" "(tgaa.util.image/show-cann-path 50\\n                                )" "(tgaa.util.image/show-cann-path 10)" "(def config (get-config))" "(delay (print 101010) 10)" "(def dt (delay (print 101010) 10))" "@dt" "(def dt (delay (print 101010) 100))" "@dt" "(def dt (delay (print 101010) 10000))" "@dt" "(def dtt (delay (print 101010) 10000))" "@dtt" "(force dtt)" "(force @dtt)" "@dtt" "(do (Thread/sleep 500)(print 444))" "(do (Thread/sleep 5000)(print 444))" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.image/show-cann-path 10)" "(phase/load-image)" "(phase/bootstrap)" " (phase/trapping)" "(tgaa.util.image/show-cann-path 10)" "(tgaa.util.image/anim-trail-paths)" "(process-image)" "(tgaa.util.image/show-segmentaton)" "(tgaa.util.image/anim-trail-paths)" "(import 'java.awt.Color)" "(tgaa.util.image/anim-trail-paths)" "(process-image)" "(tgaa.util.image/anim-trail-paths)" "(import 'java.awt.Color)" "(tgaa.util.image/anim-trail-paths)" "(process-image)" "(import 'java.awt.Color)" "(tgaa.util.image/anim-trail-paths)"]
eclipse.preferences.version=1
