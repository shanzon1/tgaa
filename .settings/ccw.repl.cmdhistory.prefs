cmdhistory=["(process-image)" "(macroexpand (import 'java.awt.Color'))" "(macroexpand (import 'java.awt.Color))" "(macroexpand '(import 'java.awt.Color))" "(process-image)" "(tgaa.struct.image/load-import)" "(process-image)" "(JFrame. \\"Hello Frame\\")" "(in-ns 'tgaa.util.gui)" "(JFrame. \\"Hello Frame\\")" "(import 'javax.swing.JFrame)\\r\\n(def frame (JFrame. \\"Hello Frame\\"))\\r\\n(.setSize frame 200 200)\\r\\n(.setVisible frame true)" "(import JOptionPane)" "(import javax.swing.JOptionPane)" "(. JOptionPane showOptionDialog (JFrame. \\"Hello Frame\\") \\"test\\" 1 2)" "(. (JOptionPane.) showOptionDialog (JFrame. \\"Hello Frame\\") \\"test\\" 1 2)" "(. (new JOptionPane) showOptionDialog (JFrame. \\"Hello Frame\\") \\"test\\" 1 2)" "(. (new JOptionPane) showOptionDialog (JFrame. \\"Hello Frame\\") \\"test\\" \\"test\\"\\n  JOptionPane.YES_NO_CANCEL_OPTION JOptionPane.QUESTION_MESSAGE\\n  nil nil nil)" "(. (new JOptionPane) showOptionDialog (JFrame. \\"Hello Frame\\") \\"test\\" \\"test\\"\\n  JOptionPane/YES_NO_CANCEL_OPTION JOptionPane/QUESTION_MESSAGE\\n  nil nil nil)" "(JOptionPane/showOptionDialog (JFrame. \\"Hello Frame\\") \\"test\\" \\"test\\"\\n  JOptionPane/YES_NO_CANCEL_OPTION JOptionPane/QUESTION_MESSAGE\\n  nil nil nil)" "(defn showOptionDialog [question]\\n(JOptionPane/showOptionDialog (JFrame. \\"Hello Frame\\") \\"test\\" \\"test\\"\\n  JOptionPane/YES_NO_CANCEL_OPTION JOptionPane/QUESTION_MESSAGE\\n  nil nil nil))" "(defn showOptionDialog [question]\\n  (JOptionPane/showOptionDialog (JFrame. \\"Hello Frame\\") \\"test\\" \\"test\\"\\n                                JOptionPane/YES_NO_CANCEL_OPTION JOptionPane/QUESTION_MESSAGE\\n                                nil nil nil))" "(showOptionDialog \\"test?\\")" "(defn option-dialog [question]\\n  (JOptionPane/showOptionDialog (JFrame. \\"Hello Frame\\") question \\"test\\"\\n                                JOptionPane/YES_NO_CANCEL_OPTION JOptionPane/QUESTION_MESSAGE\\n                                nil nil nil))" "(option-dialog \\"test?\\")" "(defn option-dialog [question]\\n  (JOptionPane/showOptionDialog (JFrame.) question \\"Select an option.\\"\\n                                JOptionPane/YES_NO_CANCEL_OPTION JOptionPane/QUESTION_MESSAGE\\n                                nil nil nil))" "(option-dialog \\"test?\\")" "(defn option-dialog [question & buttons]\\n  (let [[yes-desc no-desc cancel-desc] buttons]\\n  (JOptionPane/showOptionDialog (JFrame. \\"Hello Frame\\") question \\"test\\"\\n                                JOptionPane/YES_NO_CANCEL_OPTION JOptionPane/QUESTION_MESSAGE\\n                                [yes-desc no-desc cancel-desc] nil nil))" "(defn option-dialog [question & buttons]\\n  (let [[yes-desc no-desc cancel-desc] buttons]\\n  (JOptionPane/showOptionDialog (JFrame. \\"Hello Frame\\") question \\"test\\"\\n                                JOptionPane/YES_NO_CANCEL_OPTION JOptionPane/QUESTION_MESSAGE\\n                                [yes-desc no-desc cancel-desc] nil nil)))" "(option-dialog \\"test?\\")" "(defn option-dialog [question & buttons]\\n  (let [[yes-desc no-desc cancel-desc] buttons]\\n  (JOptionPane/showOptionDialog (JFrame. \\"Hello Frame\\") question \\"test\\"\\n                                JOptionPane/YES_NO_CANCEL_OPTION JOptionPane/QUESTION_MESSAGE\\n                                 nil [yes-desc no-desc cancel-desc] nil)))" "(option-dialog \\"test?\\")" "(defn option-dialog [question & buttons]\\n  (let [[yes-desc no-desc cancel-desc] buttons]\\n  (JOptionPane/showOptionDialog (JFrame. \\"Hello Frame\\") question \\"test\\"\\n                                JOptionPane/YES_NO_CANCEL_OPTION JOptionPane/QUESTION_MESSAGE\\n                                 nil [yes-desc no-desc cancel-desc] nil)))" "(let [[x y] nil] x)" "(defn option-dialog [question & buttons]\\n  (let [[yes-desc no-desc cancel-desc] buttons]\\n  (JOptionPane/showOptionDialog (JFrame. \\"Hello Frame\\") question \\"test\\"\\n                                JOptionPane/YES_NO_CANCEL_OPTION JOptionPane/QUESTION_MESSAGE\\n                                 nil nil nil)))" "(let [[x y] nil] x)" "(option-dialog \\"test?\\")" "(defn option-dialog [question & buttons]\\n  (let [buttons (if (nil? buttons)\\n                  [\\"Yes\\" \\"No\\" \\"Cancel\\"]\\n                  buttons)]\\n  (JOptionPane/showOptionDialog (JFrame. \\"Hello Frame\\") question \\"test\\"\\n                                JOptionPane/YES_NO_CANCEL_OPTION JOptionPane/QUESTION_MESSAGE\\n                                 nil buttons nil)))" "(option-dialog \\"test?\\")" "(defn option-dialog [question & buttons]\\n  (let [buttons (if (nil? buttons)\\n                  [\\"Yes\\" \\"No\\" \\"Cancel\\"]\\n                  buttons)]\\n  (JOptionPane/showOptionDialog (JFrame. \\"Hello Frame\\") question \\"test\\"\\n                                JOptionPane/YES_NO_CANCEL_OPTION JOptionPane/QUESTION_MESSAGE\\n                                 nil buttons nil)))" "(Object.)" "(Object. \\"yes\\")" "(class (list \\"test\\"))" "(cast Object (list \\"test\\"))" "(cast Object (list \\"test\\" \\"test\\"))" "(defn option-dialog [question & buttons]\\n  (let [buttons (if (nil? buttons)\\n                  (cast Object (list \\"Yes\\" \\"No\\" \\"Cancel\\")\\n                  (cast Object buttons)))]\\n  (JOptionPane/showOptionDialog (JFrame. \\"Hello Frame\\") question \\"test\\"\\n                                JOptionPane/YES_NO_CANCEL_OPTION JOptionPane/QUESTION_MESSAGE\\n                                 nil buttons nil)))" "(option-dialog \\"test?\\")" "(defn option-dialog [question & buttons]\\n  (let [buttons (if (nil? buttons)\\n                  (cast Object (list \\"Yes\\" \\"No\\" \\"Cancel\\")\\n                  (cast Object (list buttons))))]\\n  (JOptionPane/showOptionDialog (JFrame. \\"Hello Frame\\") question \\"test\\"\\n                                JOptionPane/YES_NO_CANCEL_OPTION JOptionPane/QUESTION_MESSAGE\\n                                 nil buttons nil)))" "(option-dialog \\"test?\\")" "(defn option-dialog [question & buttons]\\n  (let [buttons (if (nil? buttons)\\n                  (cast Object (list \\"Yes\\" \\"No\\" \\"Cancel\\"))\\n                  (cast Object  buttons))]\\n  (JOptionPane/showOptionDialog (JFrame. \\"Hello Frame\\") question \\"test\\"\\n                                JOptionPane/YES_NO_CANCEL_OPTION JOptionPane/QUESTION_MESSAGE\\n                                 nil buttons nil)))" "(option-dialog \\"test?\\")" "(cast Object (list \\"test\\" \\"test\\"))" "(defn option-dialog [question & buttons]\\n  (let [buttons (if (nil? buttons)\\n                  (cast Object (list \\"Yes\\" \\"No\\" \\"Cancel\\"))\\n                  (cast Object  (list buttons)))]\\n  (JOptionPane/showOptionDialog (JFrame. \\"Hello Frame\\") question \\"test\\"\\n                                JOptionPane/YES_NO_CANCEL_OPTION JOptionPane/QUESTION_MESSAGE\\n                                 nil buttons nil)))" "(cast Object (list \\"test\\" \\"test\\"))" "(option-dialog \\"test?\\")" "(defn option-dialog [question & buttons]\\n  (let [buttons  (cast Object (list \\"Yes\\" \\"No\\" \\"Cancel\\"))]\\n  (JOptionPane/showOptionDialog (JFrame. \\"Hello Frame\\") question \\"test\\"\\n                                JOptionPane/YES_NO_CANCEL_OPTION JOptionPane/QUESTION_MESSAGE\\n                                 nil buttons nil)))" "(option-dialog \\"test?\\")" "(defn option-dialog [question ]\\n  (JOptionPane/showOptionDialog (JFrame. \\"Hello Frame\\") question \\"test\\"\\n                                JOptionPane/YES_NO_CANCEL_OPTION JOptionPane/QUESTION_MESSAGE\\n                                 nil nil nil))" "(defn option-dialog [question ]\\n  (JOptionPane/showOptionDialog (JFrame. \\"Hello Frame\\") question \\"test\\"\\n                                JOptionPane/YES_NO_CANCEL_OPTION JOptionPane/QUESTION_MESSAGE\\n                                nil nil nil))" "(option-dialog \\"test?\\")" "(defn option-dialog [question ]\\n  (JOptionPane/showOptionDialog (JFrame.) question \\"Select an Option.\\"\\n                                JOptionPane/YES_NO_CANCEL_OPTION JOptionPane/QUESTION_MESSAGE\\n                                nil nil nil))" "(option-dialog \\"test?\\")" "(in-ns 'tgaa.algo.core)" "(run-as-app)" "(option-dialog \\"test?\\")" "(run-as-app)" " (gui/option-dialog \\"Process another image?\\")" "(run-as-app)" " (gui/option-dialog \\"Process another image?\\")" "(run-as-app)" "(+ 1 1)" "(run-animation)" "(run-as-app)" "(+ 1 1)" "(run-as-app)" "(+ 1 1)" "(run-as-app)" "(viz/animate-algo)" "(repeatedly (viz/animate-algo))" "(viz/animate-algo)" "(show-results)" "(run-animation)" "  (loop []\\r\\n    (if (p(not\= (w (gui/option-dialog \\"Run animation?\\") 0)\\r\\n      nil\\r\\n    (viz/show-val-end-pnts)))))" "  (loop []\\r\\n    (if (not\= (w (gui/option-dialog \\"Run animation?\\") 0))\\r\\n      nil\\r\\n    (viz/show-val-end-pnts)))" "  (loop []\\r\\n    (if (not\= (gui/option-dialog \\"Run animation?\\") 0)\\r\\n      nil\\r\\n    (viz/show-val-end-pnts)))" "  (loop []\\n    (let [res (gui/option-dialog \\"Run animation?\\")]\\r\\n    (if (not\= res 0)\\r\\n      nil\\r\\n    (viz/show-val-end-pnts))))" "(promise)" "(def x (promise))" "x" "(if  (\= (viz/show-val-end-pnts) 0)\\n  (deliver x 0))" "x" "(gui/option-dialog \\"Show Results?\\")" "(if  (\= (gui/option-dialog \\"Show Results?\\") 0)\\n  (deliver x 0))" "x" "(if  (\= (gui/option-dialog \\"Show Results?\\") 0)\\n  (deliver x 0))" "x" "@seliver" "@x" "(defn run-animation [] \\r\\n  (loop [x (promise)]\\r\\n    (let [(delver x (gui/option-dialog \\"Run animation?\\") )]\\r\\n    (if (not\= @x 0)\\r\\n      nil\\r\\n    (viz/animate-algo)))))" "(defn run-animation [] \\r\\n  (loop [x (promise)]\\r\\n    (let [_ (deliver x (gui/option-dialog \\"Run animation?\\"))]\\r\\n    (if (not\= @x 0)\\r\\n      nil\\r\\n    (viz/animate-algo)))))" "(run-animation)" "(+1 1)" "(defn run-animation [] \\r\\n    (if (\= (gui/option-dialog \\"Run animation?\\") 0 )\\r\\n    (viz/animate-algo)))" "(run-animation)" "(defn get-sample-image []\\r\\n        (image/get-image \\r\\n          (str (gui/sys-view-ref \\"Select sample image (manual)\\" \:file))))\\r\\n\\r\\n(defn get-reference-image []\\r\\n        (image/get-image \\r\\n          (str (gui/sys-view-ref \\"Select reference image (automation)\\" \:file))))\\r\\n\\r\\n(defn perform-dice []\\r\\n  (let [sample-image (get-sample-image)\\r\\n        reference-image (get-reference-image)]\\r\\n    )" "(defn get-sample-image []\\r\\n        (image/get-image \\r\\n          (str (gui/sys-view-ref \\"Select sample image (manual)\\" \:file))))\\r\\n\\r\\n(defn get-reference-image []\\r\\n        (image/get-image \\r\\n          (str (gui/sys-view-ref \\"Select reference image (automation)\\" \:file))))\\r\\n\\r\\n(defn perform-dice []\\r\\n  (let [sample-image (get-sample-image)\\r\\n        reference-image (get-reference-image)]\\r\\n    ))" "(defn get-sample-image []\\r\\n  (image/get-image \\r\\n    (str (gui/sys-view-ref \\"Select sample image (manual)\\" \:file))))\\r\\n\\r\\n(defn get-reference-image []\\r\\n  (image/get-image \\r\\n    (str (gui/sys-view-ref \\"Select reference image (automation)\\" \:file))))\\r\\n\\r\\n(defn perform-dice []\\r\\n  (let [sample-image (get-sample-image)\\r\\n        reference-image (get-reference-image)]))" "(in-ns 'tgaa.util.dice-metric-analysis)" "(perform-dice)" "(Exception. \\"test\\")" "(while [x (range 4)\\n        y (range 4)]\\n  [x y])" "(for [x (range 4)\\n      y (range 4)]\\n  [x y])" "(def t (perform-dice))" "(+ 1 1)" "(first t)" "(count t)" "(def t (perform-dice))" "(first t)" "(def t (perform-dice))" "(+ 1 1)" "(first t)" "(def t (perform-dice))" "(+ 1 1)" "(first t)" "(def t (perform-dice))" "(+ 1 1)" "(first t)" "(count (filter \#(\:intersect %) t) )" "(second t)" "(count (filter \#(\= \:intersect %) t) )" "(count (filter \#(\= \:none %) t) )" "(count (filter \#(\:intersect %) t) )" "(def t (perform-dice))" "(count (filter \#(\= \:none %) t) )" "(def t (perform-dice))" "(count (filter \#(\= \:none %) t) )" "(count (filter \#(\= \:intersect %) t) )" "(def t (perform-dice))" "(count (filter \#(\= \:none %) t) )" "(count (filter \#(\= \:intersect %) t) )" "(def t (perform-dice))" "(count (filter \#(\= \:intersect %) t) )" "java.awt.Color/yellow" " (image/get-image \\r\\n    (str (gui/sys-view-ref \\"Select reference image (automation)\\" \:file))" " (def ti (image/get-image \\r\\n    (str (gui/sys-view-ref \\"Select sample image (manual)\\" \:file))))" "(image/pix-value ti 10 10)" "(image/pix-value 10 10 ti)" " (shared/target-intensity (Math/abs (bit-shift-right java.awt.Color/yellow  16)))" "(def t (perform-dice))" "(count (filter \#(\= \:intersect %) t) )" "(Integer java.awt.Color/yellow)" "(Integer. java.awt.Color/yellow)" "(perform-dice)" "(def t (perform-dice))" "(+ 1 1)" "(count (filter \#(\:none %) t))" "(count (filter \#(\= \:none %) t))" "(count (filter \#(\= \:intersect %) t))" "(count (filter \#(\= \:sample-one %) t))" "(count (filter \#(\= \:sample-two %) t))" "(perform-dice)" "(def t (perform-dice))" "(count (filter \#(\= \:none %) t))" "(count (filter \#(\= \:intersect %) t))" "(count (filter \#(\= \:sample-two %) t))" "(count (filter \#(\= \:sample-one %) t))" "(def t (perform-dice))" "(count (filter \#(\= \:intersect %) t))" "(count (filter \#(\= \:none %) t))" "(count (filter \#(\= \:sample-one %) t))" "(count (filter \#(\= \:sample-two %) t))" "(perform-dice)" "(/ 13616 47277)" "(do (/ 13616 47277))" "(double 13616/47277)" "(\= test)" "(\= \:test)" "(perform-dice)" "(def t (perform-dice))" "(count (filter \#(\= \:sample-two %) t))" "(dice-metric t)" "(def t2 (perform-dice))" "(dice-metric t2)" "(first t2)" "(dice-metric [\:none])" "(dice-metric t2)" "(class t2)" "t2" "(def t2 (perform-dice))" "(dice-metric t2)" "(def t2 (perform-dice))" "(dice-metric t2)" "t2" "(def t2 (perform-dice))" "t2" "(def t2 (perform-dice))" "(in-ns 'tgaa.algo.core)" "(run-as-app)" "(+ 1 1)" "(in-ns 'tgaa.util.dice-metric-analysis)" "(def d (perform-dice))" "(dice-metric d)" "(in-ns 'tgaa.algo.core)" "(run-as-app)" "(int 3.3)" "(run-as-app)" "(in-ns 'tgaa.util.dice-metric-analysis)" "(def d (perform-dice))" "(dice-metric d)" "(in-ns 'tgaa.algo.core)" "(viz/show-all-boundry-pnts)" "(viz/show-all-boundry-pnts-cann)" "(viz/show-all-boundry-pnts)" "(max 0.9)" "(Math/round 1.2)" "(Math/round 0.5)" "(viz/show-all-boundry-pnts)" "(round 0.4)" "(Math/round (/ 4 4))" "(Math/round (double (/ 4 4)))" "(Math/round (/ 4 4.0))" "(viz/show-all-boundry-pnts)" " (viz/show-val-end-pnts)" "(viz/show-val-end-pnts))" "(run-as-app)" "(viz/show-val-end-pnts)" "(in-ns 'tgaa.util.dice-metric-analysis)" "(perform-dice)" "(def t (perform-dice))" "(dice-metric t)" "(in-ns 'tgaa.algo.core)" "(viz/show-val-end-pnts)" "(viz/show-prediction-pnts)" "(in-ns 'tgaa.util.dice-metric-analysis)" "(def t (perform-dice))" "(run-as-app)" "(in-ns 'tgaa.algo.core)" "(run-as-app)" "(derive-metric)" "(run-as-app)" "(derive-metric)" "(run-as-app)" "(derive-metric)" "(assoc {\:test 2} {\:test3 5})" "(apply assoc {\:test 2} {\:test3 5})" "(merge {\:test 2} {\:test3 5})" "(remove \:test (merge {\:test 2} {\:test3 5}))" "(dissoc \:test (merge {\:test 2} {\:test3 5}))" "(dissoc  (merge {\:test 2} {\:test3 5}) \:test)" "(derive-metric)" "(run-as-app)" "(derive-metric)" "(run-as-app)" "(derive-metric)" "(run-as-app)" "(let [BufferedImage (shared/image-ref)])" "               (process-setup)\\r\\n               (process-image)" "(viz/show-image)" "(+ 1 1)" "(viz/show-image)" "(let [BufferedImage (shared/image-ref)])" "(let [BufferedImage (shared/image-ref)\\n      x   100\\n      y    100\\n      c  (java.awt.Color.)\\n      c1 (java.awt.Color.)])" "(let [BufferedImage (shared/image-ref)\\n      x   100\\n      y    100\\n      c  (new java.awt.Color)\\n      c1 (new java.awt.Color)])" "java.awt.Color" "java.awt.Color." "(new java.awt.Color)" "(let [i(shared/image-ref)\\n      x   100\\n      y    100\\n      x-max (. i getWidth)\\n      y-max (. i getHeight)]\\n    )" "(defn flood [x y thresh graphic image]\\n  (if (and (>\= x 1) (>\= y 1)\\n           (< x (. image getWidth)) (< y (. image getHeight))\\n           (< thresh (. image getRGB x y)))\\n    (do (. i setRGB x y (Color/yellow))\\n      (flood x (- y 1) thesh graphic image)\\n      (flood x (+ y 1) thesh graphic image)\\n      (flood (- x 1) y thesh graphic image)\\n      (flood (+ x 1) y thesh graphic image))))" "(defn flood [x y thresh graphic image]\\n  (if (and (>\= x 1) (>\= y 1)\\n           (< x (. image getWidth)) (< y (. image getHeight))\\n           (< thresh (. image getRGB x y)))\\n    (do (. image setRGB x y (Color/yellow))\\n      (flood x (- y 1) thesh graphic image)\\n      (flood x (+ y 1) thesh graphic image)\\n      (flood (- x 1) y thesh graphic image)\\n      (flood (+ x 1) y thesh graphic image))))" "(defn flood [x y thresh graphic image]\\n  (if (and (>\= x 1) (>\= y 1)\\n           (< x (. image getWidth)) (< y (. image getHeight))\\n           (< thresh (. image getRGB x y)))\\n    (do (. image setRGB x y (Color/yellow))\\n      (flood x (- y 1) thresh graphic image)\\n      (flood x (+ y 1) thresh graphic image)\\n      (flood (- x 1) y thresh graphic image)\\n      (flood (+ x 1) y thresh graphic image))))" "java.awt.Color" "(def i (tgaa.util.flood-fill/flood 100 100 100 (shared/image-loc)))" "(def i (tgaa.util.flood-fill/flood 100 100 100 (shared/image-ref))" "(defn flood \\r\\n  ([x y thresh graphic image]\\r\\n  (do (if (and (>\= x 1) (>\= y 1)\\r\\n           (< x (. image getWidth)) (< y (. image getHeight))\\r\\n           (< thresh (. image getRGB x y)))\\r\\n    (do (. image setRGB x y (java.awt.Color/yellow))\\r\\n      (flood x (- y 1) thresh graphic image)\\r\\n      (flood x (+ y 1) thresh graphic image)\\r\\n      (flood (- x 1) y thresh graphic image)\\r\\n      (flood (+ x 1) y thresh graphic image)))\\r\\n    [image graphic]))\\r\\n  ([x y thresh image]\\r\\n         (let [cpy-image (mikera.image.core/copy image)]\\r\\n     (flood x y thresh (. cpy-image createGraphics) cpy-image))))" "(def i (tgaa.util.flood-fill/flood 100 100 100 (shared/image-ref))" "(defn flood \\r\\n  ([x y thresh graphic image]\\r\\n    (if (and (>\= x 1) (>\= y 1)\\r\\n             (< x (. image getWidth)) (< y (. image getHeight))\\r\\n             (< thresh (. image getRGB x y))))\\r\\n    (do (. image setRGB x y (java.awt.Color/yellow))\\r\\n      (flood x (- y 1) thresh graphic image)\\r\\n      (flood x (+ y 1) thresh graphic image)\\r\\n      (flood (- x 1) y thresh graphic image)\\r\\n      (flood (+ x 1) y thresh graphic image))\\r\\n    [image graphic])\\r\\n  ([x y thresh image]\\r\\n    (let [cpy-image (mikera.image.core/copy image)]\\r\\n      (flood x y thresh (. cpy-image createGraphics) cpy-image))))" "(defn flood \\r\\n  ([x y thresh graphic image]\\r\\n    (if (and (>\= x 1) (>\= y 1)\\r\\n             (< x (. image getWidth)) (< y (. image getHeight))\\r\\n             (< thresh (. image getRGB x y)))\\r\\n    (do (. image setRGB x y (java.awt.Color/yellow))\\r\\n      (flood x (- y 1) thresh graphic image)\\r\\n      (flood x (+ y 1) thresh graphic image)\\r\\n      (flood (- x 1) y thresh graphic image)\\r\\n      (flood (+ x 1) y thresh graphic image))\\r\\n    [image graphic]))\\r\\n  ([x y thresh image]\\r\\n    (let [cpy-image (mikera.image.core/copy image)]\\r\\n      (flood x y thresh (. cpy-image createGraphics) cpy-image))))" "(def i (tgaa.util.flood-fill/flood 100 100 100 (shared/image-ref))" "(let [cpy-image (mikera.image.core/copy (shared/image-ref))]\\r\\n      (flood x y thresh (. cpy-image createGraphics) cpy-image))" "(let [cpy-image (mikera.image.core/copy (shared/image-ref))]\\r\\n      (flood 100 100 100 (. cpy-image createGraphics) cpy-image))" "(def i (let [cpy-image (mikera.image.core/copy (shared/image-ref))]\\r\\n      (flood 100 100 100 (. cpy-image createGraphics) cpy-image)))" "(mikera.image.core/show i)" "(mikera.image.core/show (first i))" "(def i (let [cpy-image (mikera.image.core/copy (shared/image-ref))]\\r\\n      (flood 200 200 200 (. cpy-image createGraphics) cpy-image)))" "(+ 2 1)" "(mikera.image.core/show (first i))" "(. (shared/image-ref) getRGB 100 100\\n  )" "(. (shared/image-gry-ref) getRGB 100 100)" "(. (shared/image-ref) getRGB 100 100\\n  )" "(def i (let [cpy-image (mikera.image.core/copy (shared/image-ref))]\\r\\n      (flood 100 100  -14869319 (. cpy-image createGraphics) cpy-image)))" "(< -14869219 (. (shared/image-ref) getRGB 100 100))" "(< -14869319 (. (shared/image-ref) getRGB 100 100))" "(def i (let [cpy-image (mikera.image.core/copy (shared/image-ref))]\\r\\n      (flood 100 100  -14869319 (. cpy-image createGraphics) cpy-image)))" "(class (. image getRGB x y))" "(class (. (shared/image-ref) getRGB x y))" "(class (. (shared/image-ref) getRGB 10 10))" "(def i (let [cpy-image (mikera.image.core/copy (shared/image-ref))]\\r\\n      (flood 100 100  -14869319 (. cpy-image createGraphics) cpy-image)))" "(defn flood \\r\\n  ([x y thresh graphic image]\\r\\n    (if (and (>\= x 1) (>\= y 1)\\r\\n             (< x (. image getWidth)) (< y (. image getHeight))\\r\\n             (< thresh (. image getRGB x y)))\\r\\n    (do (. image setRGB x y java.awt.Color/yellow)\\r\\n      (flood x (- y 1) thresh graphic image)\\r\\n      (flood x (+ y 1) thresh graphic image)\\r\\n      (flood (- x 1) y thresh graphic image)\\r\\n      (flood (+ x 1) y thresh graphic image))\\r\\n    [image graphic]))\\r\\n  ([x y thresh image]\\r\\n    (let [cpy-image (mikera.image.core/copy image)]\\r\\n      (flood x y thresh (. cpy-image createGraphics) cpy-image))))" "(def i (let [cpy-image (mikera.image.core/copy (shared/image-ref))]\\r\\n      (flood 100 100  -14869319 (. cpy-image createGraphics) cpy-image)))" "java.awt.Color" "java.awt.Color/yellow" "(Integer java.awt.Color/yellow)" "(Integer. java.awt.Color/yellow)" "(int java.awt.Color/yellow)" "(defn flood \\r\\n  ([x y thresh graphic image]\\r\\n    (if (and (>\= x 1) (>\= y 1)\\r\\n             (< x (. image getWidth)) (< y (. image getHeight))\\r\\n             (< thresh (. image getRGB x y)))\\r\\n    (do (. image setRGB x y 100)\\r\\n      (flood x (- y 1) thresh graphic image)\\r\\n      (flood x (+ y 1) thresh graphic image)\\r\\n      (flood (- x 1) y thresh graphic image)\\r\\n      (flood (+ x 1) y thresh graphic image))\\r\\n    [image graphic]))\\r\\n  ([x y thresh image]\\r\\n    (let [cpy-image (mikera.image.core/copy image)]\\r\\n      (flood x y thresh (. cpy-image createGraphics) cpy-image))))" "(def i (let [cpy-image (mikera.image.core/copy (shared/image-ref))]\\r\\n      (flood 100 100  -14869319 (. cpy-image createGraphics) cpy-image)))" "(loop [points [[x y]]]\\n  (if (empty? points)\\n    [image graphic]\\n    (let [ref-pnt (first points)\\n          pnt1 (< thresh (. (tgaa.struct.image/pix-value  x (- y 1) image)))\\r\\n          pnt2 (flood x (+ y 1) thresh graphic image)\\r\\n          pnt3 (flood (- x 1) y thresh graphic image)\\r\\n          pnt4 (flood (+ x 1) y thresh graphic image)) ]\\n      (if" "(tgaa.struct.image/pix-value 1000 1000 (shared/image-ref))" "(if (tgaa.struct.image/pix-value 1000 1000 (shared/image-ref)) true false)" "(defn safe-rgb\\r\\n  ([x y image]\\r\\n  (if (and (>\= x 1) (>\= y 1)\\r\\n           (< x (. image getWidth)) (< y (. image getHeight)))\\r\\n    (< thresh (. image getRGB x y))))\\r\\n  ([x y value image]\\r\\n  (if (and (>\= x 1) (>\= y 1)\\r\\n           (< x (. image getWidth)) (< y (. image getHeight)))\\r\\n    (< thresh (. image setRGB x y value)))))" "(defn safe-rgb\\r\\n  ([x y image]\\r\\n  (if (and (>\= x 1) (>\= y 1)\\r\\n           (< x (. image getWidth)) (< y (. image getHeight)))\\r\\n    (< thresh (. image getRGB x y))))\\r\\n  ([x y value image]\\r\\n  (if (and (>\= x 1) (>\= y 1)\\r\\n           (< x (. image getWidth)) (< y (. image getHeight)))\\r\\n    (. image setRGB x y value))))" "(defn safe-rgb\\r\\n  ([x y image]\\r\\n  (if (and (>\= x 1) (>\= y 1)\\r\\n           (< x (. image getWidth)) (< y (. image getHeight)))\\r\\n    (. image getRGB x y)))\\r\\n  ([x y value image]\\r\\n  (if (and (>\= x 1) (>\= y 1)\\r\\n           (< x (. image getWidth)) (< y (. image getHeight)))\\r\\n    (. image setRGB x y value))))" "(loop [points [[x y]]]\\n  (if (empty? points)\\n    [image graphic]\\n    (let [ref-pnt (first points)\\n          new-pnts (map \#((let [val (safe-rgb % image)] (if (nil? val) nil ) [[x (- y 1)] [ x (+ y 1)][(- x 1) y ][(+ x 1) y ] ]\\n          (rest \\n            (< thresh (. (tgaa.struct.image/pix-value  x (- y 1) image)))" "(< nil 10)" "(loop [points [[x y]]]\\n  (if (empty? points)\\n    [image graphic]\\n    (let [ref-pnt (first points)\\n          new-pnts (map \#((let [val (safe-rgb % image)] (if  val) nil ) [[x (- y 1)] [ x (+ y 1)][(- x 1) y ][(+ x 1) y ] ]\\n          (rest \\n            (< thresh (. (tgaa.struct.image/pix-value  x (- y 1) image)))" "   (process-setup)" "(process-image)" "(run-animation)" "(derive-metric)" "(viz/show-eval-paths)" "(run-as-app)" "(viz/show-eval-paths)" "(derive-metric)" "(run-as-app)" "(derive-metric)" "(viz/show-eval-paths)" "(derive-metric)" "(run-as-app)" "(viz/show-eval-paths)" "(derive-metric)" "(run-as-app)" "(viz/show-eval-paths)" "(derive-metric)" "(run-as-app)" "(viz/show-eval-paths)" "(derive-metric)" "(run-as-app)" "(viz/show-eval-paths)" "(run-as-app)" "(viz/show-eval-paths)" "(derive-metric)" "(viz/show-eval-paths-result)" "(derive-metric)" "java.awt.Color" "java.awt.Color/white" "(derive-metric)" "(. (shared/image-ref) setRGB 10 10 java.awt.Color/white)" "java.awt.Color/white" "(. java.awt.Color/white toString)" "(. java.awt.Color/white value\\n  )" "(process-setup)" "(. (shared/image-ref) getRGB 10 10)" "(derive-metric)" "(run-as-app)" "(viz/show-eval-paths-result)" "(viz/show-eval-paths-result \\"test\\")" "(nil?(shared/image-ref))" "(run-as-app)" "(derive-metric)" "(safe-rgb 10 10 (shared/image-ref))" "(let [[x-ref y-ref] [10 10]]\\n      (map \#(safe-rgb %1 %2 (shared/image-ref)) [[(dec x-ref) y-ref] [(inc x-ref) y-ref] [x-ref (dec y-ref)] [x-ref (inc y-ref)]]))" "(let [[x-ref y-ref] [10 10]]\\n      (map \#(safe-rgb (first %) (second %) (shared/image-ref)) [[(dec x-ref) y-ref] [(inc x-ref) y-ref] [x-ref (dec y-ref)] [x-ref (inc y-ref)]]))" "(let [[x-ref y-ref] [10 1]]\\n      (map \#(safe-rgb (first %) (second %) (shared/image-ref)) [[(dec x-ref) y-ref] [(inc x-ref) y-ref] [x-ref (dec y-ref)] [x-ref (inc y-ref)]]))" "(let [[x-ref y-ref] [10 1]]\\n   (filter \#(not (nil? %))   (map \#(safe-rgb (first %) (second %) (shared/image-ref)) [[(dec x-ref) y-ref] [(inc x-ref) y-ref] [x-ref (dec y-ref)] [x-ref (inc y-ref)]])))" "(let [[x-ref y-ref] [10 1]]\\n   (filter \#(not (nil? %))   \\n           (map \#(safe-rgb (first %) (second %) (shared/image-ref)) \\n                [[(dec x-ref) y-ref] [(inc x-ref) y-ref] [x-ref (dec y-ref)] [x-ref (inc y-ref)]])))" "(let [[x-ref y-ref] [10 1]]\\n   (filter \#(not (nil? %))   \\n           (map \#(vec % (safe-rgb (first %) (second %) (shared/image-ref)))\\n                [[(dec x-ref) y-ref] [(inc x-ref) y-ref] [x-ref (dec y-ref)] [x-ref (inc y-ref)]])))" "(let [[x-ref y-ref] [10 1]]\\n   (filter \#(not (nil? %))   \\n           (map \#([ % (safe-rgb (first %) (second %) (shared/image-ref))])\\n                [[(dec x-ref) y-ref] [(inc x-ref) y-ref] [x-ref (dec y-ref)] [x-ref (inc y-ref)]])))" "(let [[x-ref y-ref] [10 1]]\\n   (filter \#(not (nil? %))   \\n           (map \#(safe-rgb (first %) (second %) (shared/image-ref)) \\n                [[(dec x-ref) y-ref] [(inc x-ref) y-ref] [x-ref (dec y-ref)] [x-ref (inc y-ref)]])))" "(let [[x-ref y-ref] [10 1]]\\n   (filter \#(not (nil? %))   \\n           (map \#(vec (safe-rgb (first %) (second %) (shared/image-ref)))\\n                [[(dec x-ref) y-ref] [(inc x-ref) y-ref] [x-ref (dec y-ref)] [x-ref (inc y-ref)]])))" "(let [[x-ref y-ref] [10 1]]\\n   (filter \#(not (nil? %))   \\n           (map \#(safe-rgb (first %) (second %) (shared/image-ref)) \\n                [[(dec x-ref) y-ref] [(inc x-ref) y-ref] [x-ref (dec y-ref)] [x-ref (inc y-ref)]])))" "(let [[x-ref y-ref] [10 1]]\\n   (filter \#(not (nil? %))   \\n           (map \#(vector (safe-rgb (first %) (second %) (shared/image-ref)))\\n                [[(dec x-ref) y-ref] [(inc x-ref) y-ref] [x-ref (dec y-ref)] [x-ref (inc y-ref)]])))" "(let [[x-ref y-ref] [10 1]]\\n   (filter \#(not (nil? %))   \\n           (map \#(vector (first %) (second %) (safe-rgb (first %) (second %) (shared/image-ref)))\\n                [[(dec x-ref) y-ref] [(inc x-ref) y-ref] [x-ref (dec y-ref)] [x-ref (inc y-ref)]])))" "(let [[x-ref y-ref] [10 1]]\\n   (filter \#(not (nil? (last %)))   \\n           (map \#(vector (first %) (second %) (safe-rgb (first %) (second %) (shared/image-ref)))\\n                [[(dec x-ref) y-ref] [(inc x-ref) y-ref] [x-ref (dec y-ref)] [x-ref (inc y-ref)]])))" "(defn get-nb-pnts [x-ref y-ref image]\\n   (filter \#(not (nil? (last %)))   \\n           (map \#(vector (first %) (second %) (safe-rgb (first %) (second %) image))\\n                [[(dec x-ref) y-ref] [(inc x-ref) y-ref] [x-ref (dec y-ref)] [x-ref (inc y-ref)]])))" "(get-nb-pnts 1 1 (shared/image-ref))" "(defn get-nb-pnts [x-ref y-ref thresh image]\\n   (filter \#(not (or (nil? (last %))\\n                     (> (last %) thresh))) \\n           (map \#(vector (first %) (second %) (safe-rgb (first %) (second %) image))\\n                [[(dec x-ref) y-ref] [(inc x-ref) y-ref] [x-ref (dec y-ref)] [x-ref (inc y-ref)]])))" "\\n(let [i (shared/image-ref)\\n      g (. i getGraphics)\\n      x-in 10\\n      y-in 10\\n      thresh -100]\\n  (loop [pnts [[x-in y-in]]]\\n    (if (empty? pnts) \\n       i\\n       (let [[x y] (first pnts)\\n             _ (. i setRGB x y 1)]\\n             (recur (concat (rest pnts) (get-nb-pnts x y thresh i)))))))" "\\n(defn flood-loop [(shared/image-ref)x-in y-in thresh ]\\n  (loop [pnts [[x-in y-in]]]\\n    (if (empty? pnts) \\n       i\\n       (let [[x y] (first pnts)\\n             _ (. i setRGB x y 1)]\\n             (recur (concat (rest pnts) (get-nb-pnts x y thresh i)))))))" "\\n(defn flood-loop [ x-in y-in thresh image ]\\n  (loop [pnts [[x-in y-in]]]\\n    (if (empty? pnts) \\n       image\\n       (let [[x y] (first pnts)\\n             _ (. image setRGB x y 1)]\\n             (recur (concat (rest pnts) (get-nb-pnts x y thresh image)))))))" "(flood 10 10 10 (shared/image-ref))" "(mikera.image.core/show (flood 10 10 10 (shared/image-ref)))" "(mikera.image.core/show (first (flood 10 10 10 (shared/image-ref))))" "(mikera.image.core/show (first (flood 100 100 10 (shared/image-ref))))" "(mikera.image.core/show  (shared/image-ref))" "(mikera.image.core/show (first (flood 100 100 10 (shared/image-ref))))" "(. (shared/image-ref) getRGB 100 100)" "(mikera.image.core/show (first (flood 100 100 -8882156 (shared/image-ref))))" "(mikera.image.core/show (first (flood 100 100 -888256 (shared/image-ref))))" "(mikera.image.core/show (first (flood 100 100 -88216 (shared/image-ref))))" "(mikera.image.core/show (first (flood 100 100 -8882156 (shared/image-ref))))" "(mikera.image.core/show (first (flood 100 100 -8882066 (shared/image-ref))))" "(defn flood-loop [ x-in y-in thresh image ]\\r\\n  (loop [pnts [[x-in y-in]]]\\r\\n    (if (empty? pnts) \\r\\n       image\\r\\n       (let [[x y] (first pnts)\\r\\n             _ (. image setRGB x y 1)]\\r\\n             (recur (concat (rest pnts) (get-nb-pnts x y thresh image)))))))" "(mikera.image.core/show  (flood-loop 100 100 -8882066 (shared/image-ref)))" "(concat [[1 1]] [3 3])" "(rest [[1 1]])" "(get-nb-pnts 10 1 10 (shared/image-ref))" "(concat [[1 1]] (get-nb-pnts 10 1 10 (shared/image-ref)))" "(concat [] (get-nb-pnts 10 1 10 (shared/image-ref)))" "(defn get-nb-pnts [x-ref y-ref thresh image]\\r\\n  (filter \#(not (or (nil? (last %))\\r\\n                    (> (last %) thresh)\\r\\n                    (\=  (last %) 1))) \\r\\n          (map \#(vector (first %) (second %) (safe-rgb (first %) (second %) image))\\r\\n               [[(dec x-ref) y-ref] [(inc x-ref) y-ref] [x-ref (dec y-ref)] [x-ref (inc y-ref)]])))" "(mikera.image.core/show  (flood-loop 100 100 -8882066 (shared/image-ref)))" "(defn flood-loop [ x-in y-in thresh image ]\\r\\n  (loop [pnts [[x-in y-in]]]\\r\\n    (if (empty? pnts) \\r\\n       image\\r\\n       (let [[x y] (first pnts)\\r\\n             _ (. image setRGB x y 1)\\r\\n             _ (println(count pnts))]\\r\\n             (recur (concat (rest pnts) (get-nb-pnts x y thresh image)))))))" "(mikera.image.core/show  (flood-loop 100 100 -8882066 (shared/image-ref)))" "(defn flood-loop [ x-in y-in thresh image ]\\r\\n  (loop [pnts [[x-in y-in]]]\\r\\n    (if (empty? pnts) \\r\\n       image\\r\\n       (let [[x y] (first pnts)\\r\\n             _ (. image setRGB x y 1)\\r\\n             _ (println x \\" \\" y)]\\r\\n             (recur (concat (rest pnts) (get-nb-pnts x y thresh image)))))))" "(mikera.image.core/show  (flood-loop 100 100 -8882066 (shared/image-ref)))" "(defn flood-loop [ x-in y-in thresh image ]\\r\\n  (loop [pnts [[x-in y-in]]]\\r\\n    (if (empty? pnts) \\r\\n       image\\r\\n       (let [[x y] (first pnts)\\r\\n             _ (. image setRGB x y 1)\\r\\n             _ (println x \\" \\" y (. image getRGB x y))]\\r\\n             (recur (concat (rest pnts) (get-nb-pnts x y thresh image)))))))" "(mikera.image.core/show  (flood-loop 100 100 -8882066 (shared/image-ref)))" "(defn flood-loop [ x-in y-in thresh image ]\\r\\n  (loop [pnts [[x-in y-in]]]\\r\\n    (if (empty? pnts) \\r\\n       image\\r\\n       (let [[x y] (first pnts)\\r\\n             _ (. image setRGB x y 2)\\r\\n             _ (println x \\" \\" y (. image getRGB x y))]\\r\\n             (recur (concat (rest pnts) (get-nb-pnts x y thresh image)))))))" "(mikera.image.core/show  (flood-loop 100 100 -8882066 (shared/image-ref)))" "\\r\\n(defn get-nb-pnts [x-ref y-ref thresh image]\\r\\n  (filter \#(not (or (nil? (last %))\\r\\n                    (> (last %) thresh)\\r\\n                    (\=  (last %) -1))) \\r\\n          (map \#(vector (first %) (second %) (safe-rgb (first %) (second %) image))\\r\\n               [[(dec x-ref) y-ref] [(inc x-ref) y-ref] [x-ref (dec y-ref)] [x-ref (inc y-ref)]])))\\r\\n\\r\\n(defn flood-loop [ x-in y-in thresh image ]\\r\\n  (loop [pnts [[x-in y-in]]]\\r\\n    (if (empty? pnts) \\r\\n       image\\r\\n       (let [[x y] (first pnts)\\r\\n             _ (. image setRGB x y -1)\\r\\n             _ (println x \\" \\" y (. image getRGB x y))]\\r\\n             (recur (concat (rest pnts) (get-nb-pnts x y thresh image)))))))" "(mikera.image.core/show  (flood-loop 100 100 -8882066 (shared/image-ref)))" "(mikera.image.core/show  (flood-loop 200 100 -8882066 (shared/image-ref)))" "(defn flood-loop [ x-in y-in thresh image ]\\r\\n  (loop [pnts [[x-in y-in]]]\\r\\n    (if (empty? pnts) \\r\\n       image\\r\\n       (let [[x y] (first pnts)\\r\\n             _ (. image setRGB x y -1)]\\r\\n             (recur (concat (rest pnts) (get-nb-pnts x y thresh image)))))))" "(mikera.image.core/show  (flood-loop 200 100 -8882066 (shared/image-ref)))" "(mikera.image.core/show  (flood-loop 10 200 -8882066 (shared/image-ref)))" "(process-setup)" "(process-image)" "(+ 1 1)" "(show-results)" "(run-animation)" " (process-setup)" "(shared/image-ref)" "(. setRGB (shared/image-ref) 10 10 java.awt.Color/BLACK)" "(. (shared/image-ref) setRGB  10 10 java.awt.Color/BLACK)" "(. (shared/image-ref) setRGB  java.awt.Color/BLACK 10 10 )" "java.awt.Color" "java.awt.Color/black" "(. (shared/image-gry-ref) setRGB  java.awt.Color/BLACK 10 10 )" "(. (shared/image-ref) setRGB  java.awt.Color/BLACK 10 10 )" "(. (shared/image-ref) setRGB  0 10 10 )" "(. (shared/image-ref) getRGB  10 10 )" "(mikera.image.core/show (shared/image-ref))" "(. (shared/image-ref) setRGB  0 11 11 )" "(mikera.image.core/show (shared/image-ref))" "java.awt.Color/black" "(int java.awt.Color/black)" "java.awt.Color/black.toSring" "(. java.awt.Color/black toString\\n  )" " (process-setup)" "(. (shared/image-ref) getRGB  10 10 )" "(run-as-app)" "(derive-metric)" "(/ (* 2 6734) (+ (* 2 6734) 9961)" "(/ (* 2 6734) (+ (* 2 6734) 9961))" "(double (/ (* 2 6734) (+ (* 2 6734) 9961)))" "(derive-metric)" "(process-setup)" "(. (shared/image-ref) getRGB 178 181)" "(- -16776960 -16777216)" "(+ -16777216 256)" "(- -16777216 256)" "(derive-metric)" "(. (shared/image-ref) getRGB 208 150)" "(derive-metric)" "(run-as-app)" "(viz/show-cann-path)" "(viz/show-eval-paths)" "(viz/show-eval-paths-result)" "(derive-metric)" "java.awt.Color" "java.awt.Color/YELLOW" "(+ 1 1)" "(mikera.image.colours/extract-blue (mikera.image.core/get-pixel (shared/image-ref) 1 1))" "(mikera.image.core/get-pixel (shared/image-ref) 1 1)" "(mikera.image.colours/extract-green (mikera.image.core/get-pixel (shared/image-ref) 1 1))" "(mikera.image.colours/extract-blue (mikera.image.core/get-pixel (shared/image-ref) 1 1))" "(.(shared/image-ref) setRGB 10 10 java.awt.Color/yellow)" "(.(shared/image-ref) setRGB  java.awt.Color/yellow 10 10 )" "(. (shared/image-ref) setRGB 10 10 java.awt.Color/yellow)" "java.awt.Color/yellow" "(. (shared/image-ref) getRGB  10 10 )" "(process-setup)" "(. (shared/image-ref) getRGB  10 10 )" "(mikera.image.colours/extract-blue (mikera.image.core/get-pixel (shared/image-ref) 1 1))" "(mikera.image.colours/extract-red (mikera.image.core/get-pixel (shared/image-ref) 1 1))" "(mikera.image.colours/extract-green (mikera.image.core/get-pixel (shared/image-ref) 1 1))" "(. (shared/image-ref) getRGB  10 10 )" "(process-setup)" "(mikera.image.colours/extract-blue (mikera.image.core/get-pixel (shared/image-ref) 1 1))" "(mikera.image.colours/extract-red (mikera.image.core/get-pixel (shared/image-ref) 1 1))" "(mikera.image.colours/extract-green (mikera.image.core/get-pixel (shared/image-ref) 1 1))" "\\n(map \#(% (mikera.image.core/get-pixel (shared/image-ref) 1 1))\\n[mikera.image.colours/extract-green \\n mikera.image.colours/extract-red\\n mikera.image.colours/extract-blue])" "\\n(map \#((mikera.image.colours/extract-green %)\\n        (mikera.image.colours/extract-red %)\\n        (mikera.image.colours/extract-blue %))\\n     (mikera.image.core/get-pixel (shared/image-ref) 1 1))" "\\n(map \#((mikera.image.colours/extract-green %)\\n        (mikera.image.colours/extract-red %)\\n        (mikera.image.colours/extract-blue %))\\n     [(mikera.image.core/get-pixel (shared/image-ref) 1 1)])" "\\n(map \#([(mikera.image.colours/extract-green %)\\n        (mikera.image.colours/extract-red %)\\n        (mikera.image.colours/extract-blue %)]\\n        )\\n     [(mikera.image.core/get-pixel (shared/image-ref) 1 1)])" "\\n(let [pxl (mikera.image.core/get-pixel (shared/image-ref) 1 1)]\\n  [(mikera.image.colours/extract-green pxl)\\n           (mikera.image.colours/extract-red pxl)\\n           (mikera.image.colours/extract-blue pxl)])" "\\n(defn get-rgb-vec [image x y]\\n  (let [pxl (mikera.image.core/get-pixel (shared/image-ref) x y)]\\n  [(mikera.image.colours/extract-green pxl)\\n           (mikera.image.colours/extract-red pxl)\\n           (mikera.image.colours/extract-blue pxl)]))" "\\n(defn pxl-yellow [pxl rgb-vec]\\n  (if (and (> (first rgb-vec) 200)\\n           (>  (second rgb-vec) 200)\\n           (< (nth rgb-vec 2) 100))\\n    true\\n    false))" "(pxl-yellow (get-rgb-vec (shared/image-ref) 10 10))" "\\n(defn pxl-yellow [rgb-vec]\\n  (if (and (> (first rgb-vec) 200)\\n           (>  (second rgb-vec) 200)\\n           (< (nth rgb-vec 2) 100))\\n    true\\n    false))" "(pxl-yellow (get-rgb-vec (shared/image-ref) 10 10))" "(defn compare-color [ref]\\r\\n  (let [width-ref (image/image-width ref)\\r\\n        height-ref (image/image-height ref)\\n        out-image  (BufferedImage. width-ref  height-ref BufferedImage/TYPE_INT_RGB)]\\r\\n    (for [x (range width-ref)\\r\\n          y (range height-ref)]\\r\\n      (if (pxl-yellow (get-rgb-vec ref x y))\\n        (. out-image setRGB x y -16777216)\\n        (. out-image setRGB x y -1)))\\n    out-image))" "(defn compare-color [ref]\\r\\n  (let [width-ref (tgaa.struct.image/image-width ref)\\r\\n        height-ref (tgaa.struct.image/image-height ref)\\n        out-image  (BufferedImage. width-ref  height-ref BufferedImage/TYPE_INT_RGB)]\\r\\n    (for [x (range width-ref)\\r\\n          y (range height-ref)]\\r\\n      (if (pxl-yellow (get-rgb-vec ref x y))\\n        (. out-image setRGB x y -16777216)\\n        (. out-image setRGB x y -1)))\\n    out-image))" "(process-setup)" "(def i2 (compare-color (shared/image-ref)))" "(viz/show-image i2)" "(mikera.image.core/show i2)" "(mikera.image.core/show (shared/image-ref))" "(defn compare-color [ref]\\r\\n  (let [width-ref (tgaa.struct.image/image-width ref)\\r\\n        height-ref (tgaa.struct.image/image-height ref)\\r\\n        out-image  (BufferedImage. width-ref  height-ref BufferedImage/TYPE_INT_RGB)]\\r\\n    (for [x (range width-ref)\\r\\n          y (range height-ref)]\\r\\n      (if (pxl-yellow (get-rgb-vec ref x y))\\r\\n        (. out-image setRGB x y -1)\\r\\n        (. out-image setRGB x y -1)))\\r\\n    out-image))" "(def i2 (compare-color (shared/image-ref)))" "(viz/show-image i2)" "(mikera.image.core/show i2)" "(defn compare-color [ref]\\r\\n  (let [width-ref (tgaa.struct.image/image-width ref)\\r\\n        height-ref (tgaa.struct.image/image-height ref)\\r\\n        out-image  (mikera.image.core/copy ref)]\\r\\n    (for [x (range width-ref)\\r\\n          y (range height-ref)]\\r\\n      (if (pxl-yellow (get-rgb-vec ref x y))\\r\\n        (. out-image setRGB x y -1)\\r\\n        (. out-image setRGB x y -1)))\\r\\n    out-image))" "(def i2 (compare-color (shared/image-ref)))" "(mikera.image.core/show i2)" "(defn compare-color [ref]\\r\\n  (let [width-ref (tgaa.struct.image/image-width ref)\\r\\n        height-ref (tgaa.struct.image/image-height ref)\\r\\n        out-image  (mikera.image.core/copy ref)]\\r\\n   (doall (for [x (range width-ref)\\r\\n          y (range height-ref)]\\r\\n      (if (pxl-yellow (get-rgb-vec ref x y))\\r\\n        (. out-image setRGB x y -1)\\r\\n        (. out-image setRGB x y -1)))\\r\\n    out-image)))" "(def i2 (compare-color (shared/image-ref)))" "(defn compare-color [ref]\\r\\n  (let [width-ref (tgaa.struct.image/image-width ref)\\r\\n        height-ref (tgaa.struct.image/image-height ref)\\r\\n        out-image  (mikera.image.core/copy ref)]\\r\\n   (do (for [x (range width-ref)\\r\\n          y (range height-ref)]\\r\\n      (if (pxl-yellow (get-rgb-vec ref x y))\\r\\n        (. out-image setRGB x y -1)\\r\\n        (. out-image setRGB x y -1)))\\r\\n    out-image)))" "(def i2 (compare-color (shared/image-ref)))" "(mikera.image.core/show i2)" "(defn compare-color [ref]\\r\\n  (let [width-ref (tgaa.struct.image/image-width ref)\\r\\n        height-ref (tgaa.struct.image/image-height ref)\\r\\n        out-image  (mikera.image.core/copy ref)]\\r\\n   (doseq (for [x (range width-ref)\\r\\n          y (range height-ref)]\\r\\n      (if (pxl-yellow (get-rgb-vec ref x y))\\r\\n        (. out-image setRGB x y -1)\\r\\n        (. out-image setRGB x y -1))))\\r\\n    out-image))" "(defn compare-color [ref]\\r\\n  (let [width-ref (tgaa.struct.image/image-width ref)\\r\\n        height-ref (tgaa.struct.image/image-height ref)\\r\\n        out-image  (mikera.image.core/copy ref)]\\r\\n   (do(for [x (range width-ref)\\r\\n          y (range height-ref)]\\r\\n      (if (pxl-yellow (get-rgb-vec ref x y))\\r\\n        (. out-image setRGB x y -1)\\r\\n        (. out-image setRGB x y -1))))\\r\\n    out-image))" "(def i2 (compare-color (shared/image-ref)))" "(mikera.image.core/show i2)" "(defn compare-color [ref]\\r\\n  (let [width-ref (tgaa.struct.image/image-width ref)\\r\\n        height-ref (tgaa.struct.image/image-height ref)\\r\\n        out-image  (mikera.image.core/copy ref)]\\r\\n   (do(for [x (range width-ref)\\r\\n          y (range height-ref)]\\r\\n      (if (pxl-yellow (get-rgb-vec ref x y))\\r\\n       (do (println \\"h\\") (. out-image setRGB x y -1))\\r\\n        (. out-image setRGB x y -1))))\\r\\n    out-image))" "(def i2 (compare-color (shared/image-ref)))" "(mikera.image.core/show i2)" "(defn compare-color [ref]\\r\\n  (let [width-ref (tgaa.struct.image/image-width ref)\\r\\n        height-ref (tgaa.struct.image/image-height ref)\\r\\n        out-image  (mikera.image.core/copy ref)]\\r\\n   (for [x (range width-ref)\\r\\n          y (range height-ref)]\\r\\n      (if (pxl-yellow (get-rgb-vec ref x y))\\r\\n       (do (println \\"h\\") (. out-image setRGB x y -1))\\r\\n        (. out-image setRGB x y -1))))\\r\\n    out-image)" "(defn compare-color [ref]\\r\\n  (let [width-ref (tgaa.struct.image/image-width ref)\\r\\n        height-ref (tgaa.struct.image/image-height ref)\\r\\n        out-image  (mikera.image.core/copy ref)]\\r\\n   (for [x (range width-ref)\\r\\n          y (range height-ref)]\\r\\n      (if (pxl-yellow (get-rgb-vec ref x y))\\r\\n       (do (println \\"h\\") (. out-image setRGB x y -1))\\r\\n        (. out-image setRGB x y -1)))\\r\\n    out-image))" "(def i2 (compare-color (shared/image-ref)))" "(mikera.image.core/show i2)" "(defn compare-color [ref]\\r\\n  (let [width-ref (tgaa.struct.image/image-width ref)\\r\\n        height-ref (tgaa.struct.image/image-height ref)\\r\\n        out-image  (mikera.image.core/copy ref)]\\r\\n   (for [x (range width-ref)\\r\\n          y (range height-ref)]\\r\\n      (if (pxl-yellow (get-rgb-vec ref x y))\\r\\n       (do (println \\"h\\") (. out-image setRGB x y -1))\\r\\n       (do (println \\"h\\") (. out-image setRGB x y -1))))\\r\\n    out-image))" "(def i2 (compare-color (shared/image-ref)))" "(mikera.image.core/show i2)" "(defn compare-color [ref]\\r\\n  (let [width-ref (tgaa.struct.image/image-width ref)\\r\\n        height-ref (tgaa.struct.image/image-height ref)\\r\\n        out-image  (mikera.image.core/copy ref)]\\r\\n   (for [x (range width-ref)\\r\\n          y (range height-ref)\\n          update? (pxl-yellow (get-rgb-vec ref x y))]\\r\\n      (if  update?\\r\\n       (do (println \\"h\\") (. out-image setRGB x y -1))\\r\\n       (do (println \\"h\\") (. out-image setRGB x y -1))))\\r\\n    out-image))" "(mikera.image.core/show i2)" "(def i2 (compare-color (shared/image-ref)))" "(mikera.image.core/show i2)" "(defn compare-color [ref]\\r\\n  (let [width-ref (tgaa.struct.image/image-width ref)\\r\\n        height-ref (tgaa.struct.image/image-height ref)\\r\\n        out-image  (mikera.image.core/copy ref)]\\r\\n   (for [x (range width-ref)\\r\\n          y (range height-ref)\\n          update? (pxl-yellow (get-rgb-vec ref x y))]\\r\\n      (println x y update?))\\r\\n    out-image))" "(mikera.image.core/show i2)" "(def i2 (compare-color (shared/image-ref)))" "(defn compare-color-2 [ref]\\r\\n  (let [width-ref (tgaa.struct.image/image-width ref)\\r\\n        height-ref (tgaa.struct.image/image-height ref)\\r\\n        out-image  (mikera.image.core/copy ref)]\\r\\n   (for [x (range width-ref)\\r\\n          y (range height-ref)\\n          update? (pxl-yellow (get-rgb-vec ref x y))]\\r\\n      (println x y update?))\\r\\n    out-image))" "(def i2 (compare-color-2 (shared/image-ref)))" "(mikera.image.core/show i2)" "(defn compare-color-2 [ref]\\r\\n  (let [width-ref (tgaa.struct.image/image-width ref)\\r\\n        height-ref (tgaa.struct.image/image-height ref)\\r\\n        out-image  (mikera.image.core/copy ref)\\n        _ (println width-ref height-ref)]\\r\\n   (for [x (range width-ref)\\r\\n          y (range height-ref)]\\r\\n      (println x y (pxl-yellow (get-rgb-vec ref x y))))\\r\\n    out-image))" "(def i2 (compare-color-2 (shared/image-ref)))" "(mikera.image.core/show i2)" "(defn compare-color-2 [ref]\\r\\n  (let [width-ref (tgaa.struct.image/image-width ref)\\r\\n        height-ref (tgaa.struct.image/image-height ref)\\r\\n        out-image  (mikera.image.core/copy ref)\\n        _ (println width-ref height-ref)]\\r\\n   (for [x (range width-ref)\\r\\n          y (range height-ref)]\\r\\n      (println x y (pxl-yellow (get-rgb-vec ref x y))))))" "(def i2 (compare-color-2 (shared/image-ref)))" "(mikera.image.core/show i2)" "   (for [x  10\\r\\n         y 0(range height-ref)]\\r\\n      (println x y ))" "   (for [x  10\\r\\n         y 10]\\r\\n      (println x y ))" "   (for [x  (range 10)\\r\\n         y (range 10)]\\r\\n      (println x y ))" "(defn compare-color-2 [ref]\\r\\n  (let [width-ref (tgaa.struct.image/image-width ref)\\r\\n        height-ref (tgaa.struct.image/image-height ref)\\r\\n        out-image  (mikera.image.core/copy ref)\\n        _ (println width-ref height-ref)]\\r\\n   (do (for [x (range width-ref)\\r\\n          y (range height-ref)]\\r\\n      (println x y (pxl-yellow (get-rgb-vec ref x y)))))))" "(def i2 (compare-color-2 (shared/image-ref)))" "(+ 1 1)" "(process-image)" "(process-setup)" "(defn pxl-yellow [rgb-vec]\\r\\n  (if (and (> (first rgb-vec) 200)\\r\\n           (>  (second rgb-vec) 200)\\r\\n           (< (nth rgb-vec 2) 100))\\r\\n    true\\r\\n    false))\\r\\n\\r\\n(defn compare-color [ref]\\r\\n  (let [width-ref (tgaa.struct.image/image-width ref)\\r\\n        height-ref (tgaa.struct.image/image-height ref)\\r\\n        out-image  (mikera.image.core/copy ref)]\\r\\n    (for [x (range width-ref)\\r\\n          y (range height-ref)]\\r\\n      (if (pxl-yellow (get-rgb-vec ref x y))\\r\\n        (. out-image setRGB x y -16777216)\\r\\n        (. out-image setRGB x y -1)))\\r\\n    out-image))" "(defn get-rgb-vec [image x y]\\r\\n  (let [pxl (mikera.image.core/get-pixel (shared/image-ref) x y)]\\r\\n  [(mikera.image.colours/extract-green pxl)\\r\\n           (mikera.image.colours/extract-red pxl)\\r\\n           (mikera.image.colours/extract-blue pxl)]))" "(defn pxl-yellow [rgb-vec]\\r\\n  (if (and (> (first rgb-vec) 200)\\r\\n           (>  (second rgb-vec) 200)\\r\\n           (< (nth rgb-vec 2) 100))\\r\\n    true\\r\\n    false))" "defn compare-color [ref]\\r\\n  (let [width-ref (tgaa.struct.image/image-width ref)\\r\\n        height-ref (tgaa.struct.image/image-height ref)\\r\\n        out-image  (mikera.image.core/copy ref)]\\r\\n    (for [x (range width-ref)\\r\\n          y (range height-ref)]\\r\\n      (if (pxl-yellow (get-rgb-vec ref x y))\\r\\n        (. out-image setRGB x y -16777216)\\r\\n        (. out-image setRGB x y -1)))\\r\\n    out-image)" "(defn compare-color [ref]\\r\\n  (let [width-ref (tgaa.struct.image/image-width ref)\\r\\n        height-ref (tgaa.struct.image/image-height ref)\\r\\n        out-image  (mikera.image.core/copy ref)]\\r\\n    (for [x (range width-ref)\\r\\n          y (range height-ref)]\\r\\n      (if (pxl-yellow (get-rgb-vec ref x y))\\r\\n        (. out-image setRGB x y -16777216)\\r\\n        (. out-image setRGB x y -1)))\\r\\n    out-image))" "(def t (compare-color (shared/image-ref)))" "(mikera.image.core/show t)" "(defn compare-color [ref]\\r\\n  (let [width-ref (tgaa.struct.image/image-width ref)\\r\\n        height-ref (tgaa.struct.image/image-height ref)\\r\\n        out-image  (mikera.image.core/copy ref)]\\r\\n    (for [x (range width-ref)\\r\\n          y (range height-ref)]\\r\\n      (if (pxl-yellow (get-rgb-vec ref x y))\\r\\n        (do (. out-image setRGB x y -16777216))\\r\\n        (do (. out-image setRGB x y -1))))\\r\\n    out-image))" "(def t (compare-color (shared/image-ref)))" "(mikera.image.core/show t)" "(defn compare-color [ref]\\r\\n  (let [width-ref (tgaa.struct.image/image-width ref)\\r\\n        height-ref (tgaa.struct.image/image-height ref)\\r\\n        out-image  (mikera.image.core/copy ref)]\\r\\n    \\r\\n    (map \#(if (pxl-yellow (get-rgb-vec ref x y))\\r\\n        (. out-image setRGB x y -16777216))\\r\\n        (. out-image setRGB x y -1)\\r\\n    (for [x (range width-ref)\\r\\n          y (range height-ref)]\\r\\n      [x y]))\\r\\n    out-image))" "(defn compare-color [ref]\\r\\n  (let [width-ref (tgaa.struct.image/image-width ref)\\r\\n        height-ref (tgaa.struct.image/image-height ref)\\r\\n        out-image  (mikera.image.core/copy ref)]\\r\\n    (map \#(if (pxl-yellow (get-rgb-vec ref %1 %2))\\r\\n            (. out-image setRGB %1 %2 -16777216))\\r\\n         (. out-image setRGB %1 %2 -1)\\r\\n         (for [x (range width-ref)\\r\\n               y (range height-ref)]\\r\\n           [x y]))\\r\\n    out-image))" "(defn compare-color [ref]\\r\\n  (let [width-ref (tgaa.struct.image/image-width ref)\\r\\n        height-ref (tgaa.struct.image/image-height ref)\\r\\n        out-image  (mikera.image.core/copy ref)]\\r\\n    (map \#(if (pxl-yellow (get-rgb-vec ref %1 %2))\\r\\n            (. out-image setRGB %1 %2 -16777216)\\r\\n         (. out-image setRGB %1 %2 -1))\\r\\n         (for [x (range width-ref)\\r\\n               y (range height-ref)]\\r\\n           [x y]))\\r\\n    out-image))" "(def t (compare-color (shared/image-ref)))" "(mikera.image.core/show t)" "(defn compare-color [ref]\\r\\n  (let [width-ref (tgaa.struct.image/image-width ref)\\r\\n        height-ref (tgaa.struct.image/image-height ref)\\r\\n        out-image  (mikera.image.core/copy ref)]\\r\\n    (loop [pnt (for [x (range width-ref)\\r\\n                     y (range height-ref)] [x y])]\\n      (if (empty? pnt)\\n        out-image\\r\\n        (if (pxl-yellow (get-rgb-vec ref (first pnt) (second pnt)))\\r\\n          (. out-image setRGB (first pnt) (second pnt) -16777216)\\r\\n          (. out-image setRGB (first pnt) (second pnt) -1))))))" "(def t (compare-color (shared/image-ref)))" "(defn compare-color [ref]\\r\\n  (let [width-ref (tgaa.struct.image/image-width ref)\\r\\n        height-ref (tgaa.struct.image/image-height ref)\\r\\n        out-image  (mikera.image.core/copy ref)]\\r\\n    (loop [pnt (for [x (range width-ref)\\r\\n                     y (range height-ref)] [x y])]\\n      (if (empty? pnt)\\n        out-image\\r\\n        (do (if (pxl-yellow (get-rgb-vec ref (first pnt) (second pnt)))\\r\\n          (. out-image setRGB (first pnt) (second pnt) -16777216)\\r\\n          (. out-image setRGB (first pnt) (second pnt) -1))\\n          (rest pnt))))))" "(def t (compare-color (shared/image-ref)))" "(defn compare-color [ref]\\r\\n  (let [width-ref (tgaa.struct.image/image-width ref)\\r\\n        height-ref (tgaa.struct.image/image-height ref)\\r\\n        out-image  (mikera.image.core/copy ref)]\\r\\n    (loop [pnt (for [x (range width-ref)\\r\\n                     y (range height-ref)] [x y])]\\n      (if (empty? pnt)\\n        out-image\\r\\n         (if (pxl-yellow (get-rgb-vec ref (first pnt) (second pnt)))\\r\\n          (. out-image setRGB (first pnt) (second pnt) -16777216)\\r\\n          (. out-image setRGB (first pnt) (second pnt) -1))\\n          (rest pnt)))))" "(defn compare-color [ref]\\r\\n  (let [width-ref (tgaa.struct.image/image-width ref)\\r\\n        height-ref (tgaa.struct.image/image-height ref)\\r\\n        out-image  (mikera.image.core/copy ref)]\\r\\n    (loop [pnt (for [x (range width-ref)\\r\\n                     y (range height-ref)] [x y])]\\n      (if (empty? pnt)\\n        out-image\\r\\n         (if (pxl-yellow (get-rgb-vec ref (first (first pnt)) (first (second pnt))))\\r\\n          (. out-image setRGB (first (first pnt)) (first (second pnt)) -16777216)\\r\\n          (. out-image setRGB (first (first pnt)) (first (second pnt)) -1))\\n          (rest pnt)))))" "(defn compare-color [ref]\\r\\n  (let [width-ref (tgaa.struct.image/image-width ref)\\r\\n        height-ref (tgaa.struct.image/image-height ref)\\r\\n        out-image  (mikera.image.core/copy ref)]\\r\\n    (loop [pnt (for [x (range width-ref)\\r\\n                     y (range height-ref)] [x y])]\\n      (if (empty? pnt)\\n        out-image\\r\\n         (do (if (pxl-yellow (get-rgb-vec ref (first (first pnt)) (first (second pnt))))\\r\\n          (. out-image setRGB (first (first pnt)) (first (second pnt)) -16777216)\\r\\n          (. out-image setRGB (first (first pnt)) (first (second pnt)) -1))\\n          (rest pnt))))))" "(def t (compare-color (shared/image-ref)))" "(mikera.image.core/show t)" "(for [x (range 10)\\r\\ny (range 10)] [x y])" "(defn compare-color [ref]\\r\\n  (let [width-ref (tgaa.struct.image/image-width ref)\\r\\n        height-ref (tgaa.struct.image/image-height ref)\\r\\n        out-image  (mikera.image.core/copy ref)]\\r\\n    (loop [pnt (for [x (range width-ref)\\r\\n                     y (range height-ref)] [x y])]\\n      (if (empty? pnt)\\n        out-image\\r\\n         (do \\n           (println \\"test\\")(if (pxl-yellow (get-rgb-vec ref (first (first pnt)) (first (second pnt))))\\r\\n          (. out-image setRGB (first (first pnt)) (first (second pnt)) -16777216)\\r\\n          (. out-image setRGB (first (first pnt)) (first (second pnt)) -1))\\n          (rest pnt))))))" "(def t (compare-color (shared/image-ref)))" "(mikera.image.core/show t)" "(defn compare-color [ref]\\r\\n  (let [width-ref (tgaa.struct.image/image-width ref)\\r\\n        height-ref (tgaa.struct.image/image-height ref)\\r\\n        out-image  (mikera.image.core/copy ref)]\\r\\n    (for [x (range width-ref)\\r\\n          y (range height-ref)]\\r\\n      (if (pxl-yellow (get-rgb-vec ref x y))\\r\\n        (do (println \\"test\\") (. out-image setRGB x y -16777216))\\r\\n        (do (. out-image setRGB x y -1))))\\r\\n    out-image))" "(def t (compare-color (shared/image-ref)))" "(mikera.image.core/show t)" "(defn compare-color [ref]\\r\\n  (let [width-ref (tgaa.struct.image/image-width ref)\\r\\n        height-ref (tgaa.struct.image/image-height ref)\\r\\n        out-image  (mikera.image.core/copy ref)]\\r\\n    (seq (for [x (range width-ref)\\r\\n          y (range height-ref)]\\r\\n      (if (pxl-yellow (get-rgb-vec ref x y))\\r\\n        (do (println \\"test\\") (. out-image setRGB x y -16777216))\\r\\n        (do (. out-image setRGB x y -1))))\\r\\n    out-image)))" "(def t (compare-color (shared/image-ref)))" "(defn compare-color [ref]\\r\\n  (let [width-ref (tgaa.struct.image/image-width ref)\\r\\n        height-ref (tgaa.struct.image/image-height ref)\\r\\n        out-image  (mikera.image.core/copy ref)]\\r\\n    (for [x (range width-ref)\\r\\n          y (range height-ref)\\n          \:when (not (pxl-yellow (get-rgb-vec ref x y)))]\\r\\n      (. out-image setRGB x y -1)\\r\\n    out-image)))" "(defn compare-color [ref]\\r\\n  (let [width-ref (tgaa.struct.image/image-width ref)\\r\\n        height-ref (tgaa.struct.image/image-height ref)\\r\\n        out-image  (mikera.image.core/copy ref)]\\r\\n    (for [x (range width-ref)\\r\\n          y (range height-ref)\\n          \:when (not (pxl-yellow (get-rgb-vec ref x y)))]\\r\\n      (. out-image setRGB x y -1))\\r\\n    out-image))" "(def t (compare-color (shared/image-ref)))" "(mikera.image.core/show t)" "(defn compare-color [ref]\\r\\n  (let [out-image  (mikera.image.core/copy ref)]\\r\\n    (for [x (range (tgaa.struct.image/image-width ref))\\r\\n          y (range (tgaa.struct.image/image-height ref))\\n          \:when (not (pxl-yellow (get-rgb-vec ref x y)))]\\r\\n      (. out-image setRGB x y -1))\\r\\n    out-image))" "(def t (compare-color (shared/image-ref)))" "(mikera.image.core/show t)" "(defn compare-color [ref]\\r\\n  (let [out-image  (mikera.image.core/copy ref)]\\r\\n    (for [x (range (tgaa.struct.image/image-width ref))\\r\\n          y (range (tgaa.struct.image/image-height ref))\\n          \:when (not (pxl-yellow (get-rgb-vec ref x y)))]\\r\\n      (. out-image setRGB x y -1))\\r\\n    out-image))" "(def t (compare-color (shared/image-ref)))" "(defn compare-color [ref]\\r\\n    (for [x (range (tgaa.struct.image/image-width ref))\\r\\n          y (range (tgaa.struct.image/image-height ref))\\n          \:when (not (pxl-yellow (get-rgb-vec ref x y)))]\\r\\n      (. ref setRGB x y -1)))" "(def t (compare-color (shared/image-ref)))" "(mikera.image.core/show t)" "(mikera.image.core/show (shared/image-ref))" "(def t (compare-color (shared/image-ref)))" "(defn compare-color [ref]\\r\\n    (for [x (range (tgaa.struct.image/image-width ref))\\r\\n          y (range (tgaa.struct.image/image-height ref))\\n          \:when (not (pxl-yellow (get-rgb-vec ref x y)))]\\r\\n      (. ref setRGB x y -1)))" "(compare-color (shared/image-ref))" "(mikera.image.core/show t)" "(mikera.image.core/show (shared/image-ref))" "(defn compare-color [ref]\\r\\n   (doall (for [x (range (tgaa.struct.image/image-width ref))\\r\\n          y (range (tgaa.struct.image/image-height ref))\\n              \:when (not (pxl-yellow (get-rgb-vec ref x y)))]\\r\\n      (. ref setRGB x y -1))))" "(process-image)" "(process-setup)" "(mikera.image.core/show (shared/image-ref))" "(defn compare-color [ref]\\r\\n   (doall (for [x (range (tgaa.struct.image/image-width ref))\\r\\n          y (range (tgaa.struct.image/image-height ref))\\n              \:when (not (pxl-yellow (get-rgb-vec ref x y)))]\\r\\n      (. ref setRGB x y -1))))" "(def t2 compare-color (shared/image-ref))" "(def t2 (compare-color (shared/image-ref)))" "(mikera.image.core/show t2)" "(mikera.image.core/show (shared/image-ref))" "(process-setup)" "(mikera.image.core/show (shared/image-ref))" "(def t2 (compare-color (shared/image-ref)))" "(mikera.image.core/show (shared/image-ref))" "(tgaa.util.dice-metric-analysis/perform-dice)" "(tgaa.util.dice-metric-analysis/dice-metric (tgaa.util.dice-metric-analysis/perform-dice))" "(process-setup)" "(mikera.image.core/show (shared/image-ref))" "(def t2 (compare-color (shared/image-ref)))" "(mikera.image.core/show (shared/image-ref))" "(process-setup)" "(mikera.image.core/show (shared/image-ref))" "(def t2 (compare-color (shared/image-ref)))" "(mikera.image.core/show (shared/image-ref))" "(tgaa.util.dice-metric-analysis/dice-metric (tgaa.util.dice-metric-analysis/perform-dice))" "(def d (tgaa.util.dice-metric-analysis/perform-dice))" "(tgaa.util.dice-metric-analysis/dice-metric d)" "d" "(def d (tgaa.util.dice-metric-analysis/perform-dice))" "(tgaa.util.dice-metric-analysis/dice-metric d)" "(process-setup)" "(mikera.image.core/show (shared/image-ref))" "(def t2 (compare-color (shared/image-ref)))" "(mikera.image.core/show (shared/image-ref))" "(process-setup)" "(mikera.image.core/show (shared/image-ref))" "(def t2 (compare-color (shared/image-ref)))" "(mikera.image.core/show (shared/image-ref))" "(def d (tgaa.util.dice-metric-analysis/perform-dice))" "(tgaa.util.dice-metric-analysis/dice-metric d)" "(def d (tgaa.util.dice-metric-analysis/perform-dice))" "(tgaa.util.dice-metric-analysis/dice-metric d)" "(process-setup)" "(def t2 (compare-color (shared/image-ref)))" "(mikera.image.core/show (shared/image-ref))" "(process-setup)" "(tgaa.util.dice-metric-analysis/dice-metric)" "(run-as-app\\n  )" "(process-setup)" "(def t2 (compare-color (shared/image-ref)))" "(mikera.image.core/show (shared/image-ref))" "(process-setup)" "(mikera.image.core/show (shared/image-ref))" "(process-setup)" "(mikera.image.core/show (shared/image-ref))" "(def t2 (compare-color (shared/image-ref)))" "(mikera.image.core/show (shared/image-ref))" "(tgaa.util.dice-metric-analysis/dice-metric)" "(tgaa.util.mri-converter/get-dir)" "(tgaa.util.mri-converter/get-dir \\"image\\")" "(tgaa.util.gui/sys-view-ref \\"test\\")" "(tgaa.util.gui/sys-view-ref \\"Folder to convert images.\\")" "(defn convert-yellow-only\\n  (let [conv-folder (tgaa.util.gui/sys-folder-all-files \\"Folder to convert images.\\")\\n        target-folder (tgaa.util.gui/sys-view-ref \\"Target folder.\\")]\\n    conv-folder))" "(defn convert-yellow-only []\\n  (let [conv-files (tgaa.util.gui/sys-folder-all-files \\"Folder to convert images.\\")\\n        target-folder (tgaa.util.gui/sys-view-ref \\"Target folder.\\")]\\n    conv-files))" "(convert-yellow-only)" "(defn convert-yellow-only []\\n  (let [conv-files (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\")\\n        target-folder (tgaa.util.gui/sys-view-ref \\"Target parent folder.\\")]\\n    conv-files))" "(defn convert-yellow-only []\\n  (let [conv-files (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\")\\n        target-folder (tgaa.util.gui/sys-view-ref \\"Target parent folder.\\")]\\n        (loop [files conv-files]\\n          (if (empty? files)\\n            (println \\"complete\\")\\n            (do (printnl (first files))\\n              (rest files))))))" "(defn convert-yellow-only []\\n  (let [conv-files (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\")\\n        target-folder (tgaa.util.gui/sys-view-ref \\"Target parent folder.\\")]\\n        (loop [files conv-files]\\n          (if (empty? files)\\n            (println \\"complete\\")\\n            (do (println (first files))\\n              (rest files))))))" "(convert-yellow-only)" "(defn convert-yellow-only []\\n  (let [conv-files (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\")\\n        target-folder (tgaa.util.gui/sys-view-ref \\"Target parent folder.\\")]\\n        (loop [files conv-files]\\n          (if (empty? files)\\n            (println \\"complete\\")\\n            (do (compare-color (tgaa.struct.image/get-image (first files)))\\n              (rest files))))))" "(defn convert-yellow-only []\\n  (let [conv-files (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\")\\n        target-folder (tgaa.util.gui/sys-view-ref \\"Target parent folder.\\")]\\n        (loop [files conv-files]\\n          (if (empty? files)\\n            (println \\"complete\\")\\n            (do \\n              (mikera.image.core/save (compare-color (tgaa.struct.image/get-image (first files))) target-folder)\\n              (rest files))))))" "(convert-yellow-only)" "(defn convert-yellow-only []\\n  (let [conv-files (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\")\\n        target-folder (tgaa.util.gui/sys-view-ref \\"Target parent folder.\\")]\\n        (loop [files conv-files]\\n          (if (empty? files)\\n            (println \\"complete\\")\\n            (do \\n              (mikera.image.core/save (compare-color (tgaa.struct.image/get-image (str (first files)))) target-folder)\\n              (rest files))))))" "(convert-yellow-only)" "(defn convert-yellow-only []\\n  (let [conv-files (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\")\\n        target-folder (tgaa.util.gui/sys-view-ref \\"Target parent folder.\\")]\\n        (loop [files conv-files]\\n          (if (empty? files)\\n            (println \\"complete\\")\\n            (do \\n             (println (str (first files)))\\n              (rest files))))))" "(convert-yellow-only)" "(defn convert-yellow-only []\\n  (let [conv-files (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\")\\n        target-folder (tgaa.util.gui/sys-view-ref \\"Target parent folder.\\")]\\n        (loop [files conv-files]\\n          (if (empty? files)\\n            (println \\"complete\\")\\n            (do \\n             (println \\"here\\" (str (first files)))\\n              (rest files))))))" "(convert-yellow-only)" "(defn convert-yellow-only []\\n  (let [conv-files (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\")\\n        target-folder (tgaa.util.gui/sys-view-ref \\"Target parent folder.\\")]\\n        conv-files))" "(convert-yellow-only)" "(def as (convert-yellow-only))" "as" "(first as)" "(second as)" "(nth as 3)" "(defn convert-yellow-only []\\n  (let [conv-files (rest (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\"))\\n        target-folder (tgaa.util.gui/sys-view-ref \\"Target parent folder.\\")]\\n        (loop [files conv-files]\\n          (if (empty? files)\\n            (println \\"complete\\")\\n            (do \\n              (mikera.image.core/save (compare-color (tgaa.struct.image/get-image (first files))) target-folder)\\n              (rest files))))))" "(convert-yellow-only)" "(defn convert-yellow-only []\\n  (let [conv-files (rest (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\"))\\n        target-folder (tgaa.util.gui/sys-view-ref \\"Target parent folder.\\")]\\n        (loop [files conv-files]\\n          (if (empty? files)\\n            (println \\"complete\\")\\n            (do \\n              (mikera.image.core/save (compare-color (tgaa.struct.image/get-image (str (first files)))) target-folder)\\n              (rest files))))))" "(convert-yellow-only)" "(range 10)" "(defn convert-yellow-only []\\n  (let [conv-files (rest (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\"))\\n        target-folder (tgaa.util.gui/sys-view-ref \\"Target parent folder.\\")]\\n        (loop [files conv-files]\\n          (if (empty? files)\\n            (println \\"complete\\")\\n            (do (println \\"processing\: \\" (first files))\\n              (mikera.image.core/save (compare-color (tgaa.struct.image/get-image (str (first files)))) target-folder)\\n              (rest files))))))" "(convert-yellow-only)" "(compare-color (tgaa.struct.image/get-image \\n                 \\"C\:\\\\\\\\Users\\\\\\\\erudi\\\\\\\\Desktop\\\\\\\\Thesis End Game\\\\\\\\Sampling\\\\\\\\Student Sampling\\\\\\\\volume student\\\\\\\\STUDENT 1\\\\\\\\Archive\\\\\\\\1_1_19.jpg\\"))" "(tgaa.struct.image/get-image \\n                 \\"C\:\\\\\\\\Users\\\\\\\\erudi\\\\\\\\Desktop\\\\\\\\Thesis End Game\\\\\\\\Sampling\\\\\\\\Student Sampling\\\\\\\\volume student\\\\\\\\STUDENT 1\\\\\\\\Archive\\\\\\\\1_1_19.jpg\\")" "(process-setup)" "(shared/image-ref)" "(defn compare-color [ref]\\r\\n   (doall (for [x (range (tgaa.struct.image/image-width ref))\\r\\n          y (range (tgaa.struct.image/image-height ref))\\r\\n              \:when (not (pxl-yellow (get-rgb-vec ref x y)))]\\r\\n      (. ref setRGB x y -1))))" "(convert-yellow-only (shared/image-ref)\\n                     )" "(compare-color (shared/image-ref)\\n                     )" "(+ 1 1)" "(defn convert-yellow-only []\\n  (let [conv-files (rest (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\"))\\n        target-folder (tgaa.util.gui/sys-view-ref \\"Target parent folder.\\")]\\n        (loop [files conv-files]\\n          (if (empty? files)\\n            (println \\"complete\\")\\n            (let [conv-image (tgaa.struct.image/get-image (str (first files)))\\n                  _ (compare-color conv-image)\\n                  _ (println \\"processing\: \\" (first files))]\\n              (mikera.image.core/save conv-image  target-folder)\\n              (rest files))))))" "(convert-yellow-only)" "(defn convert-yellow-only []\\n  (let [conv-files (rest (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\"))\\n        target-folder (str (tgaa.util.gui/sys-view-ref \\"Target parent folder.\\"))\\n        _ (println target-folder)]\\n        (loop [files conv-files]\\n          (if (empty? files)\\n            (println \\"complete\\")\\n            (let [conv-image (tgaa.struct.image/get-image (str (first files)))\\n                  _ (compare-color conv-image)\\n                  _ (println \\"processing\: \\" (first files))]\\n              (mikera.image.core/save conv-image  target-folder)\\n              (rest files))))))" "(convert-yellow-only)" "(defn convert-yellow-only []\\n  (let [conv-files (rest (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\"))\\n        target-folder (str (tgaa.util.gui/sys-view-ref \\"Target parent folder.\\"))\\n        _ (println target-folder)]\\n        (loop [files conv-files]\\n          (if (empty? files)\\n            (println \\"complete\\")\\n            (let [conv-image (tgaa.struct.image/get-image (str (first files)))\\n                  _ (println conv-image)\\n                  _ (compare-color conv-image)\\n                  _ (println \\"processing\: \\" (first files))]\\n              (mikera.image.core/save conv-image  target-folder)\\n              (rest files))))))" "(convert-yellow-only)" "(defn convert-yellow-only []\\n  (let [conv-files (rest (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\"))\\n        target-folder (str (tgaa.util.gui/sys-view-ref \\"Target parent folder.\\"))\\n        _ (println target-folder)]\\n        (loop [files conv-files]\\n          (if (empty? files)\\n            (println \\"complete\\")\\n            (let [conv-image (tgaa.struct.image/get-image (str (first files)))\\n                  _ (println conv-image)\\n                  _ (compare-color conv-image)\\n                  _ (println \\"processing\: \\" (str (first files)))]\\n              (mikera.image.core/save conv-image  target-folder)\\n              (rest files))))))" "(defn convert-yellow-only []\\n  (let [conv-files (rest (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\"))\\n        target-folder (str (tgaa.util.gui/sys-view-ref \\"Target parent folder.\\"))\\n        _ (println target-folder)]\\n        (loop [files conv-files]\\n          (if (empty? files)\\n            (println \\"complete\\")\\n            (do (let [conv-image (tgaa.struct.image/get-image (str (first files)))\\n                      _ (println conv-image)\\n                      _ (compare-color conv-image)\\n                      _ (println \\"processing\: \\" (str (first files)))]\\n              (mikera.image.core/save conv-image  target-folder))\\n              (rest files))))))" "(convert-yellow-only)" "(defn convert-yellow-only []\\n  (let [conv-files (rest (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\"))\\n        target-folder (str (tgaa.util.gui/sys-view-ref \\"Target parent folder.\\"))\\n        _ (println target-folder)]\\n        (loop [files conv-files]\\n          (if (empty? files)\\n            (println \\"complete\\")\\n            (do (let [conv-image (tgaa.struct.image/get-image (str (first files)))\\n                      _ (println conv-image)\\n                      _ (compare-color conv-image)\\n                      _ (println \\"processing file \\" (count files) \\" Named \\"  (str (first files)))]\\n              (mikera.image.core/save conv-image  target-folder))\\n              (rest files))))))" "(convert-yellow-only)" "(defn convert-yellow-only []\\n  (let [conv-files (rest (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\"))\\n        target-folder (str (tgaa.util.gui/sys-view-ref \\"Target parent folder.\\"))\\n        _ (println target-folder)]\\n        (loop [files conv-files]\\n          (if (empty? files)\\n            (println \\"complete\\")\\n            (do (let [conv-image (tgaa.struct.image/get-image (str (first files)))\\n                      _ (println conv-image)\\n                      _ (compare-color conv-image)\\n                      _ (println \\"processing file \\" (count files) \\" Named \\"  (str (first files)))]\\n              (rest files)))))))" "(convert-yellow-only)" "(defn convert-yellow-only []\\n  (let [conv-files (rest (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\"))\\n        target-folder (str (tgaa.util.gui/sys-view-ref \\"Target parent folder.\\"))\\n        _ (println target-folder)]\\n        (loop [file conv-files]\\n          (if (empty? files)\\n            (println \\"complete\\")\\n            (do (let [conv-image (tgaa.struct.image/get-image (str (first file)))\\n                      _ (println conv-image)\\n                      _ (compare-color conv-image)\\n                      _ (println \\"processing file \\" (count file) \\" Named \\"  (str (first file)))]\\n              (rest file)))))))" "(defn convert-yellow-only []\\n  (let [conv-files (rest (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\"))\\n        target-folder (str (tgaa.util.gui/sys-view-ref \\"Target parent folder.\\"))\\n        _ (println target-folder)]\\n        (loop [file conv-files]\\n          (if (empty? files)\\n            (println \\"complete\\")\\n            (do (let [conv-image (tgaa.struct.image/get-image (str (first file)))\\n                      _ (println conv-image)\\n                      _ (compare-color conv-image)\\n                      _ (println \\"processing file \\" (count file) \\" Named \\"  (str (first file)))])\\n              (rest file))))))" "(defn convert-yellow-only []\\n  (let [conv-files (rest (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\"))\\n        target-folder (str (tgaa.util.gui/sys-view-ref \\"Target parent folder.\\"))\\n        _ (println target-folder)]\\n        (loop [file conv-files]\\n          (if (empty? file)\\n            (println \\"complete\\")\\n            (do (let [conv-image (tgaa.struct.image/get-image (str (first file)))\\n                      _ (println conv-image)\\n                      _ (compare-color conv-image)\\n                      _ (println \\"processing file \\" (count file) \\" Named \\"  (str (first file)))])\\n              (rest file))))))" "(convert-yellow-only)" "(def t \\n  (rest (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\")))" "t" "(rest t)" "(count t)" "(nth t 1)" "(nth t 2)" "(nth t 1)" "(nth t 0)" "(nth 1 0)" "(nth t 2)" "(defn convert-yellow-only []\\n  (let [conv-files (rest (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\"))\\n        target-folder (str (tgaa.util.gui/sys-view-ref \\"Target parent folder.\\"))\\n        _ (println target-folder)]\\n        (loop [file conv-files]\\n          (if (empty? file)\\n            (println \\"complete\\")\\n            (do (let [conv-image (tgaa.struct.image/get-image (str (first file)))\\n                      _ (println conv-image)\\n                      _ (compare-color conv-image)\\n                      _ (println \\"processing file \\" (count file) \\" Named \\"  (str (first file)))\\n                     ; _ (mikera.image.core/save conv-image  target-folder)\\n                      ])\\n              (rest file))))))" "(defn convert-yellow-only []\\n  (let [conv-files (rest (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\"))\\n        target-folder (str (tgaa.util.gui/sys-view-ref \\"Target parent folder.\\"))\\n        _ (println target-folder)]\\n        (loop [file conv-files]\\n          (if (empty? file)\\n            (println \\"complete\\")\\n            (do (let [conv-image (tgaa.struct.image/get-image (str (first file)))\\n                      _ (println conv-image)\\n                      _ (compare-color conv-image)\\n                      _ (println \\"processing file \\" (count file) \\" Named \\"  (str (first file)))\\n                      _ (mikera.image.core/save conv-image  target-folder)\\n                      ])\\n              (rest file))))))" "(convert-yellow-only)" "(defn convert-yellow-only []\\n  (let [conv-files (rest (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\"))\\n        target-folder (str (tgaa.util.gui/sys-view-ref \\"Target parent folder.\\"))\\n        _ (println target-folder)]\\n        (loop [file conv-files]\\n          (if (empty? file)\\n            (println \\"complete\\")\\n            (do (let [conv-image (tgaa.struct.image/get-image (str (first file)))\\n                      _ (println conv-image)\\n                      _ (compare-color conv-image)\\n                      _ (println \\"processing file \\" (count file) \\" Named \\"  (str (first file)))\\n                      _ (mikera.image.core/save conv-image  target-folder)\\n                      ])\\n              (recur (rest file)))))))" "(convert-yellow-only)" "(defn convert-yellow-only []\\n  (let [conv-files (rest (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\"))\\n        target-folder (str (tgaa.util.gui/sys-view-ref \\"Target parent folder.\\"))\\n        _ (println target-folder)]\\n        (loop [file conv-files]\\n          (if (empty? file)\\n            (println \\"complete\\")\\n            (do (let [conv-image (tgaa.struct.image/get-image (str (first file)))\\n                      _ (println conv-image)\\n                      _ (compare-color conv-image)\\n                      _ (println \\"processing file \\" (count file) \\" Named \\"  (str (first file)))\\n                     ; _ (mikera.image.core/save conv-image  target-folder)\\n                      ])\\n              (recur (rest file)))))))" "(convert-yellow-only)" "(defn convert-yellow-only []\\n  (let [conv-files (rest (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\"))\\n        target-folder (str (tgaa.util.gui/sys-view-ref \\"Target parent folder.\\"))\\n        _ (println target-folder)]\\n        (loop [file conv-files]\\n          (if (empty? file)\\n            (println \\"complete\\")\\n            (do (let [conv-image (tgaa.struct.image/get-image (str (first file)))\\n                      _ (println conv-image)\\n                     ; _ (compare-color conv-image)\\n                      _ (println \\"processing file \\" (count file) \\" Named \\"  (str (first file)))\\n                     ; _ (mikera.image.core/save conv-image  target-folder)\\n                      ])\\n              (recur (rest file)))))))" "(convert-yellow-only)" "(defn convert-yellow-only []\\n  (let [conv-files (rest (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\"))\\n        target-folder (str (tgaa.util.gui/sys-view-ref \\"Target parent folder.\\"))\\n        _ (println target-folder)]\\n        (loop [file conv-files]\\n          (if (empty? file)\\n            (println \\"complete\\")\\n            (do (let [conv-image (tgaa.struct.image/get-image (str (first file)))\\n                      _ (println conv-image)\\n                      _ (compare-color conv-image)\\n                      _ (println \\"processing file \\" (count file) \\" Named \\"  (str (first file)))\\n                     ; _ (mikera.image.core/save conv-image  target-folder)\\n                      ])\\n              (recur (rest file)))))))" "(convert-yellow-only)" "(defn convert-yellow-only []\\n  (let [conv-files (rest (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\"))\\n        target-folder (str (tgaa.util.gui/sys-view-ref \\"Target parent folder.\\"))\\n        _ (println target-folder)]\\n        (loop [file conv-files]\\n          (if (empty? file)\\n            (println \\"complete\\")\\n            (do (let [conv-image (tgaa.struct.image/get-image (str (first file)))\\n                      _ (println conv-image)\\n                      _ (compare-color conv-image)\\n                      _ (println \\"processing file \\" (count file) \\" Named \\"  (str (first file)))\\n                      _ (mikera.image.core/save conv-image  target-folder)\\n                      ])\\n              (recur (rest file)))))))" "(convert-yellow-only)" "(defn convert-yellow-only []\\n  (let [conv-files (rest (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\"))\\n        target-folder (str (tgaa.util.gui/sys-view-ref \\"Target parent folder.\\"))\\n        _ (println target-folder)]\\n        (loop [file conv-files]\\n          (if (empty? file)\\n            (println \\"complete\\")\\n            (let [conv-image (tgaa.struct.image/get-image (str (first file)))\\n                  _ (println conv-image)\\n                  _ (compare-color conv-image)\\n                  _ (println \\"processing file \\" (count file) \\" Named \\"  (str (first file)))\\n                  _ (mikera.image.core/save conv-image  target-folder)\\n                  ]\\n              (recur (rest file)))))))" "(convert-yellow-only)" "(defn convert-yellow-only []\\n  (let [conv-files (rest (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\"))\\n        target-folder (str (tgaa.util.gui/sys-view-ref \\"Target parent folder.\\"))\\n        _ (println target-folder)]\\n        (loop [file conv-files]\\n          (if (empty? file)\\n            (println \\"complete\\")\\n            (let [conv-image (tgaa.struct.image/get-image (str (first file)))\\n                  _ (println conv-image)\\n                  _ (compare-color conv-image)\\n                  _ (println \\"processing file \\" (count file) \\" Named \\"  (str (first file)))\\n                  _ (mikera.image.core/show conv-image)\\n                  _ (mikera.image.core/save conv-image  target-folder)\\n                  ]\\n              (recur (rest file)))))))" "(convert-yellow-only)" "(defn convert-yellow-only []\\n  (let [conv-files (rest (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\"))\\n        target-folder (str (tgaa.util.gui/sys-view-ref \\"Target parent folder.\\"))\\n        _ (println target-folder)]\\n        (loop [file conv-files]\\n          (if (empty? file)\\n            (println \\"complete\\")\\n            (let [conv-image (tgaa.struct.image/get-image (str (first file)))\\n                  _ (println conv-image)\\n                  _ (compare-color conv-image)\\n                  _ (println \\"processing file \\" (count file) \\" Named \\"  (str (first file)))\\n                  _ (mikera.image.core/show conv-image)\\n                  ;_ (mikera.image.core/save conv-image  target-folder)\\n                  ]\\n              (recur (rest file)))))))" "(convert-yellow-only)" "(defn convert-yellow-only []\\n  (let [conv-files (rest (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\"))\\n        target-folder (str (tgaa.util.gui/sys-view-ref \\"Target parent folder.\\"))\\n        _ (println target-folder)]\\n            (let [conv-image (tgaa.struct.image/get-image (str (first file)))\\n                  _ (println conv-image)\\n                  _ (compare-color conv-image)\\n                  _ (println \\"processing file \\" (count file) \\" Named \\"  (str (first file)))\\n                  _ (mikera.image.core/show conv-image)\\n                  _ (mikera.image.core/save conv-image  target-folder)\\n                  ])))" "(defn convert-yellow-only []\\n  (let [conv-files (rest (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\"))\\n        target-folder (str (tgaa.util.gui/sys-view-ref \\"Target parent folder.\\"))\\n        _ (println target-folder)]\\n            (let [conv-image (tgaa.struct.image/get-image (str (first file)))\\n                  _ (println conv-image)\\n                  _ (compare-color conv-image)\\n                  _ (mikera.image.core/show conv-image)\\n                  _ (mikera.image.core/save conv-image  target-folder)\\n                  ])))" "(defn convert-yellow-only []\\n  (let [conv-files (rest (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\"))\\n        target-folder (str (tgaa.util.gui/sys-view-ref \\"Target parent folder.\\"))\\n        _ (println target-folder)]\\n            (let [conv-image (tgaa.struct.image/get-image (str (first conv-files)))\\n                  _ (println conv-image)\\n                  _ (compare-color conv-image)\\n                  _ (mikera.image.core/show conv-image)\\n                  _ (mikera.image.core/save conv-image  target-folder)\\n                  ])))" "(convert-yellow-only)" "(defn convert-yellow-only []\\n  (let [conv-files (rest (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\"))\\n        target-folder (str (tgaa.util.gui/sys-view-ref \\"Target parent folder.\\"))\\n        _ (println target-folder)]\\n            (let [conv-image (tgaa.struct.image/get-image (str (first conv-files)))\\n                  _ (println conv-image)\\n                  _ (compare-color conv-image)\\n                  _ (mikera.image.core/show conv-image)\\n                 ; _ (mikera.image.core/save conv-image  target-folder)\\n                  ])))" "(convert-yellow-only)" "(defn convert-yellow-only []\\n  (let [conv-files (rest (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\"))\\n        target-folder (str (tgaa.util.gui/sys-view-ref \\"Target parent folder.\\"))\\n        _ (println target-folder)]\\n            (let [conv-image (tgaa.struct.image/get-image (str (first conv-files)))\\n                  _ (println conv-image)\\n                  _ (compare-color conv-image)\\n                  _ (mikera.image.core/show conv-image)\\n                  _ (mikera.image.core/save conv-image  target-folder \:quality 1.0)\\n                  ])))" "(convert-yellow-only)" "(defn convert-yellow-only []\\n  (let [conv-files (rest (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\"))\\n        target-folder (str (tgaa.util.gui/sys-view-ref \\"Target parent folder.\\"))\\n        _ (println target-folder)]\\n            (let [conv-image (tgaa.struct.image/get-image (str (first conv-files)))\\n                  _ (println conv-image)\\n                  _ (compare-color conv-image)\\n                  _ (mikera.image.core/show conv-image)\\n                  _ (mikera.image.core/write conv-image  target-folder \\"jpg\\")\\n                  ])))" "(convert-yellow-only)" "(defn convert-yellow-only []\\n  (let [conv-files (rest (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\"))\\n        target-folder (str (tgaa.util.gui/sys-view-ref \\"Target parent folder.\\"))\\n        _ (println target-folder)]\\n            (let [conv-image (tgaa.struct.image/get-image (str (first conv-files)))\\n                  _ (println conv-image)\\n                  _ (compare-color conv-image)\\n                  _ (mikera.image.core/write conv-image  target-folder \\"jpg\\")\\n                  ])))" "(convert-yellow-only)" "(defn convert-yellow-only []\\n  (let [conv-files (rest (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\"))\\n        target-folder (str (tgaa.util.gui/sys-view-ref \\"Target parent folder.\\"))\\n        _ (println target-folder)]\\n            (let [full-path (str (first conv-files))\\n                  f-name (split \#\\"\\\\\\\\\\" last)\\n                  _ (println (str target-folder \\"\\\\\\\\\\" f-name) )\\n                  conv-image (tgaa.struct.image/get-image )\\n                  _ (println conv-image)\\n                  _ (compare-color conv-image)\\n                  _ (mikera.image.core/write conv-image  (str target-folder \\"\\\\\\\\\\" f-name) \\"jpg\\")\\n                  ])))" "(defn convert-yellow-only []\\n  (let [conv-files (rest (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\"))\\n        target-folder (str (tgaa.util.gui/sys-view-ref \\"Target parent folder.\\"))\\n        _ (println target-folder)]\\n            (let [full-path (str (first conv-files))\\n                  f-name (clojure.string/split \#\\"\\\\\\\\\\" last)\\n                  _ (println (str target-folder \\"\\\\\\\\\\" f-name) )\\n                  conv-image (tgaa.struct.image/get-image )\\n                  _ (println conv-image)\\n                  _ (compare-color conv-image)\\n                  _ (mikera.image.core/write conv-image  (str target-folder \\"\\\\\\\\\\" f-name) \\"jpg\\")\\n                  ])))" "(convert-yellow-only)" "(clojure.string/split \#\\"\\\\\\\\\\" \\"C\:\\\\\\\\test\\\\\\\\stuf.text\\")" "(clojure.string/split \#\\".\\" \\"C\:\\\\\\\\test\\\\\\\\stuf.text\\")" "(clojure.string/split \#\\"\\\\.\\" \\"C\:\\\\\\\\test\\\\\\\\stuf.text\\")" "(clojure.string/split \\"C\:\\\\\\\\test\\\\\\\\stuf.text\\" \#\\"\\\\.\\" )" "(clojure.string/split \\"C\:\\\\\\\\test\\\\\\\\stuf.text\\" \#\\"\\\\\\\\\\" )" "(defn convert-yellow-only []\\n  (let [conv-files (rest (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\"))\\n        target-folder (str (tgaa.util.gui/sys-view-ref \\"Target parent folder.\\"))\\n        _ (println target-folder)]\\n            (let [(str (first conv-files))\\n                  f-name (last (clojure.string/split full-path  \#\\"\\\\\\\\\\"))\\n                  _ (println (str target-folder \\"\\\\\\\\\\" f-name) )\\n                  conv-image (tgaa.struct.image/get-image )\\n                  _ (println conv-image)\\n                  _ (compare-color conv-image)\\n                  _ (mikera.image.core/write conv-image  (str target-folder \\"\\\\\\\\\\" f-name) \\"jpg\\")\\n                  ])))" "(defn convert-yellow-only []\\n  (let [conv-files (rest (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\"))\\n        target-folder (str (tgaa.util.gui/sys-view-ref \\"Target parent folder.\\"))\\n        _ (println target-folder)]\\n            (let [full-path (str (first conv-files))\\n                  f-name (last (clojure.string/split full-path  \#\\"\\\\\\\\\\"))\\n                  _ (println (str target-folder \\"\\\\\\\\\\" f-name) )\\n                  conv-image (tgaa.struct.image/get-image )\\n                  _ (println conv-image)\\n                  _ (compare-color conv-image)\\n                  _ (mikera.image.core/write conv-image  (str target-folder \\"\\\\\\\\\\" f-name) \\"jpg\\")\\n                  ])))" "(convert-yellow-only)" "(defn convert-yellow-only []\\r\\n  (let [conv-files (rest (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\"))\\r\\n        target-folder (str (tgaa.util.gui/sys-view-ref \\"Target parent folder.\\"))\\r\\n        _ (println target-folder)]\\r\\n        (loop [file conv-files]\\r\\n          (if (empty? file)\\r\\n            (println \\"complete\\")\\r\\n            (let [full-path (str (first conv-files))\\r\\n                  file-in-name (last (clojure.string/split full-path  \#\\"\\\\\\\\\\"))\\n                  file-in-parsed (split file-in-name \#\\"\\\\.\\")\\n                  file-out (str target-folder \\"\\\\\\\\\\" (first file-in-parsed \\"_YO.\\" (second file-in-parsed)))\\n                  _ (println \\"processing file \\" (count file) \\" Named \\"  full-path)\\n                  conv-image (tgaa.struct.image/get-image full-path)\\r\\n                  _ (compare-color conv-image)\\r\\n                  _ (mikera.image.core/save conv-image  file-out)\\r\\n                  ]\\r\\n              (recur (rest file)))))))" "(defn convert-yellow-only []\\r\\n  (let [conv-files (rest (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\"))\\r\\n        target-folder (str (tgaa.util.gui/sys-view-ref \\"Target parent folder.\\"))\\r\\n        _ (println target-folder)]\\r\\n        (loop [file conv-files]\\r\\n          (if (empty? file)\\r\\n            (println \\"complete\\")\\r\\n            (let [full-path (str (first conv-files))\\r\\n                  file-in-name (last (clojure.string/split full-path  \#\\"\\\\\\\\\\"))\\n                  file-in-parsed (clojure.string/split file-in-name \#\\"\\\\.\\")\\n                  file-out (str target-folder \\"\\\\\\\\\\" (first file-in-parsed \\"_YO.\\" (second file-in-parsed)))\\n                  _ (println \\"processing file \\" (count file) \\" Named \\"  full-path)\\n                  conv-image (tgaa.struct.image/get-image full-path)\\r\\n                  _ (compare-color conv-image)\\r\\n                  _ (mikera.image.core/save conv-image  file-out)\\r\\n                  ]\\r\\n              (recur (rest file)))))))" "(convert-yellow-only)" "(defn convert-yellow-only []\\r\\n  (let [conv-files (rest (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\"))\\r\\n        target-folder (str (tgaa.util.gui/sys-view-ref \\"Target parent folder.\\"))\\r\\n        _ (println target-folder)]\\r\\n        (loop [file conv-files]\\r\\n          (if (empty? file)\\r\\n            (println \\"complete\\")\\r\\n            (let [full-path (str (first conv-files))\\r\\n                  file-in-name (last (clojure.string/split full-path  \#\\"\\\\\\\\\\"))\\n                  file-in-parsed (clojure.string/split file-in-name \#\\"\\\\.\\")\\n                  file-out (str target-folder \\"\\\\\\\\\\" (first file-in-parsed) \\"_YO.\\" (second file-in-parsed))\\n                  _ (println \\"processing file \\" (count file) \\" Named \\"  full-path)\\n                  conv-image (tgaa.struct.image/get-image full-path)\\r\\n                  _ (compare-color conv-image)\\r\\n                  _ (mikera.image.core/save conv-image  file-out)\\r\\n                  ]\\r\\n              (recur (rest file)))))))" "(defn convert-yellow-only []\\r\\n  (let [conv-files (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\")\\r\\n        target-folder (str (tgaa.util.gui/sys-view-ref \\"Target parent folder.\\" \:file (str conv-files) ))\\r\\n        _ (println target-folder)]\\r\\n        (loop [file (rest conv-files)]\\r\\n          (if (empty? file)\\r\\n            (println \\"complete\\")\\r\\n            (let [full-path (str (first conv-files))\\r\\n                  file-in-name (last (clojure.string/split full-path  \#\\"\\\\\\\\\\"))\\n                  file-in-parsed (clojure.string/split file-in-name \#\\"\\\\.\\")\\n                  file-out (str target-folder \\"\\\\\\\\\\" (first file-in-parsed \\"_YO.\\" (second file-in-parsed)))\\n                  _ (println \\"processing file \\" (count file) \\" Named \\"  full-path)\\n                  conv-image (tgaa.struct.image/get-image full-path)\\r\\n                  _ (compare-color conv-image)\\r\\n                  _ (mikera.image.core/save conv-image  file-out)\\r\\n                  ]\\r\\n              (recur (rest file)))))))" "(convert-yellow-only)" "(defn convert-yellow-only []\\r\\n  (let [conv-files (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\")\\r\\n        target-folder (str (tgaa.util.gui/sys-view-ref \\"Target parent folder.\\" \:folder (str conv-files) ))\\r\\n        _ (println target-folder)]\\r\\n        (loop [file (rest conv-files)]\\r\\n          (if (empty? file)\\r\\n            (println \\"complete\\")\\r\\n            (let [full-path (str (first conv-files))\\r\\n                  file-in-name (last (clojure.string/split full-path  \#\\"\\\\\\\\\\"))\\n                  file-in-parsed (clojure.string/split file-in-name \#\\"\\\\.\\")\\n                  file-out (str target-folder \\"\\\\\\\\\\" (first file-in-parsed \\"_YO.\\" (second file-in-parsed)))\\n                  _ (println \\"processing file \\" (count file) \\" Named \\"  full-path)\\n                  conv-image (tgaa.struct.image/get-image full-path)\\r\\n                  _ (compare-color conv-image)\\r\\n                  _ (mikera.image.core/save conv-image  file-out)\\r\\n                  ]\\r\\n              (recur (rest file)))))))" "(convert-yellow-only)" "(defn convert-yellow-only []\\r\\n  (let [conv-files (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\")\\r\\n        target-folder (str (tgaa.util.gui/sys-view-ref \\"Target parent folder.\\" \:folder (str (first conv-files)) ))\\r\\n        _ (println target-folder)]\\r\\n        (loop [file (rest conv-files)]\\r\\n          (if (empty? file)\\r\\n            (println \\"complete\\")\\r\\n            (let [full-path (str (first conv-files))\\r\\n                  file-in-name (last (clojure.string/split full-path  \#\\"\\\\\\\\\\"))\\n                  file-in-parsed (clojure.string/split file-in-name \#\\"\\\\.\\")\\n                  file-out (str target-folder \\"\\\\\\\\\\" (first file-in-parsed \\"_YO.\\") (second file-in-parsed))\\n                  _ (println \\"processing file \\" (count file) \\" Named \\"  full-path)\\n                  conv-image (tgaa.struct.image/get-image full-path)\\r\\n                  _ (compare-color conv-image)\\r\\n                  _ (mikera.image.core/save conv-image  file-out)\\r\\n                  ]\\r\\n              (recur (rest file)))))))" "(convert-yellow-only)" "(defn convert-yellow-only []\\r\\n  (let [conv-files (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\")\\r\\n        target-folder (str (tgaa.util.gui/sys-view-ref \\"Target parent folder.\\" \:folder (str (first conv-files)) ))]\\r\\n        (loop [file (rest conv-files)]\\r\\n          (if (empty? file)\\r\\n            (println \\"complete\\")\\r\\n            (let [full-path (str (first conv-files))\\r\\n                  file-in-name (last (clojure.string/split full-path  \#\\"\\\\\\\\\\"))\\n                  file-in-parsed (clojure.string/split file-in-name \#\\"\\\\.\\")\\n                  file-out (str target-folder \\"\\\\\\\\\\" (first file-in-parsed) \\"_YO.\\" (second file-in-parsed))\\n                  _ (println \\"processing file \\" (count file) \\" Named \\"  full-path)\\n                  conv-image (tgaa.struct.image/get-image full-path)\\r\\n                  _ (compare-color conv-image)\\r\\n                  _ (mikera.image.core/save conv-image  file-out)\\r\\n                  ]\\r\\n              (recur (rest file)))))))" "(convert-yellow-only)" "(defn convert-yellow-only []\\r\\n  (let [conv-files (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\")\\r\\n        target-folder (str (tgaa.util.gui/sys-view-ref \\"Target parent folder.\\" \:folder (str (first conv-files)) ))]\\r\\n        (loop [file (rest conv-files)]\\r\\n          (if (empty? file)\\r\\n            (println \\"complete\\")\\r\\n            (let [full-path (str (first file))\\r\\n                  file-in-name (last (clojure.string/split full-path  \#\\"\\\\\\\\\\"))\\n                  file-in-parsed (clojure.string/split file-in-name \#\\"\\\\.\\")\\n                  file-out (str target-folder \\"\\\\\\\\\\" (first file-in-parsed) \\"_YO.\\" (second file-in-parsed))\\n                  _ (println \\"processing file \\" (count file) \\" Named \\"  full-path)\\n                  conv-image (tgaa.struct.image/get-image full-path)\\r\\n                  _ (compare-color conv-image)\\r\\n                  _ (mikera.image.core/save conv-image  file-out)\\r\\n                  ]\\r\\n              (recur (rest file)))))))" "(convert-yellow-only)" "(defn convert-yellow-only []\\r\\n  (let [conv-files (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\")\\r\\n        target-folder (str (tgaa.util.gui/sys-view-ref \\"Target parent folder.\\" \:folder (str (first conv-files)) ))]\\r\\n        (loop [file (rest conv-files)]\\r\\n          (if (empty? file)\\r\\n            (println \\"complete\\")\\r\\n            (let [full-path (str (first conv-files))\\r\\n                  file-in-name (last (clojure.string/split full-path  \#\\"\\\\\\\\\\"))\\n                  file-in-parsed (clojure.string/split file-in-name \#\\"\\\\.\\")\\n                  file-out (str target-folder \\"\\\\\\\\\\" (first file-in-parsed) \\"_YO.\\" (second file-in-parsed))\\n                  _ (println \\"processing file \\" (count file) \\" Named \\"  full-path)\\n                  conv-image (tgaa.struct.image/get-image full-path)\\n                  _ (println \\"width\\" (. conv-image getWidth ))\\r\\n                  _ (compare-color conv-image)\\r\\n                  _ (mikera.image.core/save conv-image  file-out)\\r\\n                  ]\\r\\n              (recur (rest file)))))))" "(convert-yellow-only)" "(defn convert-yellow-only []\\r\\n  (let [conv-files (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\")\\r\\n        target-folder (str (tgaa.util.gui/sys-view-ref \\"Target parent folder.\\" \:folder (str (first conv-files)) ))]\\r\\n        (loop [file (rest conv-files)]\\r\\n          (if (empty? file)\\r\\n            (println \\"complete\\")\\r\\n            (let [full-path (str (first file))\\r\\n                  file-in-name (last (clojure.string/split full-path  \#\\"\\\\\\\\\\"))\\n                  file-in-parsed (clojure.string/split file-in-name \#\\"\\\\.\\")\\n                  file-out (str target-folder \\"\\\\\\\\\\" (first file-in-parsed) \\"_YO.\\" (second file-in-parsed))\\n                  _ (println \\"processing file \\" (count file) \\" Named \\"  full-path)\\n                  conv-image (tgaa.struct.image/get-image full-path)\\n                  _ (println \\"width\\" (. conv-image getWidth ))\\r\\n                  _ (compare-color conv-image)\\r\\n                  _ (mikera.image.core/save conv-image  file-out)\\r\\n                  ]\\r\\n              (recur (rest file)))))))" "(convert-yellow-only)" "(defn convert-yellow-only []\\r\\n  (let [conv-files (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\")\\r\\n        target-folder (str (tgaa.util.gui/sys-view-ref \\"Target parent folder.\\" \:folder (str (first conv-files)) ))]\\r\\n        (loop [file (rest conv-files)]\\r\\n          (if (empty? file)\\r\\n            (println \\"complete\\")\\r\\n            (let [full-path (str (first file))\\r\\n                  file-in-name (last (clojure.string/split full-path  \#\\"\\\\\\\\\\"))\\n                  file-in-parsed (clojure.string/split file-in-name \#\\"\\\\.\\")\\n                  file-out (str target-folder \\"\\\\\\\\\\" (first file-in-parsed) \\"_YO.\\" (second file-in-parsed))\\n                  _ (println \\"processing file \\" (count file) \\" Named \\"  full-path)\\n                  conv-image (tgaa.struct.image/get-image full-path)\\n                  _ (println \\"width\\" (. conv-image getWidth ) \\"height\\"(. conv-image getHeight ))\\r\\n                  _ (compare-color conv-image)\\r\\n                  _ (mikera.image.core/save conv-image  file-out)\\r\\n                  ]\\r\\n              (recur (rest file)))))))" "(convert-yellow-only)" "(defn convert-yellow-only []\\r\\n  (let [conv-files (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\")\\r\\n        target-folder (str (tgaa.util.gui/sys-view-ref \\"Target parent folder.\\" \:folder (str (first conv-files)) ))]\\r\\n        (loop [file (rest conv-files)]\\r\\n          (if (empty? file)\\r\\n            (println \\"complete\\")\\r\\n            (let [full-path (str (first file))\\r\\n                  file-in-name (last (clojure.string/split full-path  \#\\"\\\\\\\\\\"))\\r\\n                  file-in-parsed (clojure.string/split file-in-name \#\\"\\\\.\\")\\r\\n                  file-out (str target-folder \\"\\\\\\\\\\" (first file-in-parsed) \\"_YO.\\" (second file-in-parsed))\\r\\n                  _ (println \\"processing file \\" (count file) \\" Named \\"  full-path)\\r\\n                  conv-image (tgaa.struct.image/get-image full-path)\\r\\n                  _ (println \\"width\\" (. conv-image getWidth ) \\"height\\"(. conv-image getHeight ))\\r\\n                  _ (compare-color conv-image)\\r\\n                  _ (Thread/sleep 1000) \\r\\n                  _ (mikera.image.core/save conv-image  file-out)\\r\\n                  ]\\r\\n              (recur (rest file)))))))" "(convert-yellow-only)" "(defn convert-yellow-only []\\r\\n  (let [conv-files (tgaa.util.gui/sys-folder-all-files \\"Parent folder to convert all images.\\")\\r\\n        target-folder (str (tgaa.util.gui/sys-view-ref \\"Target parent folder.\\" \:folder (str (first conv-files)) ))]\\r\\n        (loop [file (rest conv-files)]\\r\\n          (if (empty? file)\\r\\n            (println \\"complete\\")\\r\\n            (let [full-path (str (first file))\\r\\n                  file-in-name (last (clojure.string/split full-path  \#\\"\\\\\\\\\\"))\\r\\n                  file-in-parsed (clojure.string/split file-in-name \#\\"\\\\.\\")\\r\\n                  file-out (str target-folder \\"\\\\\\\\\\" (first file-in-parsed) \\"_YO.\\" (second file-in-parsed))\\r\\n                  _ (println \\"processing file \\" (count file) \\" Named \\"  full-path)\\r\\n                  conv-image (tgaa.struct.image/get-image full-path)\\r\\n                  _ (println \\"width\\" (. conv-image getWidth ) \\"height\\"(. conv-image getHeight ))\\r\\n                  _ (Thread/sleep 1000)\\r\\n                  _ (compare-color conv-image)\\r\\n                  _ (mikera.image.core/save conv-image  file-out)\\r\\n                  ]\\r\\n              (recur (rest file)))))))" "(convert-yellow-only)" "(defn compare-color [ref]\\r\\n   (doall (for [x (range (tgaa.struct.image/image-width ref))\\r\\n          y (range (tgaa.struct.image/image-height ref))\\r\\n              \:when (not (pxl-yellow (get-rgb-vec ref x y)))]\\r\\n     (. ref setRGB x y -1))))" "(convert-yellow-only)" "(tgaa.util.image-band-filter/convert-yellow-only)" "(convert-yellow-only)" "(tgaa.util.image-band-filter/convert-yellow-only)" "(shared/image-ref)" "(butlast [1 2 3])" "(viz/show-image)" "(run-as-app)" "(viz/show-eval-paths-result)" "(run-as-app)" "(viz/show-eval-paths-result)" "(tgaa.util.image-band-filter/convert-yellow-only)" "(tgaa.util.dice-metric-analysis/dice-metric)" "(run-as-app)" "(viz/show-eval-paths-result)" "(run-as-app)" "(tgaa.util.image-band-filter/convert-yellow-only)" "(tgaa.util.image-band-filter/convert-yellow-image)" "(tgaa.util.gui/sys-view-ref \\"Parent folder to convert all images.\\")" "(tgaa.util.gui/sys-view-ref \\"Parent folder to convert all images.\\" \:file)" "(tgaa.util.image-band-filter/convert-yellow-image)" "(tgaa.util.dice-metric-analysis/dice-metric)" "(run-as-app)" "(tgaa.util.image-band-filter/convert-yellow-image)" "(tgaa.util.dice-metric-analysis/dice-metric)" "(run-as-app)" "(tgaa.util.image-band-filter/convert-yellow-image)" "(def t (str (tgaa.util.gui/sys-view-ref \\"Parent folder to convert all images.\\" \:file)))" "t" "(split t \#\\"\\\\\\\\\\")" "(split \#\\"\\\\\\\\\\" t)" "(clojure.string/split \#\\"\\\\\\\\\\" t)" "(clojure.string/split t \#\\"\\\\\\\\\\" )" "(butlast (clojure.string/split t \#\\"\\\\\\\\\\" ))" "(interpose \\"\\\\\\\\\\" (butlast (clojure.string/split t \#\\"\\\\\\\\\\" )))" "(str (interpose \\"\\\\\\\\\\" (butlast (clojure.string/split t \#\\"\\\\\\\\\\" ))))" "(apply str  (interpose \\"\\\\\\\\\\" (butlast (clojure.string/split t \#\\"\\\\\\\\\\" ))))" "(tgaa.util.dice-metric-analysis/dice-metric)" "(run-as-app)" "5_1_3" "(run-as-app)" "(tgaa.util.image-band-filter/convert-yellow-image)" "(tgaa.util.dice-metric-analysis/dice-metric)" "(run-as-app)" "4 4 21" "(run-as-app)" "(tgaa.util.image-band-filter/convert-yellow-image)" "(tgaa.util.dice-metric-analysis/dice-metric)" "(tgaa.util.image-band-filter/convert-yellow-image)" "(tgaa.util.dice-metric-analysis/dice-metric)" "(tgaa.util.image-band-filter/convert-yellow-image)" "(tgaa.util.dice-metric-analysis/dice-metric)" "(run-as-app)" "(tgaa.util.dice-metric-analysis/dice-metric)" "(run-as-app)" "(slurp \\"results.edn\\"" "(slurp \\"results.edn\\")" "(def rs (slurp \\"results.edn\\"))" "(map \:dice ts)" "(map \:dice rs)" "(map \#(\:dice %) rs)" "(map \#(count %) rs)" "(map \#(class %) rs)" "(def rs ((read-string (slurp \\"results.edn\\"))))" "(def rs (read-string (slurp \\"results.edn\\")))" "(map \:dice rs)" "(map \#(\:dice %) rs)" "rs" "(def rs (read-string (slurp \\"results.edn\\")))" "(map \#(\:dice %) rs)" "(map \#((\:dice %) (\:predicted-loc)) rs)" "(map \#((\:dice %) (\:predicted-loc %)) rs)" "(map \#([(\:dice %) (\:predicted-loc %)]) rs)" "(map \#(\:dice %) rs)" "(run-as-app)" "(tgaa.util.image-band-filter/convert-yellow-only)" "(tgaa.util.image-band-filter/convert-yellow-image)" "(tgaa.util.dice-metric-analysis/dice-metric)" "(run-as-app)" "(tgaa.util.image-band-filter/convert-yellow-image)" "(tgaa.util.dice-metric-analysis/dice-metric)" "(run-as-app)" "(require 'clojure.string)" "(defn sample-type [sample]\\r\\n (if (> (index-of (lower-case (\:predicted-loc sample))  \\"volume analysis\\") 0)\\n   \:pred\\n   \:sample))" "dotimes" "rs" "(first rs)" "(defn sample-type [sample]\\r\\n (if (> (index-of (lower-case (\:predicted-loc sample))  \\"volume analysis\\") 0)\\n   \:pred\\n   \:sample))" "(defn sample-type [sample]\\r\\n (if (> (clojure.string/index-of (clojure.string/lower-case (\:predicted-loc sample))  \\"volume analysis\\") 0)\\n   \:pred\\n   \:sample))" "(sample-type (first rs))" "(filter \#(\= (sample-type %) \:pred) rs)" "rs" "(filter \#(\= (sample-type %) \:pred) rs)" "(map \#(\= (sample-type %) \:pred) rs)" "(sample-type (first rs))" "(count rs)" "(filter \#(\= (sample-type %) \:pred) rs)" "(filter \#(sample-type %) rs)" "(filter \#(print \\"test\\") rs)" "(run-as-app)" "(tgaa.util.image-band-filter/convert-yellow-image)" "(tgaa.util.dice-metric-analysis/dice-metric)" "tgaa.util.results-process" "tgaa.util.results-process/get-all-dm" "(tgaa.util.results-process/get-all-dm)" "\\r\\n(def rs \\r\\n  (read-string \\r\\n    (slurp \\"results.edn\\")))" "(defn get-all-dm [res-col]\\r\\n  (map \#(\:dice %) res-col))" "(get-all-dm)" "(get-all-dm rs)" "(tgaa.util.results-process/extract-dm tgaa.util.results-process/rs)" "tgaa.util.results-process/rs" "(tgaa.util.results-process/extract-dm \:pred)" "  (filter \#(\= (sample-type %) type-key) rs)" "  (filter \#(\= (sample-type %) \:pred) rs)" "  (filter \#(sample-type %) rs)" "(defn sample-type [sample]\\r\\n  (if (> (clojure.string/index-of (clojure.string/lower-case (\:predicted-loc sample))  \\"volume analysis\\") 0)\\r\\n    \:pred\\r\\n    \:sample))" "  (filter \#(sample-type %) rs)" "  (filter \#(not(empty? %)) rs)" "  (filter \#(sample-type %) rs)" "  (filter \#(count %) rs)" "  (map \#(sample-type %) rs)" " (sample-type (first rs))" "  (filter \#(nil? (sample-type %)) rs)" "  (filter (fn [v] (nil? (sample-type v))) rs)" "  (filter (fn [v] (do (print (count v))(nil? (sample-type v)))) rs)" "rs" "  (filter (fn [v] (do (print (count v))(nil? (sample-type v)))) rs)" "  (filter (fn [v] (do (print (class v))(nil? (sample-type v)))) rs)" "(run-as-app)" "(viz/show-eval-paths-result)" "(run-as-app)" "(viz/show-eval-paths-result)" "(run-as-app)" "(viz/show-image)" "(viz/show-eval-paths-result)" "(run-as-app)" "(+ 1 1)" "(run-as-app)" "(+ 1 1)" "tgaa.util.results-process/rs" "(shared/image-loc)" "(run-as-app)" "(def t tgaa.util.results-process/rs)" "(map \#(print (first %)) t)" "(map \#(print %) t)" "(run-as-app)" "(map \#(class %) t)" "(map \#(count %) t)" "(fist t)" "(first t)" "(map \#(\:no-diff-pnts %) t)" "(run-as-app)" "(map \#(if (> (clojure.string/index-of (clojure.string/lower-case (\:predicted-loc %))  \\"volume analysis\\") 0)\\r\\n    \:pred\\r\\n    \:sample) t)" "(map \#((\:predicted-loc %) %) t)" "(map \#(\:predicted-loc %) %) t)" "(map \#(\:predicted-loc % %) t)" "(clojure.string/index-of \\"4\\" \\"3\\")" "(map \#(if (nil? (clojure.string/index-of (clojure.string/lower-case (\:predicted-loc %))  \\"volume analysis\\"))\\r\\n   \:sample \\r\\n    \:pred) t)" "(tgaa.util.image-band-filter/extract-dm t \:pred)" "(tgaa.util.image-band-filter" "tgaa.util.results-process/extract-dm" "(tgaa.util.results-process/extract-dmn t \:pred)" "(tgaa.util.results-process/extract-dm t \:pred)" "(tgaa.util.image-band-filter/get-all-dm (tgaa.util.results-process/extract-dm t \:pred))" "(tgaa.util.image-band-filter/extract-dm (tgaa.util.results-process/extract-dm t \:pred))" "(run-as-app)" "(in-ns 'tgaa.util.image-band-filter)" "(get-results)" "(\:require [clojure.string \:as st])" "(require 'clojure.string)" "(\:required [clojure.string \:as st])" "(required 'clojure.string)" "(defn get-results [] \\r\\n  (read-string \\r\\n    (slurp \\"results.edn\\")))" "(+ 1 1)" "(run-as-app)" "(in-ns 'tgaa.util.image-band-filter)" "(tgaa.util.results-process/extract-dm (tgaa.util.results-process/sample-type (tgaa.util.results-process/get-results) \:pred))" "(tgaa.util.results-process/extract-dm \\n  (tgaa.util.results-process/extract-result-type\\n    (tgaa.util.results-process/get-results) \:pred))" "(count (tgaa.util.image-band-filter/get-pred-dm))" "(tgaa.util.image-band-filter/get-pred-dm)" "(tgaa.util.results-process/extract-dm \\n  (tgaa.util.results-process/extract-result-type\\n    (tgaa.util.results-process/get-results) \:pred))" "(count (tgaa.util.results-process/extract-dm \\n         (tgaa.util.results-process/extract-result-type\\n           (tgaa.util.results-process/get-results) \:pred)))" "(get-pred-dm)" "(count (get-pred-dm))" "(run-as-app)" "(shared/image-loc)" "(run-as-app)" "(shared/image-loc)" "(run-as-app)" "(shared/image-loc)" "(run-as-app)" "(shared/image-loc)" "(run-as-app)" "(tgaa.util.image-band-filter/convert-yellow-only)" "(tgaa.util.dice-metric-analysis/perform-dice-analysis)" "(def t (tgaa.util.dice-metric-analysis/perform-dice-analysis))" "(+ 1 1)" "(count t)" "(map \#(compute-dice-metric %)  t)" "(map \#(tgaa.util.dice-metric-analysis/compute-dice-metric %)  t)" "(tgaa.util.dice-metric-analysis/dice-metric)" "(tgaa.util.results-process/get-results)" "(tgaa.util.results-process/extract-dm (tgaa.util.results-process/get-results))" "(count tgaa.util.results-process)" "(tgaa.util.results-process/extract-dm (tgaa.util.results-process/get-results))" "(tgaa.util.dice-metric-analysis/dice-metric)" "(tgaa.util.results-process/extract-dm (tgaa.util.results-process/get-results))" "(tgaa.util.dice-metric-analysis/dice-metric)"]
eclipse.preferences.version=1
