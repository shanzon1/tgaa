cmdhistory=["(map count (filter  \#(is-boxed (nth est-can 1) %) est-can))" "(map count (split-with  (partial is-boxed (nth est-can 1)) est-can))" "(nth est-can 1)" "(map count (split-with  (partial is-boxed {\:path-length 31,\\r\\n \:local-max [184 376],\\r\\n \:local-min [214 376],\\r\\n \:end [184 376],\\r\\n \:start [214 376],\\r\\n \:dir [-1 0],\\r\\n \:thresh? true,\\r\\n \:trial-num 25}) est-can))" "(map count (split-with  (partial is-boxed (nth est-can 1)) est-can))" "(map count (filter  \#(is-boxed (nth est-can 1) %) est-can))" "(count (filter  \#(is-boxed (nth est-can 1) %) est-can))" "(count (filter  \#(is-boxed (nth est-can 10) %) est-can))" "(class est-can)" "(count (filter  \#(is-boxed (nth est-can 10) %) est-can))" "(count (take-while  \#(is-boxed (nth est-can 10) %) est-can))" "(defn drop-one\\r\\n  [coll]\\r\\n  (when-let [s (seq coll)]\\r\\n    (rest s)))" "(drop-one [1 2 3])" "(when-let [s [1 2 3]]\\r\\n  (rest s))" "(count (filter  \#(is-boxed (nth est-can 10) %) est-can))" "(map  \#(is-boxed (nth est-can 10) %) est-can)" "(count (filter  \#(is-boxed (nth est-can 10) %) est-can))" "(count (split-with  (fn [x] (is-boxed (nth est-can 10) x)) est-can))" "(map count (split-with  (fn [x] (is-boxed (nth est-can 10) x)) est-can))" "(loop [to-group est-can class [] non-class est-can]\\n   (if (empty? cann)\\n     {\:class class  \:non-class non-class}\\n     (recur (rest to-group) \\n            (cons(filter  \#(is-boxed (first to-group) %) non-class)" "(const [1] [1 2])" "(cons\\n  [1] [1 2])" "(apply cons [1] [1 2])" "(apply conj [1] [1 2])" "(apply conj [1 4] [1 2])" "(loop [to-group est-can class [] non-class est-can]\\n   (if (empty? cann)\\n     {\:class class  \:non-class non-class}\\n     (recur (rest to-group) \\n            (conj class (filter  \#(is-boxed (first to-group) %) non-class))\\n            (conj class (filter  \#(not (is-boxed (first to-group) %)) non-class))" "(loop [to-group est-can class [] non-class est-can]\\n   (if (empty? cann)\\n     {\:class class  \:non-class non-class}\\n     (recur (rest to-group) \\n            (conj class (filter  \#(is-boxed (first to-group) %) non-class))\\n            (conj class (filter  \#(not (is-boxed (first to-group) %)) non-class)))))" "(loop [to-group est-can class [] non-class est-can]\\n   (if (empty? to-group)\\n     {\:class class  \:non-class non-class}\\n     (recur (rest to-group) \\n            (conj class (filter  \#(is-boxed (first to-group) %) non-class))\\n            (conj class (filter  \#(not (is-boxed (first to-group) %)) non-class)))))" "(loop [to-group est-can class [] non-class est-can]\\n   (if (empty? to-group)\\n     {\:class class  \:non-class non-class}\\n     (recur (rest to-group) \\n            (conj class (filter  \#(is-boxed (first to-group) %) non-class))\\n            (filter  \#(not (is-boxed (first to-group) %)) non-class))))" "(loop [to-group est-can class [] non-class est-can]\\n   (if (empty? to-group)\\n     {\:class class  \:non-class non-class}\\n            (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)]\\n              (if (not (empty? filter-group)\\n                  (recur (rest to-group) \\n                         (conj class (filter  \#(is-boxed (first to-group) %) non-class))\\n                         (filter  \#(not (is-boxed (first to-group) %)) non-class))\\n                  (recur (rest to-group)\\n                         non-class\\n                         est-can))))))" "(loop [to-group est-can class [] non-class est-can]\\n   (if (empty? to-group)\\n     {\:class class  \:non-class non-class}\\n            (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)]\\n              (if (not (empty? filter-group))\\n                  (recur (rest to-group) \\n                         (conj class (filter  \#(is-boxed (first to-group) %) non-class))\\n                         (filter  \#(not (is-boxed (first to-group) %)) non-class))\\n                  (recur (rest to-group)\\n                         non-class\\n                         est-can)))))" "(loop [to-group est-can class [] non-class est-can]\\n   (if (empty? to-group)\\n     {\:class class  \:non-class non-class}\\n            (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)]\\n              (if (not (empty? filter-group))\\n                  (recur (rest to-group) \\n                         (conj class filter-group)\\n                         (filter  \#(not (is-boxed (first to-group) %)) non-class))\\n                  (recur (rest to-group)\\n                         non-class\\n                         est-can)))))" "(def t (loop [to-group est-can class [] non-class est-can]\\n          (if (empty? to-group)\\n            {\:class class  \:non-class non-class}\\n                   (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)]\\n                     (if (not (empty? filter-group))\\n                         (recur (rest to-group) \\n                                (conj class filter-group)\\n                                (filter  \#(not (is-boxed (first to-group) %)) non-class))\\n                         (recur (rest to-group)\\n                                non-class\\n                                est-can))))))" "(map count t)" "(map (\:class t))" "(count count t)" "(count (\:class t))" "(count (\:non-class t))" "(count est-can)" "(def t (loop [to-group est-can class [] non-class est-can]\\n          (if (empty? to-group)\\n            {\:class class  \:non-class non-class}\\n                   (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)\\n                         _ (print \\"found \: \\" (count filter-group))]\\n                     (if (not (empty? filter-group))\\n                         (recur (rest to-group) \\n                                (conj class filter-group)\\n                                (filter  \#(not (is-boxed (first to-group) %)) non-class))\\n                         (recur (rest to-group)\\n                                non-class\\n                                est-can))))))" "(def t (loop [to-group est-can class [] non-class est-can]\\n          (if (empty? to-group)\\n            {\:class class  \:non-class non-class}\\n                   (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)]\\n                     (if (not (empty? filter-group))\\n                         (recur (rest to-group) \\n                                (apply conj class filter-group)\\n                                (filter  \#(not (is-boxed (first to-group) %)) non-class))\\n                         (recur (rest to-group)\\n                                non-class\\n                                est-can))))))" "(count (\:non-class t))" "(count (\:class t))" "t" "(def t \\n  (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 10) (tgaa.util.shared/canidates))]\\n  (loop [to-group est-can class [] non-class est-can]\\n     (if (empty? to-group)\\n       {\:class class  \:non-class non-class}\\n              (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)]\\n                (if (not (empty? filter-group))\\n                    (recur (rest to-group) \\n                           (apply conj class filter-group)\\n                           (filter  \#(not (is-boxed (first to-group) %)) non-class))\\n                    (recur (rest to-group)\\n                           non-class\\n                           est-can)))))))" "(count (\:class t))" "(count (\:non-class t))" "(def t \\n  (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 5) (tgaa.util.shared/canidates))]\\n  (loop [to-group est-can class [] non-class est-can]\\n     (if (empty? to-group)\\n       {\:class class  \:non-class non-class}\\n              (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)]\\n                (if (not (empty? filter-group))\\n                    (recur (rest to-group) \\n                           (apply conj class filter-group)\\n                           (filter  \#(not (is-boxed (first to-group) %)) non-class))\\n                    (recur (rest to-group)\\n                           non-class\\n                           est-can)))))))" "(count (\:non-class t))" "(count (\:class t))" "(tgaa.util.image/show-cann-path 5)" "(import 'java.awt.Color)" "(tgaa.util.image/show-cann-path 5)" "(tgaa.util.image/show-cann-path 10)" "(def t \\n  (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 15) (tgaa.util.shared/canidates))]\\n  (loop [to-group est-can class [] non-class est-can]\\n     (if (empty? to-group)\\n       {\:class class  \:non-class non-class}\\n              (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)]\\n                (if (not (empty? filter-group))\\n                    (recur (rest to-group) \\n                           (apply conj class filter-group)\\n                           (filter  \#(not (is-boxed (first to-group) %)) non-class))\\n                    (recur (rest to-group)\\n                           non-class\\n                           est-can)))))))" "(count (\:class t))" "(count (\:non-class t))" "(tgaa.util.image/show-cann-path 15)" "(def t \\n  (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 15) (tgaa.util.shared/canidates))]\\n  (loop [to-group (first est-can) class [] non-class est-can]\\n     (if (empty? to-group)\\n       {\:class class  \:non-class non-class}\\n              (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)]\\n                (if (not (empty? filter-group))\\n                    (recur (apply conj filter-group (rest to-group))\\n                           (apply conj class filter-group)\\n                           (filter  \#(not (is-boxed (first to-group) %)) non-class))\\n                    (recur (rest to-group)\\n                           non-class\\n                           est-can)))))))" "(def t \\n  (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 15) (tgaa.util.shared/canidates))]\\n  (loop [to-group (first est-can) class [] non-class est-can]\\n     (if (empty? to-group)\\n       {\:class class  \:non-class non-class}\\n              (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)\\n                    _ (print \\"hear\\")]\\n                (if (not (empty? filter-group))\\n                    (recur (apply conj filter-group (rest to-group))\\n                           (apply conj class filter-group)\\n                           (filter  \#(not (is-boxed (first to-group) %)) non-class))\\n                    (recur (rest to-group)\\n                           non-class\\n                           est-can)))))))" "(def t \\n  (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 15) (tgaa.util.shared/canidates))]\\n  (loop [to-group [(first est-can)] class [] non-class est-can]\\n     (if (empty? to-group)\\n       {\:class class  \:non-class non-class}\\n              (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)\\n                    _ (print \\"hear\\")]\\n                (if (not (empty? filter-group))\\n                    (recur (apply conj filter-group (rest to-group))\\n                           (apply conj class filter-group)\\n                           (filter  \#(not (is-boxed (first to-group) %)) non-class))\\n                    (recur (rest to-group)\\n                           non-class\\n                           est-can)))))))" "(def t \\n  (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 15) (tgaa.util.shared/canidates))]\\n  (loop [to-group [(first est-can)] class [] non-class est-can]\\n     (if (empty? to-group)\\n       {\:class class  \:non-class non-class}\\n              (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)\\n                    _ (print \\"hear\\" (rest to-group))]\\n                (if (not (empty? filter-group))\\n                    (recur (apply conj filter-group (rest to-group))\\n                           (apply conj class filter-group)\\n                           (filter  \#(not (is-boxed (first to-group) %)) non-class))\\n                    (recur (rest to-group)\\n                           non-class\\n                           est-can)))))))" "(def t \\n  (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (tgaa.util.shared/canidates))]\\n  (loop [to-group [(first est-can)] class [] non-class est-can]\\n     (if (empty? to-group)\\n       {\:class class  \:non-class non-class}\\n              (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)\\n                    _ (print \\"hear\\" (rest to-group))]\\n                (if (not (empty? filter-group))\\n                    (recur (apply conj filter-group (rest to-group))\\n                           (apply conj class filter-group)\\n                           (filter  \#(not (is-boxed (first to-group) %)) non-class))\\n                    (recur (rest to-group)\\n                           non-class\\n                           est-can)))))))" "(apply conj [1 2 2] [])" "(apply conj [][1 2 2])" "(def t \\n  (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (tgaa.util.shared/canidates))]\\n  (loop [to-group [(first est-can)] class [] non-class est-can]\\n     (if (empty? to-group)\\n       {\:class class  \:non-class non-class}\\n              (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)\\n                    _ (print \\"hear\\" (rest to-group))]\\n                (if (not (empty? filter-group))\\n                    (recur (apply conj  (rest to-group) filter-group )\\n                           (apply conj class filter-group)\\n                           (filter  \#(not (is-boxed (first to-group) %)) non-class))\\n                    (recur (rest to-group)\\n                           non-class\\n                           est-can)))))))" "\=> (def t \\n     (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (tgaa.util.shared/canidates))]\\n     (loop [to-group [(first est-can)] class [] non-class (rest est-can)]\\n        (if (empty? to-group)\\n          {\:class class  \:non-class non-class}\\n                 (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)\\n                       _ (print \\"test\\")]\\n                   (if (not (empty? filter-group))\\n                       (recur (apply conj  (rest to-group) filter-group )\\n                              (apply conj class filter-group)\\n                              (filter  \#(not (is-boxed (first to-group) %)) non-class))\\n                       (recur (rest to-group)\\n                              non-class\\n                              est-can)))))))" "\=> (def t \\n     (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (tgaa.util.shared/canidates))]\\n     (loop [to-group [(first est-can)] class [] non-class (rest est-can)]\\n        (if (empty? to-group)\\n          {\:class class  \:non-class non-class}\\n                 (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)\\n                       _ (println \\"test\:\\" (count filter-group))]\\n                   (if (not (empty? filter-group))\\n                       (recur (apply conj  (rest to-group) filter-group )\\n                              (apply conj class filter-group)\\n                              (filter  \#(not (is-boxed (first to-group) %)) non-class))\\n                       (recur (rest to-group)\\n                              non-class\\n                              est-can)))))))" "\=> (def t \\n     (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (tgaa.util.shared/canidates))]\\n     (loop [to-group [(first est-can)] class [] non-class (rest est-can)]\\n        (if (empty? to-group)\\n          {\:class class  \:non-class non-class}\\n                 (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)\\n                       _ (println \\"test\:\\" (count filter-group))]\\n                   (if (not (empty? filter-group))\\n                       (recur (apply conj  (rest to-group) filter-group )\\n                              (apply conj class filter-group)\\n                              (filter  \#(not (is-boxed (first to-group) %)) non-class))\\n                       (recur (rest to-group)\\n                              class\\n                              non-class)))))))" "(+ 1 1)" "\=> (def t \\r\\n     (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (tgaa.util.shared/canidates))]\\r\\n     (loop [to-group [(first est-can)] class [] non-class (rest est-can)]\\r\\n        (if (empty? to-group)\\r\\n          {\:class class  \:non-class non-class}\\r\\n                 (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)\\r\\n                       _ (println \\"test\:\\" (count filter-group))]\\r\\n                   (if (not (empty? filter-group))\\r\\n                       (recur (apply conj  (rest to-group) filter-group )\\r\\n                              (apply conj class filter-group)\\r\\n                              (filter  \#(not (is-boxed (first to-group) %)) non-class))\\r\\n                       (recur (rest to-group)\\r\\n                              class\\r\\n                              non-class)))))))" "(process-image)" "\=> (def t \\r\\n     (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (tgaa.util.shared/canidates))]\\r\\n     (loop [to-group [(first est-can)] class [] non-class (rest est-can)]\\r\\n        (if (empty? to-group)\\r\\n          {\:class class  \:non-class non-class}\\r\\n                 (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)\\r\\n                       _ (println \\"test\:\\" (count filter-group))]\\r\\n                   (if (not (empty? filter-group))\\r\\n                       (recur (apply conj  (rest to-group) filter-group )\\r\\n                              (apply conj class filter-group)\\r\\n                              (filter  \#(not (is-boxed (first to-group) %)) non-class))\\r\\n                       (recur (rest to-group)\\r\\n                              class\\r\\n                              non-class)))))))" "(def t \\r\\n     (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (tgaa.util.shared/canidates))]\\r\\n     (loop [to-group [(first est-can)] class [] non-class (rest est-can)]\\r\\n        (if (empty? to-group)\\r\\n          {\:class class  \:non-class non-class}\\r\\n                 (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)\\r\\n                       _ (println \\"test\:\\" (count filter-group))]\\r\\n                   (if (not (empty? filter-group))\\r\\n                       (recur (apply conj  (rest to-group) filter-group )\\r\\n                              (apply conj class filter-group)\\r\\n                              (filter  \#(not (is-boxed (first to-group) %)) non-class))\\r\\n                       (recur (rest to-group)\\r\\n                              class\\r\\n                              non-class)))))))" "(def t \\r\\n     (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (tgaa.util.shared/canidates))]\\r\\n     (loop [to-group [(first est-can)] class [] non-class (rest est-can)]\\r\\n        (if (empty? to-group)\\r\\n          {\:class class  \:non-class non-class}\\r\\n                 (let [filter-group (filter  \#(tgaa.algo.trial/is-boxed (first to-group) %) non-class)\\r\\n                       _ (println \\"test\:\\" (count filter-group))]\\r\\n                   (if (not (empty? filter-group))\\r\\n                       (recur (apply conj  (rest to-group) filter-group )\\r\\n                              (apply conj class filter-group)\\r\\n                              (filter  \#(not (tgaa.algo.trial/is-boxed (first to-group) %)) non-class))\\r\\n                       (recur (rest to-group)\\r\\n                              class\\r\\n                              non-class)))))))" "(def t \\r\\n     (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (tgaa.util.shared/canidates))]\\r\\n     (loop [to-group [(first est-can)] class [] non-class (rest est-can)]\\r\\n        (if (empty? to-group)\\r\\n          {\:class class  \:non-class non-class}\\r\\n                 (let [filter-group (filter  \#(tgaa.algo.trial/is-boxed (first to-group) %) non-class)]\\r\\n                   (if (not (empty? filter-group))\\r\\n                       (recur (apply conj  (rest to-group) filter-group )\\r\\n                              (apply conj class filter-group)\\r\\n                              (filter  \#(not (tgaa.algo.trial/is-boxed (first to-group) %)) non-class))\\r\\n                       (recur (rest to-group)\\r\\n                              class\\r\\n                              non-class)))))))" "(count (\:non-class t))" "(count (\:class t))" "(tgaa.util.image/show-cann-path 25)" "(import 'java.awt.Color)" "(tgaa.util.image/show-cann-path 25)" "(def t \\r\\n     (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 10) (tgaa.util.shared/canidates))]\\r\\n     (loop [to-group [(first est-can)] class [] non-class (rest est-can)]\\r\\n        (if (empty? to-group)\\r\\n          {\:class class  \:non-class non-class}\\r\\n                 (let [filter-group (filter  \#(tgaa.algo.trial/is-boxed (first to-group) %) non-class)]\\r\\n                   (if (not (empty? filter-group))\\r\\n                       (recur (apply conj  (rest to-group) filter-group )\\r\\n                              (apply conj class filter-group)\\r\\n                              (filter  \#(not (tgaa.algo.trial/is-boxed (first to-group) %)) non-class))\\r\\n                       (recur (rest to-group)\\r\\n                              class\\r\\n                              non-class)))))))" "(count (\:class t))" "(count (\:non-class t))" "(tgaa.util.image/show-cann-path 10)" "(def t \\r\\n     (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 10) (tgaa.util.shared/canidates))]\\r\\n     (loop [to-group [(first est-can)] class [(first est-can)] non-class (rest est-can)]\\r\\n        (if (empty? to-group)\\r\\n          {\:class class  \:non-class non-class}\\r\\n                 (let [filter-group (filter  \#(tgaa.algo.trial/is-boxed (first to-group) %) non-class)]\\r\\n                   (if (not (empty? filter-group))\\r\\n                       (recur (apply conj  (rest to-group) filter-group )\\r\\n                              (apply conj class filter-group)\\r\\n                              (filter  \#(not (tgaa.algo.trial/is-boxed (first to-group) %)) non-class))\\r\\n                       (recur (rest to-group)\\r\\n                              class\\r\\n                              non-class)))))))" "(count (\:class t))" "(def t \\r\\n     (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 1) (tgaa.util.shared/canidates))]\\r\\n     (loop [to-group [(first est-can)] class [(first est-can)] non-class (rest est-can)]\\r\\n        (if (empty? to-group)\\r\\n          {\:class class  \:non-class non-class}\\r\\n                 (let [filter-group (filter  \#(tgaa.algo.trial/is-boxed (first to-group) %) non-class)]\\r\\n                   (if (not (empty? filter-group))\\r\\n                       (recur (apply conj  (rest to-group) filter-group )\\r\\n                              (apply conj class filter-group)\\r\\n                              (filter  \#(not (tgaa.algo.trial/is-boxed (first to-group) %)) non-class))\\r\\n                       (recur (rest to-group)\\r\\n                              class\\r\\n                              non-class)))))))" "(count (\:class t))" "(count (\:non-class t))" "(tgaa.util.image/show-cann-path 1)" "(tgaa.util.image/show-cann-path 2)" "(def t \\r\\n     (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 2) (tgaa.util.shared/canidates))]\\r\\n     (loop [to-group [(first est-can)] class [(first est-can)] non-class (rest est-can)]\\r\\n        (if (empty? to-group)\\r\\n          {\:class class  \:non-class non-class}\\r\\n                 (let [filter-group (filter  \#(tgaa.algo.trial/is-boxed (first to-group) %) non-class)]\\r\\n                   (if (not (empty? filter-group))\\r\\n                       (recur (apply conj  (rest to-group) filter-group )\\r\\n                              (apply conj class filter-group)\\r\\n                              (filter  \#(not (tgaa.algo.trial/is-boxed (first to-group) %)) non-class))\\r\\n                       (recur (rest to-group)\\r\\n                              class\\r\\n                              non-class)))))))" "(count (\:non-class t))" "(count (\:class t))" "(tgaa.util.image/show-cann-path 2)" "(tgaa.util.image/show-cann-path 3)" "(def t \\r\\n     (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 3) (tgaa.util.shared/canidates))]\\r\\n     (loop [to-group [(first est-can)] class [(first est-can)] non-class (rest est-can)]\\r\\n        (if (empty? to-group)\\r\\n          {\:class class  \:non-class non-class}\\r\\n                 (let [filter-group (filter  \#(tgaa.algo.trial/is-boxed (first to-group) %) non-class)]\\r\\n                   (if (not (empty? filter-group))\\r\\n                       (recur (apply conj  (rest to-group) filter-group )\\r\\n                              (apply conj class filter-group)\\r\\n                              (filter  \#(not (tgaa.algo.trial/is-boxed (first to-group) %)) non-class))\\r\\n                       (recur (rest to-group)\\r\\n                              class\\r\\n                              non-class)))))))" "(count (\:class t))" "(count (\:non-class t))" "(tgaa.util.image/show-cann-path 3)" "(defn group [non-group]\\r\\n     (loop [to-group [(first non-group)] grouping [(first non-group)] working-non-group (rest non-group)]\\r\\n        (if (empty? to-group)\\r\\n          {\:group grouping  \:non-group working-non-group}\\r\\n                 (let [filter-group (filter  \#(tgaa.algo.trial/is-boxed (first to-group) %) working-non-group)]\\r\\n                   (if (not (empty? filter-group))\\r\\n                       (recur (apply conj  (rest to-group) filter-group )\\r\\n                              (apply conj grouping filter-group)\\r\\n                              (filter  \#(not (tgaa.algo.trial/is-boxed (first to-group) %)) working-non-group))\\r\\n                       (recur (rest to-group)\\r\\n                              grouping\\r\\n                              working-non-group))))))" "(def t (group (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 3) (tgaa.util.shared/canidates))))" "(count (\:grouping t))" "(count (\:group\\n         t))" "(count (\:non-group\\n         t))" "(def t \\r\\n  (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 2) (tgaa.util.shared/canidates))]\\r\\n    (loop [non-group est-can groups [] group-id 0]\\n      (if (empty? non-group)\\n        group\\n        (let [[group-res non-group-res  ] (make-group non-group)]\\n        (recur non-group-res  \\n               (apply conj groups (map \#(assoc % \:group group-id) group-res))\\n               (inc group-id)))))))" "\\r\\n(defn make-group [non-group]\\r\\n  (loop [to-group [(first non-group)] grouping [(first non-group)] working-non-group (rest non-group)]\\r\\n    (if (empty? to-group)\\r\\n      [grouping  working-non-group]\\r\\n      (let [filter-group (filter  \#(tgaa.algo.trial/is-boxed (first to-group) %) working-non-group)]\\r\\n        (if (not (empty? filter-group))\\r\\n          (recur (apply conj  (rest to-group) filter-group )\\r\\n                 (apply conj grouping filter-group)\\r\\n                 (filter  \#(not (tgaa.algo.trial/is-boxed (first to-group) %)) working-non-group))\\r\\n          (recur (rest to-group)\\r\\n                 grouping\\r\\n                 working-non-group))))))" "(def t \\r\\n  (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 2) (tgaa.util.shared/canidates))]\\r\\n    (loop [non-group est-can groups [] group-id 0]\\n      (if (empty? non-group)\\n        group\\n        (let [[group-res non-group-res  ] (make-group non-group)]\\n        (recur non-group-res  \\n               (apply conj groups (map \#(assoc % \:group group-id) group-res))\\n               (inc group-id)))))))" "t" "(def t \\r\\n  (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 2) (tgaa.util.shared/canidates))]\\r\\n    (loop [non-group est-can groups [] group-id 0]\\n      (if (empty? non-group)\\n        groups\\n        (let [[group-res non-group-res  ] (make-group non-group)]\\n        (recur non-group-res  \\n               (apply conj groups (map \#(assoc % \:group group-id) group-res))\\n               (inc group-id)))))))" "t" "\\r\\n(defn make-groups [cann-path]\\r\\n  (loop [non-group cann-path groups [] group-id 0]\\n    (if (empty? non-group)\\n      groups\\n      (let [[group-res non-group-res  ] (make-group non-group)]\\n        (recur non-group-res  \\n               (apply conj groups (map \#(assoc % \:group group-id) group-res))\\n               (inc group-id))))))" "(make-groups)" "(make-groups (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 2) (tgaa.util.shared/canidates)))" "\\r\\n(key 1)" "\\r\\n(key \\"1\\")" "\\r\\n(keyword 1)" "\\r\\n(keyword \\"1\\")" "\\r\\n(keyword (str 1))" "(defn make-groups [cann-path]\\r\\n  (loop [non-group cann-path groups [] meta-data {} group-id 0]\\r\\n    (if (empty? non-group)\\r\\n      [groups meta-data]\\r\\n      (let [[group-res non-group-res  ] (make-group non-group)]\\r\\n        (recur non-group-res  \\r\\n               (apply conj groups (map \#(assoc % \:group group-id) group-res))\\r\\n               (assoc meta-data (keyword (str group-id)) (count group-res))\\r\\n               (inc group-id))))))" "(make-groups (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 2) (tgaa.util.shared/canidates)))" "(defn make-groups [cann-path]\\r\\n  (loop [non-group cann-path groups [] meta-data {} group-id 0]\\r\\n    (if (empty? non-group)\\r\\n      [\:groups groups \:group-data meta-data]\\r\\n      (let [[group-res non-group-res  ] (make-group non-group)]\\r\\n        (recur non-group-res  \\r\\n               (apply conj groups (map \#(assoc % \:group group-id) group-res))\\r\\n               (assoc meta-data (keyword (str group-id)) (count group-res))\\r\\n               (inc group-id))))))" "(make-groups (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 2) (tgaa.util.shared/canidates)))" "(make-groups (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (tgaa.util.shared/canidates)))" "(filter \#(print %) {\:2 1, \:1 1, \:0 19})" "(filter \#(>\= (second) 4) {\:2 1, \:1 1, \:0 19})" "(filter \#(>\= (second %) 4) {\:2 1, \:1 1, \:0 19})" "(contains? 1 [1 2])" "(contains? [1 2] 1)" "(contains? [1 2] 2)" "(contains? [1 2 3 4] 2)" "(contains? [1 2 3 4] 4)" "(contains? [1 2 3 4] 3)" "(contains? {\:2 3\\n            } 3)" "(contains? {\:3 3\\n            } 3)" "(contain? {\:1 1} 1)" "(contains? {\:1 1} 1)" "(contains? {\:1 1} \:1)" "(phase/load-image)" " (phase/bootstrap)" "(phase/trapping)" "(phase/evaluation)" "(tgaa.algo.trial )" "(tgaa.algo.trial/salient-regions )" "(+ 1 10)" "(def groups (make-groups \\r\\n                 (filter \#(\= (tgaa.algo.ant/ant-trial-num %) (shared/get-num-trails)) \\r\\n                         (tgaa.util.shared/canidates))))" "(def groups (tgaa.algo.trial/make-groups \\r\\n                 (filter \#(\= (tgaa.algo.ant/ant-trial-num %) (shared/get-num-trails)) \\r\\n                         (tgaa.util.shared/canidates))))" "(def groups (tgaa.algo.trial/make-groups \\r\\n                 (filter \#(\= (tgaa.algo.ant/ant-trial-num %) (tgaa.util.shared/get-num-trails)) \\r\\n                         (tgaa.util.shared/canidates))))" "(def  min-conn-group-ids (filter \#(>\= (second %) shared/min-conn-thresh) (\:group-data groups)))" "(tgaa.algo.trial/salient-regions )" "( shared/min-conn-thresh)" "(def min-conn-group-ids (filter \#(>\= (second %)( tgaa.util.shared/min-conn-thresh)) (\:group-data groups)))" " (shared/add-salient-paths  (filter \#(contains? min-conn-group-ids (keyword (str (ant/ant-group %)))) groups))))" " (shared/add-salient-paths  (filter \#(contains? min-conn-group-ids (keyword (str (ant/ant-group %)))) groups))" " (tgaa.util.shared/add-salient-paths  (filter \#(contains? min-conn-group-ids (keyword (str (ant/ant-group %)))) groups))" " (tgaa.util.shared/add-salient-paths  (filter \#(contains? min-conn-group-ids (keyword (str (tgaa.algo.ant/ant-group %)))) groups))" " (tgaa.util.shared/add-salient-paths  (filter \#(contains? {\:1 1} (keyword (str (tgaa.algo.ant/ant-group %)))) groups))" "min-conn-group-ids" "groups" "( tgaa.util.shared/min-conn-thresh)" "(\:group-data groups)" "groups" "(\:group-data groups)" "(\:group-data group)" "(keys groups)" "(tgaa.algo.trial/salient-regions )" "(def groups (tgaa.algo.trial/make-groups \\r\\n                 (filter \#(\= (tgaa.algo.ant/ant-trial-num %) (tgaa.util.shared/get-num-trails)) \\r\\n                         (tgaa.util.shared/canidates))))" "groups" "(def min-conn-group-ids (filter \#(>\= (second %)( tgaa.util.shared/min-conn-thresh)) (\:group-data groups)))" " min-conn-group-ids" "(def min-conn-group-ids (into {} (flatten (filter \#(>\= (second %)( tgaa.util.shared/min-conn-thresh)) (\:group-data groups)))))" "(def min-conn-group-ids (flatten (filter \#(>\= (second %)( tgaa.util.shared/min-conn-thresh)) (\:group-data groups))))" " min-conn-group-ids" "(def min-conn-group-ids (into {} (flatten (filter \#(>\= (second %)( tgaa.util.shared/min-conn-thresh)) (\:group-data groups)))))" "(flatten (filter \#(>\= (second %)( tgaa.util.shared/min-conn-thresh)) (\:group-data groups)))" "(keys (flatten (filter \#(>\= (second %)( tgaa.util.shared/min-conn-thresh)) (\:group-data groups))))" "(flatten (filter \#(>\= (second %)( tgaa.util.shared/min-conn-thresh)) (\:group-data groups)))" "(into {} '(\:1 7))" "(flatten (map first (filter \#(>\= (second %)( tgaa.util.shared/min-conn-thresh)) (\:group-data groups))))" "(def min-conn-group-ids (flatten (map first (filter \#(>\= (second %)( tgaa.util.shared/min-conn-thresh)) (\:group-data groups))))" "(def min-conn-group-ids (flatten (map first (filter \#(>\= (second %)( tgaa.util.shared/min-conn-thresh)) (\:group-data groups)))))" " (tgaa.util.shared/add-salient-paths  (filter \#(contains? {\:1 1} (keyword (str (tgaa.algo.ant/ant-group %)))) groups))" "tgaa.util.shared/salient-paths" "(tgaa.util.shared/salient-paths)" " (tgaa.util.shared/add-salient-paths  (filter \#(contains? min-conn-group-ids (keyword (str (tgaa.algo.ant/ant-group %)))) groups))" "(tgaa.algo.trial/salient-regions)" "min-conn-group-ids" "(def groups (tgaa.algo.trial/make-groups \\r\\n                 (filter \#(\= (tgaa.algo.ant/ant-trial-num %) (tgaa.util.shared/get-num-trails)) \\r\\n                         (tgaa.util.shared/canidates))))" "(def min-conn-group-ids (flatten (map first (filter \#(>\= (second %)( tgaa.util.shared/min-conn-thresh)) (\:group-data groups)))))" " (tgaa.util.shared/add-salient-paths  (filter \#(contains? min-conn-group-ids (keyword (str (tgaa.algo.ant/ant-group %)))) groups))" "min-conn-group-ids" " (tgaa.util.shared/add-salient-paths  (filter \#(contains? min-conn-group-ids (keyword (str (tgaa.algo.ant/ant-group %)))) groups))" " (tgaa.util.shared/add-salient-paths  (filter \#(contains? '(\:1) min-conn-group-ids (keyword (str (tgaa.algo.ant/ant-group %)))) groups))" " (filter \#(contains? '(\:1) min-conn-group-ids (keyword (str (tgaa.algo.ant/ant-group %)))) groups)" " (filter \#(contains? min-conn-group-ids (keyword (str (tgaa.algo.ant/ant-group %)))) groups)" " (filter \#(contains? (into [] min-conn-group-ids) (keyword (str (tgaa.algo.ant/ant-group %)))) groups)" "(map \#(keyword (str (tgaa.algo.ant/ant-group %))) groups)" "(map \#((tgaa.algo.ant/ant-group %)) groups)" "(map \#(tgaa.algo.ant/ant-group %) groups)" "groups" " (filter \#(contains? (into [] min-conn-group-ids) (keyword (str (tgaa.algo.ant/ant-group %)))) (\:groups groups))" "(map \#(tgaa.algo.ant/ant-group %) (\:groups groups))" " (filter \#(contains? (into [] min-conn-group-ids) (keyword (str (tgaa.algo.ant/ant-group %)))) (\:groups groups))" " (filter \#(contains? (into [] min-conn-group-ids) (apply keyword (str (tgaa.algo.ant/ant-group %)))) (\:groups groups))" "(map \#(tgaa.algo.ant/ant-group %) (\:groups groups))" "(map \#(keyworkd (str tgaa.algo.ant/ant-group %)) (\:groups groups))" "(map \#(keyworkd (str (tgaa.algo.ant/ant-group %))) (\:groups groups))" "(map \#(keyword (str (tgaa.algo.ant/ant-group %))) (\:groups groups))" " (filter \#(contains? (into [] min-conn-group-ids) (apply keyword (str (tgaa.algo.ant/ant-group %)))) (\:groups groups))" " (filter \#(contains? (into [] min-conn-group-ids) (keyword (str 1))) (\:groups groups))" " (filter \#(contains? (into [] min-conn-group-ids) (keyword (str 1 (tgaa.algo.ant/ant-group %)))) (\:groups groups))" " (filter \#(contains? (into [] min-conn-group-ids) (do (println (tgaa.algo.ant/ant-group %)) (keyword (str 1))) (\:groups groups))" " (filter \#(contains? (into [] min-conn-group-ids) (do (println (tgaa.algo.ant/ant-group %)) (keyword (str 1)))) (\:groups groups))" " (filter \#(contains? (into [] min-conn-group-ids) (do (println (keyword (str tgaa.algo.ant/ant-group %))) (keyword (str 1)))) (\:groups groups))" "(first (\:groups groups))" "(tgaa.algo.ant/ant-group (first (\:groups groups)))" " (filter \#(contains? (into [] min-conn-group-ids) (do (println (keyword (str (tgaa.algo.ant/ant-group %)))) (keyword (str 1)))) (\:groups groups))" " (filter \#(contains? (into [] min-conn-group-ids) (keyword (str (tgaa.algo.ant/ant-group %)))) (\:groups groups))" " (filter \#(contains? \:1(keyword (str (tgaa.algo.ant/ant-group %)))) (\:groups groups))" " (filter \#(contains? [\:1] (keyword (str (tgaa.algo.ant/ant-group %)))) (\:groups groups))" " (filter \#(contains? [\:0] (keyword (str (tgaa.algo.ant/ant-group %)))) (\:groups groups))" " (filter \#(contains? [\:0] (do (keyword (str (tgaa.algo.ant/ant-group %)))(keyword (str (tgaa.algo.ant/ant-group %))))) (\:groups groups))" " (filter \#(contains? [\:0] (do (println (keyword (str (tgaa.algo.ant/ant-group %))))(keyword (str (tgaa.algo.ant/ant-group %))))) (\:groups groups))" "(contains? [\:1] \:1)" "(contains? {\:1 1} \:1)" "(def min-conn-group-ids (flatten (map first (filter \#(>\= (second %)( tgaa.util.shared/min-conn-thresh)) (\:group-data groups)))))" "(def min-conn-group-ids (flatten (filter \#(>\= (second %)( tgaa.util.shared/min-conn-thresh)) (\:group-data groups))))" " min-conn-group-ids" "(into [] min-conn-group-ids)" "(into {} min-conn-group-ids)" "(hash-map min-conn-group-ids)" "(apply hash-map min-conn-group-ids)" "(def min-conn-group-ids (apply hash-map (flatten (filter \#(>\= (second %)( tgaa.util.shared/min-conn-thresh)) (\:group-data groups)))))" "(def min-conn-group-ids (flatten (filter \#(>\= (second %)( tgaa.util.shared/min-conn-thresh)) (\:group-data groups))))" "(def min-conn-group-ids (apply hash-map (flatten (filter \#(>\= (second %)( tgaa.util.shared/min-conn-thresh)) (\:group-data groups)))))" " (filter \#(contains? (into [] min-conn-group-ids) (keyword (str 1 (tgaa.algo.ant/ant-group %)))) (\:groups groups))" " (filter \#(contains? min-conn-group-ids (keyword (str 1 (tgaa.algo.ant/ant-group %)))) (\:groups groups))" "min-conn-group-ids" " (filter \#(contains? min-conn-group-ids (keyword (str (tgaa.algo.ant/ant-group %)))) (\:groups groups))" "(tgaa.algo.trial/salient-regions)" "(in-ns 'tgaa.algo.trial\\n       )" "(def groups (make-groups \\r\\n                 (filter \#(\= (tgaa.algo.ant/ant-trial-num %) (shared/get-num-trails)))))" "(def groups (make-groups (filter \#(\= (tgaa.algo.ant/ant-trial-num %)) (shared/get-num-trails))))" "(def groups groups (make-groups \\r\\n                 (filter \#(\= (tgaa.algo.ant/ant-trial-num %) (shared/get-num-trails)) \\r\\n                         (tgaa.util.shared/canidates))))" "(def groups  (make-groups \\r\\n                 (filter \#(\= (tgaa.algo.ant/ant-trial-num %) (shared/get-num-trails)) \\r\\n                         (tgaa.util.shared/canidates))))" "(def min-conn-group-ids (apply hash-map (flatten (map first (filter \#(>\= (second %)( shared/min-conn-thresh)) (\:group-data groups))))))" "(def min-conn-group-ids (apply hash-map (flatten (filter \#(>\= (second %)( shared/min-conn-thresh)) (\:group-data groups)))))" "min-conn-group-ids" "(salient-regions)" "(process-image)" "(tgaa.util.shared/salient-paths)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(phase/evaluation)" "(salient-regions)" "(tgaa.util.shared/salient-paths)" "(tgaa.util.image/anim-trail-paths)" "(import 'java.awt.Color)" "(tgaa.util.image/anim-trail-paths)" "(phase/load-image)\\r\\n       (phase/bootstrap)\\r\\n       (phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(phase/load-image)\\r\\n       (phase/bootstrap)\\r\\n       (phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(filter \#(\= (tgaa.algo.ant/ant-trial-num %) 1)(tgaa.util.shared/canidates))" "(filter \#(\= (tgaa.algo.ant/ant-trial-num %) 0)(tgaa.util.shared/canidates))" "(map \#(tgaa.algo.ant/ant-trial-num %) (tgaa.util.shared/canidates))" "(filter \#(\= (tgaa.algo.ant/ant-trial-num %) 2)(tgaa.util.shared/canidates))" "(filter \#(\= (tgaa.algo.ant/ant-trial-num %) 75)(tgaa.util.shared/canidates))" "(shared/get-num-trails)" "(tgaa.util.shared/get-num-trails)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.shared/thresh)" "(tgaa.util.image/anim-trail-paths)" "(import 'java.awt.Color)" "(tgaa.util.image/anim-trail-paths)" "(filter \#(- tgaa.algo.ant/ant-trial-num 25)  tgaa.util.shared/canidates)" "(filter \#(\= tgaa.algo.ant/ant-trial-num 25)  tgaa.util.shared/canidates)" "(filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25)  tgaa.util.shared/canidates)" "(filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25)  (tgaa.util.shared/canidates))" "(map \#(\:path-length %) (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25)  (tgaa.util.shared/canidates)))" "(tgaa.util.image/anim-trail-paths)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(import 'java.awt.Color)" "(tgaa.util.image/anim-trail-paths)" "(reset\! t)" "(keyword? t)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/init-trail-state)" "(process-image)" "(tgaa.util.image/anim-trail-paths)" "(phase/load-image)" " (phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/get-config)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" " (phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" " (phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(map (tgaa.algo.ant/ant-trial-num) tgaa.util.shared/canidates)" "(map (tgaa.algo.ant/ant-trial-num %) tgaa.util.shared/canidates)" "(map \#(tgaa.algo.ant/ant-trial-num %) tgaa.util.shared/canidates)" "(map \#(tgaa.algo.ant/ant-trial-num %) (tgaa.util.shared/canidates))" "(phase/load-image)" " (phase/bootstrap)" "(phase/trapping)" "(tgaa.util.shared/config)" "(tgaa.util.shared/get-config)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" " (phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(import 'java.awt.Color)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" " (phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(phase/evaluation)" "(shared/salient-paths)" "(tgaa.util.shared/salient-paths)" "(count (tgaa.util.shared/salient-paths))" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" " (phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(take 10 [4 4])" "(take 1 [4 4])" "(take 10 [4 4])" "(take 4 (cycle [4 4]))" "(take 4 (cycle [4 5]))" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" " (phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" " (phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" " (phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" " (phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" " (phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" " (phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" " (phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" " (phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/init-trail-state)\\r\\n    (phase/load-image)\\r\\n       (phase/bootstrap)\\r\\n       (phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/init-trail-state)\\r\\n    (phase/load-image)\\r\\n       (phase/bootstrap)\\r\\n       (phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(import 'java.awt.Color)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/config)" "(tgaa.util.shared/get-config)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/get-config)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/init-trail-state)" "(tgaa.util.shared/get-config)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/init-trail-state)" "(tgaa.util.shared/get-config)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(phase/load-image)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.ant-path/init-trail-paths)" "(tgaa.util.ant-path/num-of-random-starts)" "(tgaa.util.ant-path/num-of-phero-starts)" "(in-ns 'tgaa.util.ant-path)" "(random-point 2)" "(random-point num-of-random-starts))" "(random-point num-of-random-starts)" "(random-point (num-of-random-starts))" "(phero-points \\r\\n           (num-of-phero-starts))" "(num-of-phero-starts)" "(phero-points \\r\\n           (num-of-phero-starts))" "(phero-points 4)" "(phero-points 1)" "(or (empty? (shared/canidates)) (> 1 num))" "(empty? (shared/canidates))" "(phero-points 4)" "(def bias-paths (take 10 (cycle (shuffle (shared/canidates)))))" "bias-paths" "(def  lengths (map \#(ant/ant-path-length %) bias-paths))" "lengths" "(count lengths)" "(def           start-loc (map \#(ant/path-loc-at-time %1 %2)\\r\\n                         bias-paths\\r\\n                         (map rand-int lengths)))" "start-loc" "(phero-points 4)" "    (let [bias-paths (take 5 (cycle (shuffle (shared/canidates))))\\r\\n          lengths (map \#(ant/ant-path-length %) bias-paths)\\r\\n          start-loc (map \#(ant/path-loc-at-time %1 %2)\\r\\n                         bias-paths\\r\\n                         (map rand-int lengths))]\\r\\n      \\r\\n    start-loc)" "(phero-points 4)" "(in-ns 'tgaa.algo.core)" "(tgaa.util.ant-path/init-trail-paths)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/thresh)" "(in-ns 'tgaa.algo.trial/trap-escaped-thresh [])" "(in-ns 'tgaa.algo.trial/trap-escaped-thresh)" "(trap-escaped-thresh nil)" "(tgaa.algo.trial/trap-escaped-thresh nil)" "(tgaa.algo.trial/trap-escaped-thresh [])" "(in-ns 'tgaa.algo.phases)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(in-ns 'tgaa.algo.phases)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(import 'java.awt.Color)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/get-config)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(map \#(tgaa.algo.ant/ant-path-length %)(filter \#(\= 25 (tgaa.util.shared/trial-num %)) (tgaa.util.shared/canidates)))" "(map \#(tgaa.algo.ant/ant-path-length %)(filter \#(\= 25 (tgaa.algo.ant/ant-trial-num %)) (tgaa.util.shared/canidates)))" "(tgaa.util.shared/get-config)" "(tgaa.util.shared/config (tgaa.util.shared/get-config))" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(map \#(tgaa.algo.ant/ant-path-length %)(filter \#(\= 25 (tgaa.algo.ant/ant-trial-num %)) (tgaa.util.shared/canidates)))" "(map \#(tgaa.algo.ant/ant-path-length %)(filter \#(\= 24 (tgaa.algo.ant/ant-trial-num %)) (tgaa.util.shared/canidates)))" "(tgaa.util.image/anim-trail-paths)" "(map \#(tgaa.algo.ant/ant-path-length %)(filter \#(\= 24 (tgaa.algo.ant/ant-trial-num %)) (tgaa.util.shared/canidates)))" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(keyword 1)" "(keyword (str 1))" "(assoc {\:1 1 \:2 2} \:3 2)" "(assoc {\:1 1 \:2 2} \:3 3)" "(assoc {\:1 1 \:2 2} \:2 [3])" "(defn trial-info \\r\\n  [key value]\\r\\n  (if-not (or (nill? key) (nil? value))\\r\\n    (let [trail-key (keyword (str (trial-num)))\\r\\n          info-run (if (nil? (\:trial-log  @trial-state ))\\r\\n                             {}\\r\\n                             (\:trial-log  @trial-state ))\\r\\n          info-trial (if (nil? (trail-key info-run))\\r\\n                       {}\\r\\n                       (trail-key info-run))]\\r\\n      ((reset\! trial-state  (assoc @trail-state \:trail-log  (assoc info-run trial-key (assoc info-trial key value))))))))" "(defn trial-info \\r\\n  [key value]\\r\\n  (if-not (or (nil? key) (nil? value))\\r\\n    (let [trail-key (keyword (str (trial-num)))\\r\\n          info-run (if (nil? (\:trial-log  @trial-state ))\\r\\n                             {}\\r\\n                             (\:trial-log  @trial-state ))\\r\\n          info-trial (if (nil? (trail-key info-run))\\r\\n                       {}\\r\\n                       (trail-key info-run))]\\r\\n      ((reset\! trial-state  (assoc @trail-state \:trail-log  (assoc info-run trial-key (assoc info-trial key value))))))))" "(in-ns 'tgaa.util.shared)" "(defn trial-info \\r\\n  [key value]\\r\\n  (if-not (or (nil? key) (nil? value))\\r\\n    (let [trail-key (keyword (str (trial-num)))\\r\\n          info-run (if (nil? (\:trial-log  @trial-state ))\\r\\n                             {}\\r\\n                             (\:trial-log  @trial-state ))\\r\\n          info-trial (if (nil? (trail-key info-run))\\r\\n                       {}\\r\\n                       (trail-key info-run))]\\r\\n      ((reset\! trial-state  (assoc @trail-state \:trail-log  (assoc info-run trial-key (assoc info-trial key value))))))))" "(trial-info \:test 4)" "(keyword (str (trial-num)))" "(if (nil? (\:trial-log  @trial-state ))\\r\\n                             {}\\r\\n                             (\:trial-log  @trial-state ))" "(\:0 {})" "(trial-info \:test 4)" "(+ 1 1)" "(trial-info \:test 4)" "(trial-info \:test2 4)" "(trial-info \:t 4)" "@trial-state" "(trial-info \:tw 4)" "(trial-info \:tw 43)" "(trial-info \:tw 4)" "@trial-state" "(trial-info \:tw 4)" "(trial-info \:twq 4)" "(trial-info \:twqw 4q)" "(trial-info \:twqw 132323)" "(inc-trial)" "(trial-info \:twqw 132323)" "(trial-info \:twqw 4q)" "(trial-info \:tw 4)" "(gensym)" "(str \\"error\\" gensym)" "(str \\"error\\" (gensym))" "(trial-info-error \\"this is an error\\")" "(trial-info \:tw 4)" "(trial-info-error \\"this is an error\\")" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(tgaa.util.shared/init-trail-state)" " (phase/load-image)" " (phase/bootstrap)" "(phase/trapping)" "(tgaa.util.shared/trial-logs)" "(tgaa.util.image/anim-trail-paths)" "(import 'java.awt.Color)" "(tgaa.util.image/anim-trail-paths)" "(sort \#(compare (last %1) (last %2)) (tgaa.util.image/anim-trail-paths))" "(sort \#(compare (last %1) (last %2)) (tgaa.util.shared/trial-logs))" "(name \:1)" "(class (name \:1))" "(sort \#(name %) (tgaa.util.shared/trial-logs))" "(name \:1)" "(int (name \:1))" "(Integer (name \:1))" "(Integer. (name \:1))" "(sort \#(< (Integer. name %1) (Integer. name %2)) (tgaa.util.shared/trial-logs))" "(sort \#(< (Integer. (name %1)) (Integer. (name %2))) (tgaa.util.shared/trial-logs))" "(sort \#(< (Integer. (name (first %1))) (Integer. (first (name %2)))) (tgaa.util.shared/trial-logs))" "(sort \#(< (Integer. (name (first %1))) (Integer. (name (first %2)))) (tgaa.util.shared/trial-logs))" "(tgaa.util.shared/trial-logs)" "(sort \#(< (Integer. (name (first %1))) (Integer. (name (first %2)))) (tgaa.util.shared/trial-logs))" "(tgaa.util.shared/trial-logs)" "(sort \#(< (Integer. (name (first %1))) (Integer. (name (first %2)))) (tgaa.util.shared/trial-logs))" "tgaa.util.shared/trial-state" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.shared/trial-logs)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/trial-logs)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.shared/trial-logs)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/trial-logs)" "(tgaa.util.shared/init-trail-state)" "  (phase/load-image)" "(phase/bootstrap)" " (phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(import 'java.awt.Color)" "(tgaa.util.image/anim-trail-paths)" "(phase/evaluation)" "(keys (phase/evaluation))" "(\:salient-paths (phase/evaluation))" "(defn create-ant-path[]\\r\\n  \\"Creates init ant path datastruct\\"\\r\\n  {\:id (gensym)})" "(create-ant-path)" "(\:id (create-ant-path))" "(\= (\:id (create-ant-path)) (\:id (create-ant-path)) )" "(map \:id [{\:id 1} {\:id 2}])" "(defn make-groups [cann-path]\\r\\n  (loop [non-group cann-path groups [] meta-data {} group-id 0]\\r\\n    (if (empty? non-group)\\r\\n      {\:group-id (map \:id groups) \:group-data meta-data}\\r\\n      (let [[group-res non-group-res ] (make-group non-group)]\\r\\n        (recur non-group-res  \\r\\n               (apply conj groups (map \#(assoc % \:group group-id) group-res))\\r\\n               (assoc meta-data (keyword (str group-id)) (count group-res))\\r\\n               (inc group-id))))))" "(in-ns tgaa.algo.trial)" "(in-ns 'tgaa.algo.trial)" "(defn make-groups [cann-path]\\r\\n  (loop [non-group cann-path groups [] meta-data {} group-id 0]\\r\\n    (if (empty? non-group)\\r\\n      {\:group-id (map \:id groups) \:group-data meta-data}\\r\\n      (let [[group-res non-group-res ] (make-group non-group)]\\r\\n        (recur non-group-res  \\r\\n               (apply conj groups (map \#(assoc % \:group group-id) group-res))\\r\\n               (assoc meta-data (keyword (str group-id)) (count group-res))\\r\\n               (inc group-id))))))" "(make-groups (shared/canidates))" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(in-ns 'tgaa06172018.core)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(phase/evaluation)" "(tgaa.util.shared/salient-ids)" "(tgaa.util.shared/salient-paths)" "(tgaa.util.shared/salient-results)" "(keys @tgaa.util.shared/trial-state)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "  (phase/bootstrap)" "(phase/trapping)" "(do (phase/evaluation) 1)" "(keys @tgaa.util.shared/trial-state)" "(\:salient-ids @tgaa.util.shared/trial-state)" "(tgaa.util.shared/salient-results)" "(tgaa.util.shared/salient-paths)" "(tgaa.util.shared/salient-ids)" "(process-image)" "(\:salient-ids @tgaa.util.shared/trial-state)" "(process-image)" "(tgaa.util.shared/salient-ids)" "(tgaa.util.shared/salient-results)" "(tgaa.util.shared/salient-ids)" "(tgaa.util.shared/salient-results)" "(process-image)" "(tgaa.util.shared/salient-results)" "(tgaa.util.shared/salient-ids)" "(tgaa.util.image/anim-trail-paths)" "(import 'java.awt.Color)" "(tgaa.util.image/anim-trail-paths)" "(process-image)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "  (phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(process-image)" "(tgaa.util.image/anim-trail-paths)" " (map doall [tgaa.util.shared/init-trail-state phase/load-image phase/bootstrap phase/trapping phase/evaluation])" " (map doall ['tgaa.util.shared/init-trail-state 'phase/load-image 'phase/bootstrap 'phase/trapping 'phase/evaluation])" " (map doall ['(tgaa.util.shared/init-trail-state) '(phase/load-image) '(phase/bootstrap) '(phase/trapping) '(phase/evaluation)])" " (map doall [(tgaa.util.shared/init-trail-state) (phase/load-image) (phase/bootstrap) (phase/trapping) (phase/evaluation)])" "(tgaa.util.image/anim-trail-paths)" "(import 'java.awt.Color)" "(tgaa.util.image/anim-trail-paths)" "(filter \#(\= (tgaa.algo.ant/ant-trial-num %) 1) (tgaa.util.shared/canidates))" "(filter \#(\= (tgaa.algo.ant/ant-trial-num %) 2) (tgaa.util.shared/canidates))" "(tgaa.util.shared/canidates 2)" "(tgaa.util.shared/canidates 3)" "(tgaa.util.shared/canidates 2\\n                            )" "(tgaa.util.shared/canidates)" "(process-image)" "(tgaa.util.shared/canidates 2)" "(map \#([(tgaa.algo.ant/ant-end-point %) (tgaa.algo.ant/ant-start-point %)])   tgaa.util.shared/canidates 2)" "(map \#([(tgaa.algo.ant/ant-end-point %) (tgaa.algo.ant/ant-start-point %)])   (tgaa.util.shared/canidates 2))" "(map \#((tgaa.algo.ant/ant-end-point %) (tgaa.algo.ant/ant-start-point %])   (tgaa.util.shared/canidates 2))" "(map \#((tgaa.algo.ant/ant-end-point %) (tgaa.algo.ant/ant-start-point %))   (tgaa.util.shared/canidates 2))" "(map \#((vector (tgaa.algo.ant/ant-end-point %) (tgaa.algo.ant/ant-start-point %)) )  (tgaa.util.shared/canidates 2))" "(map \#((tgaa.algo.ant/ant-end-point %))  (tgaa.util.shared/canidates 2))" "(tgaa.util.shared/canidates 2)" "(map \#(tgaa.algo.ant/ant-end-point %)  (tgaa.util.shared/canidates 2))" "(map \#(concat (tgaa.algo.ant/ant-end-point %) (tgaa.algo.ant/ant-end-point %)) (tgaa.util.shared/canidates 2))" "(map \#(concat (tgaa.algo.ant/ant-end-point %) (tgaa.algo.ant/ant-start-point %)) (tgaa.util.shared/canidates 2))" "(map \#(vector (tgaa.algo.ant/ant-end-point %) (tgaa.algo.ant/ant-start-point %)) (tgaa.util.shared/canidates 2))" "(map \#(concat (tgaa.algo.ant/ant-end-point %) (tgaa.algo.ant/ant-start-point %)) (tgaa.util.shared/canidates 2))" "(split 2 (map \#(concat (tgaa.algo.ant/ant-end-point %) (tgaa.algo.ant/ant-start-point %)) (tgaa.util.shared/canidates 2)))" "(flatten (map \#(concat (tgaa.algo.ant/ant-end-point %) (tgaa.algo.ant/ant-start-point %)) (tgaa.util.shared/canidates 2)))" "(split 2 (flatten (map \#(concat (tgaa.algo.ant/ant-end-point %) (tgaa.algo.ant/ant-start-point %)) (tgaa.util.shared/canidates 2))))" "(partition 2 (flatten (map \#(concat (tgaa.algo.ant/ant-end-point %) (tgaa.algo.ant/ant-start-point %)) (tgaa.util.shared/canidates 2))))" "(partition 2 (flatten (map \#(concat (tgaa.algo.ant/ant-end-point %) (tgaa.algo.ant/ant-start-point %)) (tgaa.util.shared/canidates 20))))" "(defn make-convex-hull\\r\\n  \\"Make a convex hull for a set of points, all of which are assumed to have positive x and y\\r\\ncoordinates. Returns a vector of lines, each of which is a sequence of two points\\"\\r\\n  [points]\\r\\n  (let [starting-point (find-starting-point points)\\r\\n        remaining-points (remove \#(\= % starting-point) points)\\r\\n        working-set (sort angle-comparator remaining-points)]\\r\\n    (loop [remaining-points working-set\\r\\n           p1 starting-point\\r\\n           p2 (first working-set)\\r\\n           p3 (second working-set)\\r\\n           hull []]\\r\\n      (if (\= p3 (last working-set))\\r\\n        ; We have reached the end of the set, return the full hull\\r\\n        (if (left-turn? p1 p2 p3)\\r\\n          (concat hull [[p1 p2] [p2 p3] [p3 starting-point]])\\r\\n          (concat hull [[p1 p3] [p3 starting-point]]))\\r\\n\\r\\n        ; Does this form a left turn?\\r\\n        (if (left-turn? p1 p2 p3)\\r\\n          (recur (rest remaining-points) p2 p3 (nth remaining-points 2) (conj hull [p1 p2]))\\r\\n          (recur (rest remaining-points) p1 p3 (nth remaining-points 2) hull))))))" "(map \#((tgaa.algo.ant/ant-end-point %))  (tgaa.util.shared/canidates 2))" "(partition 2 (flatten (map \#(concat (tgaa.algo.ant/ant-end-point %) (tgaa.algo.ant/ant-start-point %)) (tgaa.util.shared/canidates 20))))" "(defn make-convex-hull\\r\\n  \\"Make a convex hull for a set of points, all of which are assumed to have positive x and y\\r\\ncoordinates. Returns a vector of lines, each of which is a sequence of two points\\"\\r\\n  [points]\\r\\n  (let [points (partition 2 (flatten (map \#(concat (tgaa.algo.ant/ant-end-point %) (tgaa.algo.ant/ant-start-point %)) (tgaa.util.shared/canidates 20))))\\n        starting-point [72 431]\\r\\n        remaining-points (remove \#(\= % starting-point) points)\\r\\n        working-set (sort angle-comparator remaining-points)]\\r\\n    (loop [remaining-points working-set\\r\\n           p1 starting-point\\r\\n           p2 (first working-set)\\r\\n           p3 (second working-set)\\r\\n           hull []]\\r\\n      (if (\= p3 (last working-set))\\r\\n        ; We have reached the end of the set, return the full hull\\r\\n        (if (left-turn? p1 p2 p3)\\r\\n          (concat hull [[p1 p2] [p2 p3] [p3 starting-point]])\\r\\n          (concat hull [[p1 p3] [p3 starting-point]]))\\r\\n\\r\\n        ; Does this form a left turn?\\r\\n        (if (left-turn? p1 p2 p3)\\r\\n          (recur (rest remaining-points) p2 p3 (nth remaining-points 2) (conj hull [p1 p2]))\\r\\n          (recur (rest remaining-points) p1 p3 (nth remaining-points 2) hull))))))" "(partition 2 (flatten (map \#(concat (tgaa.algo.ant/ant-end-point %) (tgaa.algo.ant/ant-start-point %)) (tgaa.util.shared/canidates 20))))" "(tgaa.algo.convexhull/convex-hull (partition 2 (flatten (map \#(concat (tgaa.algo.ant/ant-end-point %) (tgaa.algo.ant/ant-start-point %)) (tgaa.util.shared/canidates 20)))))" "(tgaa.algo.convexhull/convex-hull [[1 1][2 2][3 3]])" "(tgaa.algo.convexhull/convex-hull [1 1][2 2][3 3])" "(import 'tgaa.hull.ConvexHull)" "(import 'ConvexHull)" "(import 'tgaa.hull.ConvexHull)" "(tgaa.util.shared/init-trail-state)" "(process-image )" "(process-image)" "(tgaa.util.image/anim-trail-paths)" "(import 'java.awt.Color)" "(tgaa.util.image/anim-trail-paths)" "(process-image)" "(tgaa.util.image/anim-trail-paths)" "(import 'java.awt.Color)" "(tgaa.util.image/anim-trail-paths)" "(import 'tgaa.hull.Point)" "(Point.  2 2)" "(map tgaa.struct.ant/ant-end-point(tgaa.struct.shared/canidates 24))" "(map (apply Point. tgaa.struct.ant/ant-end-point %) (tgaa.struct.shared/canidates 24))" "(map \#(Point. (first %) (second %))(map tgaa.struct.ant/ant-end-point(tgaa.struct.shared/canidates 24)))" "(let [points (map \#(Point. (first %) (second %))(map tgaa.struct.ant/ant-end-point(tgaa.struct.shared/canidates 24)))]" "(import 'tgaa.hull.ConvexHull)" "(let [points (map \#(Point. (first %) (second %))(map tgaa.struct.ant/ant-end-point(tgaa.struct.shared/canidates 24)))\\n      cnvx (ConvexHull. points)]\\n  (. cnvx getConvexHull))" "(let [points (map \#(Point. (first %) (second %))(map tgaa.struct.ant/ant-end-point(tgaa.struct.shared/canidates 24)))\\n      cnvx (ConvexHull. to-array( points))]\\n  (. cnvx getConvexHull))" "(class (map \#(Point. (first %) (second %))(map tgaa.struct.ant/ant-end-point(tgaa.struct.shared/canidates 24))" "(class (map \#(Point. (first %) (second %))(map tgaa.struct.ant/ant-end-point(tgaa.struct.shared/canidates 24))))" "(class  (to-array (map \#(Point. (first %) (second %))(map tgaa.struct.ant/ant-end-point(tgaa.struct.shared/canidates 24)))))" "(class  ^tgaa.hull.Point (to-array (map \#(Point. (first %) (second %))(map tgaa.struct.ant/ant-end-point(tgaa.struct.shared/canidates 24)))))" "(class  ^tgaa.hull.Point (into-array tgaa.hull.Point (map \#(Point. (first %) (second %))(map tgaa.struct.ant/ant-end-point(tgaa.struct.shared/canidates 24)))))" "(let [points (map \#(Point. (first %) (second %))(map tgaa.struct.ant/ant-end-point(tgaa.struct.shared/canidates 24)))\\n      cnvx (ConvexHull. (into-array tgaa.hull.Point ( points)))]\\n  (. cnvx getConvexHull))" "(let [points (map \#(Point. (first %) (second %))(map tgaa.struct.ant/ant-end-point(tgaa.struct.shared/canidates 24)))\\n      cnvx (ConvexHull. (into-array tgaa.hull.Point points))]\\n  (. cnvx getConvexHull))" "(let [points (map \#(Point. (first %) (second %))(map tgaa.struct.ant/ant-end-point(tgaa.struct.shared/canidates (shared/trial-num))))\\n      cnvx (ConvexHull. (into-array tgaa.hull.Point points))]\\n  (. cnvx getConvexHull))" "(let [points (map \#(Point. (first %) (second %))(map tgaa.struct.ant/ant-end-point(tgaa.struct.shared/canidates (shared/get-num-trails ))))\\n      cnvx (ConvexHull. (into-array tgaa.hull.Point points))]\\n  (. cnvx getConvexHull))" "(let [points (map \#(Point. (first %) (second %))\\n                  (map tgaa.struct.ant/ant-end-point(tgaa.struct.shared/canidates (decb(shared/get-num-trails )))))\\n      cnvx (ConvexHull. (into-array tgaa.hull.Point points))]\\n  (. cnvx getConvexHull))" "(let [points (map \#(Point. (first %) (second %))\\n                  (map tgaa.struct.ant/ant-end-point(tgaa.struct.shared/canidates (dec(shared/get-num-trails )))))\\n      cnvx (ConvexHull. (into-array tgaa.hull.Point points))]\\n  (. cnvx getConvexHull))" "(defn convex-hull [paths]\\r\\n  (let[points (map \#(Point. (first %) (second %))(map ant/ant-end-point paths))\\r\\n       cnvx (ConvexHull. (into-array tgaa.hull.Point points))]\\r\\n    (. cnvx getConvexHull))" "(defn convex-hull [paths]\\r\\n  (let[points (map \#(Point. (first %) (second %))(map ant/ant-end-point paths))\\r\\n       cnvx (ConvexHull. (into-array tgaa.hull.Point points))]\\r\\n    (. cnvx getConvexHull)))" "(defn convex-hull [paths]\\r\\n  (let[points (map \#(Point. (first %) (second %))(map tgaa.struct.ant/ant-end-point paths))\\r\\n       cnvx (ConvexHull. (into-array tgaa.hull.Point points))]\\r\\n    (. cnvx getConvexHull)))" "(defn boundary-result[]\\r\\n  (convex-hull (shared/canidates (dec(shared/get-num-trails )))))" "(boundary-result)" "(process-image)" "(tgaa.util.image/anim-trail-paths)" "(import 'java.awt.Color)" "(tgaa.util.image/anim-trail-paths)" "(import 'java.awt.Polygon)" "(Polygon.)" " (tgaa.struct.shared/canidates 24)" " (map tgaa.struct.ant/ant-end-point (tgaa.struct.shared/canidates 24))" "tgaa06172018.analysis" "tgaa.algo.analysis" "tgaa.algo.analysis/salient-regions" "tgaa.algo.analysis/final-boundary" "(tgaa.algo.analysis/final-boundary)" "(map \#(. getY %) (tgaa.algo.analysis/final-boundary))" "(map \#(. % getY ) (tgaa.algo.analysis/final-boundary))" "(map \#(. % getY ) (tgaa.algo.analysis/final-boundary))\\n(map \#(. % getY ) (tgaa.algo.analysis/final-boundary))" "(Polygon. \\n  (map \#(. % getY ) (tgaa.algo.analysis/final-boundary))\\n  (map \#(. % getY ) (tgaa.algo.analysis/final-boundary))\\n  (count (tgaa.algo.analysis/final-boundary)))" "(Polygon. \\n  (into-array Integer (map \#(. % getY ) (tgaa.algo.analysis/final-boundary)))\\n  (into-array Integer (map  \#(. % getY ) (tgaa.algo.analysis/final-boundary)))\\n  (count (tgaa.algo.analysis/final-boundary)))" "(class (into-array Integer (map \#(. % getY ) (tgaa.algo.analysis/final-boundary))))" "(class (into-array int (map \#(. % getY ) (tgaa.algo.analysis/final-boundary))))" "(class (into-array java.lang.Integer (map \#(. % getY ) (tgaa.algo.analysis/final-boundary))))" "(map \#(. % getY ) (tgaa.algo.analysis/final-boundary))" "(class (map \#(. % getY ) (tgaa.algo.analysis/final-boundary)))" "(to-array (map \#(. % getY ) (tgaa.algo.analysis/final-boundary)))" "(Polygon. \\n  (in-array (map \#(. % getY ) (tgaa.algo.analysis/final-boundary)))\\n  (in-array (map  \#(. % getY ) (tgaa.algo.analysis/final-boundary)))\\n  (count (tgaa.algo.analysis/final-boundary)))" "(map \#(. % getY ) (tgaa.algo.analysis/final-boundary))" "(to-array (map \#(. % getY ) (tgaa.algo.analysis/final-boundary)))" "(to-array (map \#(Integer (. % getY )) (tgaa.algo.analysis/final-boundary)))" "(to-array (map \#(int (. % getY )) (tgaa.algo.analysis/final-boundary)))" "(into-array Integer (map \#(int (. % getY )) (tgaa.algo.analysis/final-boundary)))" "(Polygon. \\n  (into-array Integer  (map \#(int (. % getY )) (tgaa.algo.analysis/final-boundary)))\\n  (into-array Integer  (map  \#(int (. % getY )) (tgaa.algo.analysis/final-boundary)))\\n  (count (tgaa.algo.analysis/final-boundary)))" "(into-array Integer  (map \#(int (. % getY )) (tgaa.algo.analysis/final-boundary)))" "(Polygon. \\n  (into-array Integer  (map \#(int (. % getY )) (tgaa.algo.analysis/final-boundary)))\\n  (into-array Integer  (map  \#(int (. % getY )) (tgaa.algo.analysis/final-boundary)))\\n  (count (tgaa.algo.analysis/final-boundary)))" "(count (tgaa.algo.analysis/final-boundary))" "(Polygon. \\n  (into-array Integer  (map \#(int (. % getY )) (tgaa.algo.analysis/final-boundary)))\\n  (into-array Integer  (map  \#(int (. % getY )) (tgaa.algo.analysis/final-boundary)))\\n  (count (tgaa.algo.analysis/final-boundary)))" "(Polygon. \\n  (in-array (map \#(int (. % getY )) (tgaa.algo.analysis/final-boundary)))\\n  (in-array  (map  \#(int (. % getY )) (tgaa.algo.analysis/final-boundary)))\\n  (count (tgaa.algo.analysis/final-boundary)))" "(in-array (map \#(int (. % getY )) (tgaa.algo.analysis/final-boundary)))" "(to-array (map \#(int (. % getY )) (tgaa.algo.analysis/final-boundary)))" "(Polygon. \\n  (to-array (map \#(int (. % getY )) (tgaa.algo.analysis/final-boundary)))\\n  (to-array  (map  \#(int (. % getY )) (tgaa.algo.analysis/final-boundary)))\\n  (count (tgaa.algo.analysis/final-boundary)))" "(Polygon. \\n  (into-array Integer  (map \#(int (. % getY )) (tgaa.algo.analysis/final-boundary)))\\n  (into-array Integer  (map  \#(int (. % getY )) (tgaa.algo.analysis/final-boundary)))\\n  (count (tgaa.algo.analysis/final-boundary)))" "(into-array Integer  (map \#(int (. % getY )) (tgaa.algo.analysis/final-boundary)))" "(class (into-array Integer  (map \#(int (. % getY )) (tgaa.algo.analysis/final-boundary))))" "(Polygon. \\n  (into-array int  (map \#(int (. % getY )) (tgaa.algo.analysis/final-boundary)))\\n  (into-array int  (map  \#(int (. % getY )) (tgaa.algo.analysis/final-boundary)))\\n  (count (tgaa.algo.analysis/final-boundary)))" "(Polygon. \\n  (into-array Integer  (map \#(int (. % getY )) (tgaa.algo.analysis/final-boundary)))\\n  (into-array Integer  (map  \#(int (. % getY )) (tgaa.algo.analysis/final-boundary)))\\n  (count (tgaa.algo.analysis/final-boundary)))" "(Polygon. \\n  (into-array Integer  (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary)))\\n  (into-array Integer  (map  \#(int (. % getY )) (tgaa.algo.analysis/final-boundary)))\\n  (count (tgaa.algo.analysis/final-boundary)))" "(Polygon. \\n  (into-array Integer  (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary)))\\n  (into-array Integer  (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary)))\\n  (count (tgaa.algo.analysis/final-boundary)))" "(class (into-array Integer  (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary))))" "(into-array Integer  (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary)))" "(Polygon. (into-array Integer [1 2 3]) (into-array Integer [1 2 3]) 3)" "[(into-array Integer [1 2 3]) (into-array Integer [1 2 3])]" "(Polygon. \\n  (into-array Integer  (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary)))\\n  (into-array Integer  (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary)))\\n  (count (tgaa.algo.analysis/final-boundary)))" "(into-array Integer  (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary)))" "[(into-array Integer  (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary))) (into-array Integer  (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary)))]" "(Polygon. \\n  (into-array Integer  (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary)))\\n  (into-array Integer  (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary)))\\n  (count (tgaa.algo.analysis/final-boundary)))" "(def p (Polygon.))" "p" "(. p addPoint 1 1)" "p" "(. p getBounds)" "(let [polygon (Polygon.)\\n      xpnts        (into-array Integer  (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary)))\\n      ypnts      (into-array Integer  (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary)))]\\n  (map (. polygon  addPoint %1 %2) xpnts ypnts))" "(let [polygon (Polygon.)\\n      xpnts        (into-array Integer  (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary)))\\n      ypnts      (into-array Integer  (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary)))]\\n  (map \#(. polygon  addPoint %1 %2) xpnts ypnts))" "(let [polygon (Polygon.)\\n      xpnts (into-array Integer  (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary)))\\n      ypnts (into-array Integer  (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary)))\\n      _ (map \#(. polygon  addPoint %1 %2) xpnts ypnts)]\\n  polygon)" "(def p (let [polygon (Polygon.)\\n             xpnts (into-array Integer  (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary)))\\n             ypnts (into-array Integer  (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary)))\\n             _ (map \#(. polygon  addPoint %1 %2) xpnts ypnts)]\\n         polygon))" "(. p getBoundingBox)" "(. p getBounds2D)" "(. p toString)" "(into-array Integer  (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary)))" "(def p (let [polygon (Polygon.)\\n             xpnts (into-array Integer  (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary)))\\n             ypnts (into-array Integer  (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary)))\\n             _ (map \#(. polygon  addPoint %1 %2) xpnts ypnts)\\n             _ (map \#(println %1 %2) xpnts ypnts)]\\n         polygon))" "p" "(def p (let [polygon (Polygon.)\\n             xpnts (into-array Integer  (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary)))\\n             ypnts (into-array Integer  (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary)))\\n             _ (map \#(. polygon  addPoint %1 %2) xpnts ypnts)\\n             val (map \#(println %1 %2) xpnts ypnts)]\\n         polygon))" "(def p (let [polygon (Polygon.)\\n             xpnts (into-array Integer  (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary)))\\n             ypnts (into-array Integer  (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary)))\\n             _ (map \#(. polygon  addPoint %1 %2) xpnts ypnts)\\n             val (print xpnts ypnts)]\\n         polygon))" "(def p (let [polygon (Polygon.)\\n             xpnts (into-array Integer  (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary)))\\n             ypnts (into-array Integer  (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary)))\\n             _ (map \#(. polygon  addPoint %1 %2) xpnts ypnts)\\n             val (print (first xpnts) ypnts)]\\n         polygon))" "(def p (let [polygon (Polygon.)\\n             xpnts (into-array Integer  (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary)))\\n             ypnts (into-array Integer  (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary)))\\n             _ (map (fn [x y] (. polygon  addPoint x y) xpnts ypnts))]\\n         polygon))" "(. p getBoundingBox)" "(def i (mi/copy (shared/image-ref)))" "(def i (mikera.image.core/copy (tgaa.struct.shared/image-ref)))" "(def g (. i createGraphics))" "(. g setColor (. Color \\"BLUE\\"))" "(. g setColor (. Color BLUE))" "(. g setStroke (BasicStroke. line-width))" "(. g setStroke (BasicStroke. 2))" "(. g setStroke (java.awt.BasicStroke. 2))" "(. g drawPolygon p)" "(show i)" "(tgaa.util.image/show-image i)" "(mikera.image.core/show i)" "(let [i (mikera.image.core/copy (tgaa.struct.shared/image-ref))\\n      g (. i createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (BasicStroke. 4))\\n      polygon (Polygon.)\\r\\n      xpnts (into-array Integer  (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary)))\\r\\n      ypnts (into-array Integer  (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary)))\\r\\n      _ (map (fn [x y] (. polygon  addPoint x y) xpnts ypnts))\\n      (. g drawPolygon p)]\\n  (mikera.image.core/show i))" "(let [i (mikera.image.core/copy (tgaa.struct.shared/image-ref))\\n      g (. i createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (BasicStroke. 4))\\n      polygon (Polygon.)\\r\\n      xpnts (into-array Integer  (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary)))\\r\\n      ypnts (into-array Integer  (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary)))\\r\\n      _ (map (fn [x y] (. polygon  addPoint x y) xpnts ypnts))\\n      _ (. g drawPolygon p)]\\n  (mikera.image.core/show i))" "(let [i (mikera.image.core/copy (tgaa.struct.shared/image-ref))\\n      g (. i createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (java.awt.BasicStroke. 4))\\n      polygon (Polygon.)\\r\\n      xpnts (into-array Integer  (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary)))\\r\\n      ypnts (into-array Integer  (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary)))\\r\\n      _ (map (fn [x y] (. polygon  addPoint x y) xpnts ypnts))\\n      _ (. g drawPolygon p)]\\n  (mikera.image.core/show i))" "(let [i (mikera.image.core/copy (tgaa.struct.shared/image-ref))\\n      g (. i createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (java.awt.BasicStroke. 4))\\n      _ (println \\"point count\: \\" (count (tgaa.algo.analysis/final-boundary)))\\n      polygon (Polygon.)\\r\\n      xpnts (into-array Integer  (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary)))\\r\\n      ypnts (into-array Integer  (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary)))\\r\\n      _ (map (fn [x y] (. polygon  addPoint x y) xpnts ypnts))\\n      _ (. g drawPolygon p)]\\n  (mikera.image.core/show i))" "(let [i (mikera.image.core/copy (tgaa.struct.shared/image-ref))\\n      g (. i createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (java.awt.BasicStroke. 4))\\n      _ (println \\"point count\: \\" (count (tgaa.algo.analysis/final-boundary)))\\n      polygon (Polygon.)\\r\\n      xpnts (into-array Integer  (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary)))\\r\\n      ypnts (into-array Integer  (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary)))\\r\\n      _ (map (fn [x y] (do (println x \\" \\" y) (. polygon  addPoint x y)) xpnts ypnts))\\n      _ (. g drawPolygon p)]\\n  (mikera.image.core/show i))" "(let [i (mikera.image.core/copy (tgaa.struct.shared/image-ref))\\n      g (. i createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (java.awt.BasicStroke. 4))\\n      _ (println \\"point count\: \\" (count (tgaa.algo.analysis/final-boundary)))\\n      polygon (Polygon.)\\r\\n      xpnts (into-array Integer  (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary)))\\r\\n      ypnts (into-array Integer  (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary)))\\r\\n      _ (doall (map (fn [x y] (do (println x \\" \\" y) (. polygon  addPoint x y)) xpnts ypnts)))\\n      _ (. g drawPolygon p)]\\n  (mikera.image.core/show i))" "(let [i (mikera.image.core/copy (tgaa.struct.shared/image-ref))\\n      g (. i createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (java.awt.BasicStroke. 4))\\n      _ (println \\"point count\: \\" (count (tgaa.algo.analysis/final-boundary)))\\n      polygon (Polygon.)\\r\\n      xpnts (into-array Integer  (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary)))\\r\\n      ypnts (into-array Integer  (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary)))\\r\\n      r (map (fn [x y] (do (println x \\" \\" y) (. polygon  addPoint x y)) xpnts ypnts))\\n      _ (. g drawPolygon p)]\\n  (mikera.image.core/show i))" "(let [i (mikera.image.core/copy (tgaa.struct.shared/image-ref))\\n      g (. i createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (java.awt.BasicStroke. 4))\\n      _ (println \\"point count\: \\" (count (tgaa.algo.analysis/final-boundary)))\\n      polygon (Polygon.)\\r\\n      xpnts (into-array Integer  (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary)))\\r\\n      ypnts (into-array Integer  (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary)))\\n      _ (println xpnts)\\r\\n      r (map (fn [x y] (do (println x \\" \\" y) (. polygon  addPoint x y)) xpnts ypnts))\\n      _ (. g drawPolygon p)]\\n  (mikera.image.core/show i))" "(let [i (mikera.image.core/copy (tgaa.struct.shared/image-ref))\\n      g (. i createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (java.awt.BasicStroke. 4))\\n      _ (println \\"point count\: \\" (count (tgaa.algo.analysis/final-boundary)))\\n      polygon (Polygon.)\\r\\n      xpnts (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary))\\r\\n      ypnts (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary))\\n      _ (println xpnts)\\r\\n      r (map (fn [x y] (do (println x \\" \\" y) (. polygon  addPoint x y)) xpnts ypnts))\\n      _ (. g drawPolygon p)]\\n  (mikera.image.core/show i))" "(map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary))" "(let [i (mikera.image.core/copy (tgaa.struct.shared/image-ref))\\n      g (. i createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (java.awt.BasicStroke. 4))\\n      _ (println \\"point count\: \\" (count (tgaa.algo.analysis/final-boundary)))\\n      polygon (Polygon.)\\r\\n      xpnts (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary))\\r\\n      ypnts (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary))\\n      _ (println xpnts)\\r\\n      r (map (fn [x y] (do (println x \\" \\" y) (. polygon  addPoint x y)) xpnts ypnts))\\n      _ (. g drawPolygon p)]\\n  (mikera.image.core/show i))" "(let [i (mikera.image.core/copy (tgaa.struct.shared/image-ref))\\n      g (. i createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (java.awt.BasicStroke. 4))\\n      _ (println \\"point count\: \\" (count (tgaa.algo.analysis/final-boundary)))\\n      polygon (Polygon.)\\r\\n      xpnts (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary))\\r\\n      ypnts (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary))\\r\\n      r (map (fn [x y] (do (println x \\" \\" y) (. polygon  addPoint x y)) xpnts ypnts))\\n      _ (. g drawPolygon p)]\\n  (mikera.image.core/show i))" "(def       xpnts (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary)))\\r\\n (def     ypnts (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary)))" "(map (fn [x y] (do (println x \\" \\" y) (. polygon  addPoint x y)) xpnts ypnts))" "(map (fn [x y] (do (println x \\" \\" y) ) xpnts ypnts))" "(map (fn [x y] (println x \\" \\" y)  xpnts ypnts))" "(map (fn [x y] (println x \\" \\" y))  xpnts ypnts))" "(let [i (mikera.image.core/copy (tgaa.struct.shared/image-ref))\\n      g (. i createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (java.awt.BasicStroke. 4))\\n      _ (println \\"point count\: \\" (count (tgaa.algo.analysis/final-boundary)))\\n      polygon (Polygon.)\\r\\n      xpnts (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary))\\r\\n      ypnts (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary))\\r\\n      r (map (fn [x y] (do (println x \\" \\" y) (. polygon  addPoint x y))) xpnts ypnts)\\n      _ (. g drawPolygon p)]\\n  (mikera.image.core/show i))" "(let [i (mikera.image.core/copy (tgaa.struct.shared/image-ref))\\n      g (. i createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (java.awt.BasicStroke. 4))\\n      _ (println \\"point count\: \\" (count (tgaa.algo.analysis/final-boundary)))\\n      polygon (Polygon.)\\r\\n      xpnts (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary))\\r\\n      ypnts (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary))\\r\\n      r (map (fn [x y] (do (println x \\" \\" y) (. polygon  addPoint x y))) xpnts ypnts)\\n      _ (. g drawPolygon p)])\\n\\n  ;(mikera.image.core/show i))" "(map (fn [x y] (do (println x \\" \\" y) (. polygon  addPoint x y))) xpnts ypnts)" "(map (fn [x y] (do (println x \\" \\" y))) xpnts ypnts)" "xpnts" "(map (fn [x y] (println x \\" \\" y)) xpnts ypnts)" "(map (fn [x] (println x \\" \\" y)) xpnts ypnts)" "(map (fn [x] (println x)) xpnts ypnts)" "(map (fn [x y] (println x)) xpnts ypnts)" "(map (fn [y] (println x)) xpnts ypnts)" "(map (fn [x y] (println y)) xpnts ypnts)" "(map (fn [x y] [x y]) xpnts ypnts)" "(let [i (mikera.image.core/copy (tgaa.struct.shared/image-ref))\\n      g (. i createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (java.awt.BasicStroke. 4))\\n      _ (println \\"point count\: \\" (count (tgaa.algo.analysis/final-boundary)))\\n      polygon (Polygon.)\\r\\n      xpnts (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary))\\r\\n      ypnts (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary))\\r\\n      r (map (fn [x y] (do (println x \\" \\" y) (. polygon  addPoint x y))) xpnts ypnts)\\n      _ (. g drawPolygon p)]\\n  (mikera.image.core/show i))" "(let [i (mikera.image.core/copy (tgaa.struct.shared/image-ref))\\n      g (. i createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (java.awt.BasicStroke. 4))\\n      polygon (Polygon.)\\r\\n      xpnts (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary))\\r\\n      ypnts (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary))\\r\\n      r (doall (map (fn [x y] (do (println x \\" \\" y) (. polygon  addPoint x y))) xpnts ypnts))\\n      _ (. g drawPolygon p)]\\n  (mikera.image.core/show i))" "(let [i (mikera.image.core/copy (tgaa.struct.shared/image-ref))\\n      g (. i createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (java.awt.BasicStroke. 4))\\n      polygon (Polygon.)\\r\\n      xpnts (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary))\\r\\n      ypnts (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary))\\r\\n      r (doall (map (fn [x y] (. polygon  addPoint x y)) xpnts ypnts))\\n      _ (. g drawPolygon p)]\\n  (mikera.image.core/show i))" "(let [i (mikera.image.core/copy (tgaa.struct.shared/image-ref))\\n      g (. i createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (java.awt.BasicStroke. 4))\\n      polygon (Polygon.)\\r\\n      xpnts (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary))\\r\\n      ypnts (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary))\\r\\n      _ (doall (map (fn [x y] (. polygon  addPoint x y)) xpnts ypnts))\\n      _ (. g drawPolygon p)]\\n  (mikera.image.core/show i))" "(let [i (mikera.image.core/copy (tgaa.struct.shared/image-ref))\\n      g (. i createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (java.awt.BasicStroke. 4))\\n      _ (. g drawLine 1 1 100 100)\\n      polygon (Polygon.)\\r\\n      xpnts (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary))\\r\\n      ypnts (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary))\\r\\n      _ (doall (map (fn [x y] (. polygon  addPoint x y)) xpnts ypnts))\\n      _ (. g drawPolygon p)\\n     ;_ (mikera.image.core/show i)\\n     ]   )" "(let [i (mikera.image.core/copy (tgaa.struct.shared/image-ref))\\n      g (. i createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (java.awt.BasicStroke. 4))\\n      _ (. g drawLine 1 1 100 100)\\n      polygon (Polygon.)\\r\\n      xpnts (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary))\\r\\n      ypnts (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary))\\r\\n      _ (doall (map (fn [x y] (. polygon  addPoint x y)) xpnts ypnts))\\n      _ (. g drawPolygon p)\\n     _ (mikera.image.core/show i)\\n     ]   )" "(let [i (mikera.image.core/copy (tgaa.struct.shared/image-ref))\\n      g (. i createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (java.awt.BasicStroke. 4))\\n      _ (. g drawLine 1 1 100 100)\\n      polygon (Polygon.)\\r\\n      xpnts (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary))\\r\\n      ypnts (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary))\\r\\n      _ (doall (map (fn [x y] (. polygon  addPoint x y)) xpnts ypnts))\\n      _ (. g drawPolygon xpnts ypnts (count ypnts))\\n     _ (mikera.image.core/show i)\\n     ]   )" "(let [i (mikera.image.core/copy (tgaa.struct.shared/image-ref))\\n      g (. i createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (java.awt.BasicStroke. 4))\\n      _ (. g drawLine 1 1 100 100)\\n      polygon (Polygon.)\\r\\n      xpnts (doall (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary)))\\r\\n      ypnts (doall (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary))\\r\\n      _ (doall (map (fn [x y] (. polygon  addPoint x y)) xpnts ypnts))\\n      _ (. g drawPolygon xpnts ypnts (count ypnts))\\n     _ (mikera.image.core/show i)\\n     ]   )" "(let [i (mikera.image.core/copy (tgaa.struct.shared/image-ref))\\n      g (. i createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (java.awt.BasicStroke. 4))\\n      _ (. g drawLine 1 1 100 100)\\n      polygon (Polygon.)\\r\\n      xpnts (doall (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary)))\\r\\n      ypnts (doall (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary)))\\r\\n      _ (doall (map (fn [x y] (. polygon  addPoint x y)) xpnts ypnts))\\n      _ (. g drawPolygon xpnts ypnts (count ypnts))\\n     _ (mikera.image.core/show i)\\n     ]   )" "(let [i (mikera.image.core/copy (tgaa.struct.shared/image-ref))\\n      g (. i createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (java.awt.BasicStroke. 4))\\n      _ (. g drawLine 1 1 100 100)\\n      polygon (Polygon.)\\r\\n      xpnts (doall (into-array Integer (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary))))\\r\\n      ypnts (doall (into-array Integer (map \#(int (. % getY)) (tgaa.algo.analysis/final-boundary))))\\r\\n      _ (doall (map (fn [x y] (. polygon  addPoint x y)) xpnts ypnts))\\n      _ (. g drawPolygon xpnts ypnts (count ypnts))\\n     _ (mikera.image.core/show i)\\n     ]   )" "(let [i (mikera.image.core/copy (tgaa.struct.shared/image-ref))\\n      g (. i createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (java.awt.BasicStroke. 4))\\n      _ (println \\"point count\: \\" (count (tgaa.algo.analysis/final-boundary)))\\n      polygon (Polygon.)\\r\\n      xpnts (into-array Integer  (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary)))\\r\\n      ypnts (into-array Integer  (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary)))\\r\\n      r (map (fn [x y] (do (println x \\" \\" y) (. polygon  addPoint x y)) xpnts ypnts))\\n      _ (. g drawPolygon p)]\\n  (mikera.image.core/show i))" "(let [i (mikera.image.core/copy (tgaa.struct.shared/image-ref))\\n      g (. i createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (java.awt.BasicStroke. 4))\\n      polygon (Polygon.)\\r\\n      xpnts (into-array Integer  (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary)))\\r\\n      ypnts (into-array Integer  (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary)))\\r\\n      r (map (fn [x y] (do (println x \\" \\" y) (. polygon  addPoint x y)) xpnts ypnts))\\n      _ (. g drawPolygon xpnts ypnts (cont ypnts))]\\n  (mikera.image.core/show i))" "(let [i (mikera.image.core/copy (tgaa.struct.shared/image-ref))\\n      g (. i createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (java.awt.BasicStroke. 4))\\n      polygon (Polygon.)\\r\\n      xpnts (into-array Integer  (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary)))\\r\\n      ypnts (into-array Integer  (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary)))\\r\\n      r (map (fn [x y] (do (println x \\" \\" y) (. polygon  addPoint x y)) xpnts ypnts))\\n      _ (. g drawPolygon xpnts ypnts (count ypnts))]\\n  (mikera.image.core/show i))" "(into-array Integer  (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary)))" "(class (into-array Integer  (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary))))" "(let [i (mikera.image.core/copy (tgaa.struct.shared/image-ref))\\n      g (. i createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (java.awt.BasicStroke. 4))\\n      polygon (Polygon.)\\r\\n      xpnts (into-array Integer  (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary)))\\r\\n      ypnts (into-array Integer  (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary)))\\r\\n      r (map (fn [x y] (do (println x \\" \\" y) (. polygon  addPoint x y)) xpnts ypnts))\\n      _ (. g drawPolyline xpnts ypnts (count ypnts))]\\n  (mikera.image.core/show i))" "(into-array Integer  (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary)))" "(let [i (mikera.image.core/copy (tgaa.struct.shared/image-ref))\\n      g (. i createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (java.awt.BasicStroke. 4))\\n      polygon (Polygon.)\\r\\n      xpnts (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary))\\r\\n      ypnts (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary))\\r\\n      r (map (fn [x y] (do (println x \\" \\" y) (. polygon  addPoint x y)) xpnts ypnts))\\n      _ (. g drawPolyline xpnts ypnts (count ypnts))]\\n  (mikera.image.core/show i))" "(let [i (mikera.image.core/copy (tgaa.struct.shared/image-ref))\\n      g (. i createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (java.awt.BasicStroke. 4))\\n      polygon (Polygon.)\\r\\n      xpnts (doall (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary)))\\r\\n      ypnts (doall (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary)))\\n      _ (. g drawPolyline xpnts ypnts (count ypnts))]\\n  (mikera.image.core/show i))" "(let [i (mikera.image.core/copy (tgaa.struct.shared/image-ref))\\n      g (. i createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (java.awt.BasicStroke. 4))\\r\\n      xpnts (doall (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary)))\\r\\n      ypnts (doall (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary)))\\n      _ (. g drawPolyline xpnts ypnts (count ypnts))]\\n  (mikera.image.core/show i))" "(let [i (mikera.image.core/copy (tgaa.struct.shared/image-ref))\\n      g (. i createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (java.awt.BasicStroke. 4))\\r\\n      xpnts (doall (map \#(Intger (. % getX)) (tgaa.algo.analysis/final-boundary)))\\r\\n      ypnts (doall (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary)))\\n      _ (. g drawPolyline xpnts ypnts (count ypnts))]\\n  (mikera.image.core/show i))" "(let [i (mikera.image.core/copy (tgaa.struct.shared/image-ref))\\n      g (. i createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (java.awt.BasicStroke. 4))\\r\\n      xpnts (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary))\\r\\n      ypnts (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary))\\n      _ (. g drawPolyline xpnts ypnts (count ypnts))]\\n  (mikera.image.core/show i))" "(try\\n  (let [i (mikera.image.core/copy (tgaa.struct.shared/image-ref))\\n        g (. i createGraphics)\\n        _ (. g setColor (. Color YELLOW))\\n        _ (. g setStroke (java.awt.BasicStroke. 4))\\r\\n      xpnts (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary))\\r\\n      ypnts (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary))\\n        _ (. g drawPolyline xpnts ypnts (count ypnts))]\\n    (mikera.image.core/show i))\\n  (catch Exception e\\n    (print e)))" "(try\\n  (let [i (mikera.image.core/copy (tgaa.struct.shared/image-ref))\\n        g (. i createGraphics)\\n        _ (. g setColor (. Color YELLOW))\\n        _ (. g setStroke (java.awt.BasicStroke. 4))\\r\\n      xpnts (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary))\\r\\n      ypnts (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary))\\n        _ (. g drawPolyline (into-array Integer xpnts) (into-array Integer ypnts) (count ypnts))]\\n    (mikera.image.core/show i))\\n  (catch Exception e\\n    (print e)))" "\\n  (let [i (mikera.image.core/copy (tgaa.struct.shared/image-ref))\\n        g (. i createGraphics)\\n        _ (. g setColor (. Color YELLOW))\\n        _ (. g setStroke (java.awt.BasicStroke. 4))\\r\\n      xpnts (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary))\\r\\n      ypnts (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary))\\n        _ (. g drawPolyline (into-array Integer xpnts) (into-array Integer ypnts) (count ypnts))]\\n    (mikera.image.core/show i))" "(into-array Integer xpnts)" "\\n  (let [i (mikera.image.core/copy (tgaa.struct.shared/image-ref))\\n        g (. i createGraphics)\\n        _ (. g setColor (. Color YELLOW))\\n        _ (. g setStroke (java.awt.BasicStroke. 4))\\r\\n      xpnts (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary))\\r\\n      ypnts (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary))\\n        _ (. g drawPolyline (into-array Integer xpnts) (into-array Integer ypnts) (count ypnts))]\\n    (mikera.image.core/show i))" "\\n(let [i (mikera.image.core/copy (tgaa.struct.shared/image-ref))\\n      g (. i createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (java.awt.BasicStroke. 4))\\r\\n      xpnts (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary))\\r\\n      ypnts (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary))\\n      _ (. g drawPolyline (int-array Integer xpnts) (int-array Integer ypnts) (count ypnts))]\\n  (mikera.image.core/show i))" "(int-array Integer xpnts)" "(apply int-array Integer xpnts)" "g" "(. g drawPolyline (int-array 2 1 2)(int-array 2 1 2)2)" "(. g drawPolyline (int-array 2 [1 2])(int-array 2 [1 2])2)" "\\n(let [i (mikera.image.core/copy (tgaa.struct.shared/image-ref))\\n      g (. i createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (java.awt.BasicStroke. 4))\\r\\n      xpnts (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary))\\r\\n      ypnts (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary))\\n      _ (. g drawPolyline (int-array (count xpnts) xpnts) (int-array (count ypnts) ypnts) (count ypnts))]\\n  (mikera.image.core/show i))" "\\n(let [i (mikera.image.core/copy (tgaa.struct.shared/image-ref))\\n      g (. i createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (java.awt.BasicStroke. 4))\\r\\n      xpnts (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary))\\r\\n      ypnts (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary))\\n      xpnts (concat (first xpnts) xpints)\\n      ypnts (concat (first ypnts) ypnts)\\n      _ (. g drawPolyline (int-array (count xpnts) xpnts) (int-array (count ypnts) ypnts) (count ypnts))]\\n  (mikera.image.core/show i))" "\\n(let [i (mikera.image.core/copy (tgaa.struct.shared/image-ref))\\n      g (. i createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (java.awt.BasicStroke. 4))\\r\\n      xpnts (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary))\\r\\n      ypnts (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary))\\n      xpnts (concat (first xpnts) xpnts)\\n      ypnts (concat (first ypnts) ypnts)\\n      _ (. g drawPolyline (int-array (count xpnts) xpnts) (int-array (count ypnts) ypnts) (count ypnts))]\\n  (mikera.image.core/show i))" "\\n(let [i (mikera.image.core/copy (tgaa.struct.shared/image-ref))\\n      g (. i createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (java.awt.BasicStroke. 4))\\r\\n      xpnts (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary))\\r\\n      ypnts (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary))\\n      xpnts (conj xpnts (first xpnts))\\n      ypnts (conj ypnts (first ypnts) )\\n      _ (. g drawPolyline (int-array (count xpnts) xpnts) (int-array (count ypnts) ypnts) (count ypnts))]\\n  (mikera.image.core/show i))" "\\n(let [i (mikera.image.core/copy (tgaa.struct.shared/image-ref))\\n      g (. i createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (java.awt.BasicStroke. 4))\\r\\n      xpnts (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary))\\r\\n      ypnts (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary))\\n      xpnts (conj xpnts (first xpnts))\\n      ypnts (conj ypnts (first ypnts) )\\n      lnum (inc (count xpnts))\\n      _ (. g drawPolyline (int-array lnum xpnts) (int-array lnum ypnts) lnum)]\\n  (mikera.image.core/show i))" "(conj ypnts (first ypnts))" "(conj ypnts (first ypnts) )" "\\n(let [i (mikera.image.core/copy (tgaa.struct.shared/image-ref))\\n      g (. i createGraphics)\\n      _ (. g setColor (. Color YELLOW))\\n      _ (. g setStroke (java.awt.BasicStroke. 4))\\r\\n      xpnts (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary))\\r\\n      ypnts (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary))\\n      xpnts (conj xpnts (first xpnts))\\n      ypnts (conj ypnts (first ypnts) )\\n      lnum (inc (count xpnts))\\n      _ (. g drawPolyline (int-array lnum xpnts) (int-array lnum ypnts) lnum)]\\n  (mikera.image.core/show i))" "\\n(let [i (mikera.image.core/copy (tgaa.struct.shared/image-ref))\\n      g (. i createGraphics)\\n      _ (. g setColor (. Color BLUE))\\n      _ (. g setStroke (java.awt.BasicStroke. 4))\\r\\n      xpnts (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary))\\r\\n      ypnts (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary))\\n      xpnts (conj xpnts (first xpnts))\\n      ypnts (conj ypnts (first ypnts) )\\n      lnum (inc (count xpnts))\\n      _ (. g drawPolyline (int-array lnum xpnts) (int-array lnum ypnts) lnum)]\\n  (mikera.image.core/show i))" "\\n(let [i (mikera.image.core/copy (tgaa.struct.shared/image-ref))\\n      g (. i createGraphics)\\n      _ (. g setColor (. Color BLUE))\\n      _ (. g setStroke (java.awt.BasicStroke. 4))\\r\\n      xpnts (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary))\\r\\n      ypnts (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary))\\n      xpnts (conj xpnts (first xpnts))\\n      ypnts (conj ypnts (first ypnts) )\\n      lnum (count xpnts)\\n      _ (. g drawPolyline (int-array lnum xpnts) (int-array lnum ypnts) lnum)]\\n  (mikera.image.core/show i))" "\\n(let [i (mikera.image.core/copy (tgaa.struct.shared/image-ref))\\n      g (. i createGraphics)\\n      _ (. g setColor (. Color BLUE))\\n      _ (. g setStroke (java.awt.BasicStroke. 1))\\r\\n      xpnts (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary))\\r\\n      ypnts (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary))\\n      xpnts (conj xpnts (first xpnts))\\n      ypnts (conj ypnts (first ypnts) )\\n      lnum (count xpnts)\\n      _ (. g drawPolyline (int-array lnum xpnts) (int-array lnum ypnts) lnum)]\\n  (mikera.image.core/show i))" "\\n(let [i (mikera.image.core/copy (tgaa.struct.shared/image-ref))\\n      g (. i createGraphics)\\n      _ (. g setColor (. Color BLUE))\\n      _ (. g setStroke (java.awt.BasicStroke. 1))\\r\\n      xpnts (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary))\\r\\n      ypnts (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary))\\n      xpntsl (conj xpnts (first xpnts))\\n      ypntsl (conj ypnts (first ypnts) )\\n      lnum (count xpntsl)\\n      _ (. g drawPolyline (int-array lnum xpntsl) (int-array lnum ypntsl) lnum)]\\n  (mikera.image.core/show i))" "\\n(let [i (mikera.image.core/copy (tgaa.struct.shared/image-ref))\\n      g (. i createGraphics)\\n      _ (. g setColor (. Color BLUE))\\n      _ (. g setStroke (java.awt.BasicStroke. 1))\\r\\n      xpnts (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary))\\r\\n      ypnts (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary))\\n      xpntsl (conj xpnts (first xpnts))\\n      ypntsl (conj ypnts (first ypnts) )\\n      lnum (count xpntsl)\\n      _ (print lnum)\\n      _ (. g drawPolyline (int-array lnum xpntsl) (int-array lnum ypntsl) lnum)]\\n  (mikera.image.core/show i))" "\\n(let [i (mikera.image.core/copy (tgaa.struct.shared/image-ref))\\n      g (. i createGraphics)\\n      _ (. g setColor (. Color BLUE))\\n      _ (. g setStroke (java.awt.BasicStroke. 1))\\r\\n      xpnts (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary))\\r\\n      ypnts (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary))\\n      xpntsl (conj xpnts (first xpnts))\\n      ypntsl (conj ypnts (first ypnts) )\\n      lnum (count xpntsl)\\n      _ (print lnum)\\n      _ (. g drawPolyline (int-array lnum xpnts) (int-array lnum ypnts) lnum)]\\n  (mikera.image.core/show i))" "(conj xpnts (first xpnts))" "(count (conj xpnts (first xpnts)))" "(map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary))" "(first xpnts)" "xpnts" "(conj xpnts (first xpnts))" "(conj (reverse xpnts) (first xpnts))" "(cons xpnts (first xpnts))" "(cons (first xpnts) xpnts )" "concat" "(concat  xpnts (first xpnts))" "(concat  xpnts [(first xpnts)])" "\\n(let [i (mikera.image.core/copy (tgaa.struct.shared/image-ref))\\n      g (. i createGraphics)\\n      _ (. g setColor (. Color BLUE))\\n      _ (. g setStroke (java.awt.BasicStroke. 1))\\r\\n      xpnts (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary))\\r\\n      ypnts (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary))\\n      xpntsl (concat xpnts [(first xpnts)])\\n      ypntsl (concat ypnts [(first ypnts)] )\\n      lnum (count xpntsl)\\n      _ (print lnum)\\n      _ (. g drawPolyline (int-array lnum xpnts) (int-array lnum ypnts) lnum)]\\n  (mikera.image.core/show i))" "\\n(let [i (mikera.image.core/copy (tgaa.struct.shared/image-ref))\\n      g (. i createGraphics)\\n      _ (. g setColor (. Color BLUE))\\n      _ (. g setStroke (java.awt.BasicStroke. 1))\\r\\n      xpnts (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary))\\r\\n      ypnts (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary))\\n      xpntsl (concat xpnts [(first xpnts)])\\n      ypntsl (concat ypnts [(first ypnts)] )\\n      lnum (count xpntsl)\\n      _ (print lnum)\\n      _ (. g drawPolyline (int-array lnum xpntsl) (int-array lnum ypntsl) lnum)]\\n  (mikera.image.core/show i))" "(defn draw-boundary [points]\\n(let [i (mikera.image.core/copy (tgaa.struct.shared/image-ref))\\n      g (. i createGraphics)\\n      _ (. g setColor (. Color BLUE))\\n      _ (. g setStroke (java.awt.BasicStroke. 1))\\r\\n      xpnts (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary))\\r\\n      ypnts (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary))\\n      xpntsl (concat xpnts [(first xpnts)])\\n      ypntsl (concat ypnts [(first ypnts)] )\\n      lnum (count xpntsl)\\n      _ (print lnum)\\n      _ (. g drawPolyline (int-array lnum xpntsl) (int-array lnum ypntsl) lnum)]\\n  (mikera.image.core/show i))" "\\n(let [i (mikera.image.core/copy (tgaa.struct.shared/image-ref))\\n      g (. i createGraphics)\\n      _ (. g setColor (. Color BLUE))\\n      _ (. g setStroke (java.awt.BasicStroke. 1))\\r\\n      xpnts (map \#(int (. % getX)) (tgaa.algo.analysis/final-boundary))\\r\\n      ypnts (map  \#(int (. % getY)) (tgaa.algo.analysis/final-boundary))\\n      xpntsl (concat xpnts [(first xpnts)])\\n      ypntsl (concat ypnts [(first ypnts)] )\\n      lnum (count xpntsl)\\n      _ (print lnum)\\n      _ (. g drawPolyline (int-array lnum xpntsl) (int-array lnum ypntsl) lnum)]\\n  (mikera.image.core/show i))" "(defn draw-boundary [ref-img boundary]\\r\\n  (let [boundary-closed (concat boundary [(first boundary)])\\r\\n        xpnts (map \#(int (. % getX)) boundary-closed)\\r\\n        ypnts (map  \#(int (. % getY)) boundary-closed)\\r\\n        p-num (count boundary-closed)\\r\\n        g (. ref-img createGraphics)\\r\\n        _ (doto g (.setColor (. Color BLUE))\\r\\n            (.setStroke (java.awt.BasicStroke. 1))\\r\\n            (.drawPolyline (int-array p-num xpnts) (int-array p-num ypnts) p-num))]\\r\\n    (mikera.image.core/show ref-img)))" "(draw-boundary i (tgaa.algo.analysis/final-boundary))"]
eclipse.preferences.version=1
