cmdhistory=["(draw-paths (fn [x] true) \\"BLUE\\" (tgaa.util.shared/image-ref))" "(show (tgaa.util.shared/image-ref))" "(clojure.string/upper-case \\"t\\")" "(defn draw-paths [ant-paths-filter-func color-name-str img-ref line-width]\\r\\n  (let [g (doto (. img-ref createGraphics)\\r\\n            (.setColor (eval (read-string \\r\\n                               (str \\"(. Color \\"  \\r\\n                                    (upper-case color-name-str) \\")\\"))))\\r\\n            (.setStroke (BasicStroke. line-width)))]\\r\\n    (doall (map \\r\\n             (fn [{\:keys [start end]}] \\r\\n               (. g drawLine (first start) (second start) (first end) (second end))) \\r\\n             (filter ant-paths-filter-func (tgaa.util.shared/canidates))))))" "tgaa.util.shared" "tgaa.util.shared/canidates" "(first (tgaa.util.shared/canidates))" "(require [tgaa.algo.ant \:as a])" "(require [tgaa.util.ant \:as a])" "(require [tgaa.algo.ant \:as a])" "(shared/config)" "shared/config" "(init-trail-paths )" "(image/get-image)" "(tgaa.algo.phases/load-image)" "(init-trail-paths )" "(defn create-ant-path[]\\r\\n  {})" "(create-ant-path)" "create-ant-path" "(ant/create-ant-path)" "(-> (ant/create-ant-path) (ant/update-ant-thresh true))" "(->> (ant/create-ant-path) (ant/update-ant-thresh true))" "(->> (ant/create-ant-path) (ant/update-ant-thresh true) (ant/update-ant-end-point [10 10]))" "(->> (ant/create-ant-path) \\n  (ant/update-ant-thresh true) \\n  (ant/update-ant-start-point [10 10])\\n  (ant/update-ant-end-point [15 15])\\n  (ant/update-ant-end-point [10 10]))" "(->> (ant/create-ant-path) \\n  (ant/update-ant-thresh true) \\n  (ant/update-ant-start-point [10 10])\\n  (ant/update-ant-start-point [15 15])\\n  (ant/update-ant-end-point [10 10]))" "(->> (ant/create-ant-path) \\n  (ant/update-ant-thresh true) \\n  (ant/update-ant-dir-vec [10 10])\\n  (ant/update-ant-start-point [15 15])\\n  (ant/update-ant-end-point [10 10]))" "(->> (ant/create-ant-path) \\n  (ant/update-ant-trial-num 0)\\n  (ant/update-ant-thresh true) \\n  (ant/update-ant-dir-vec [10 10])\\n  (ant/update-ant-start-point [15 15])\\n  (ant/update-ant-end-point [10 10]))" "(defn tg [& v]\\n  (if (emtpy? v)\\n    10\\n    (assoc (second v) \:testg (first v))))" "(defn tg [& v]\\n  (if (empty? v)\\n    10\\n    (assoc (second v) \:testg (first v))))" "(g)" "(tg)" "(->> {\:one 1} (tg 33))" "(defn tc [& v]\\n  (if (empty? v)\\n    10\\n    (assoc (second v) \:testc (first v))))" "(->> {\:one 1} (tg 33) (tc 55))" "(defn attribute-set-get [key & in]\\r\\n  (let [in-flat (flatten in)]\\r\\n  (if (\= (count in-flat) 1)\\r\\n      (key-name (first in-flat))\\r\\n      (attribute-update key-name (second in-flat) key-name (first in-flat)))))" "(defn attribute-set-get [key-name & in]\\r\\n  (let [in-flat (flatten in)]\\r\\n    (if (\= (count in-flat) 1)\\r\\n      (key-name (first in-flat))\\r\\n      (attribute-update key-name (second in-flat) key-name (first in-flat)))))" "(defn attribute-set-get [key-name & in]\\r\\n  (let [in-flat (flatten in)]\\r\\n    (if (\= (count in-flat) 1)\\r\\n      (key-name (first in-flat))\\r\\n      ((second in-flat) key-name (first in-flat)))))" "(attribute-set-get \:test '((10 {})))" "(defn attribute-set-get [key-name & in]\\r\\n  (let [in-flat (flatten in)]\\r\\n    (if (\= (count in-flat) 1)\\r\\n      (key-name (first in-flat))\\r\\n      (assoc (second in-flat) key-name (first in-flat)))))" "(attribute-set-get \:test '((10 {})))" "(defn attribute-set-get [key-name & in]\\r\\n  (let [in-flat (flatten in)]\\r\\n    (if (\= (count in-flat) 1)\\r\\n      (key-name (first in-flat))\\r\\n      (assoc (second in-flat) key-name (first in-flat)))))\\r\\n\\r\\n(defn ant-thresh? [& in]\\r\\n  (attribute-set-get \:thresh? in)" "(defn ant-thresh? [& in]\\r\\n  (attribute-set-get \:thresh? in))" "(ant-thresh? {\:test 10})" "(ant-thresh? {\:thresh? 10})" "(ant-thresh? 33 {\:thresh? 10})" "(ant-path [ 22 22])" "(ant-path [22 22])" "(defn ant-path [start-point]\\r\\n  \\"Creates an ant path\\"\\r\\n  (->> (ant/create-ant-path) \\r\\n    (ant/ant-trial-num (shared/trial-num))\\r\\n    (ant/ant-thresh? false) \\r\\n    (ant/ant-dir-vec (rand-ant-dir start-point))\\r\\n    (ant/ant-start-point (rand-ant-dir start-point))))" "(ant-path [22 22])" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "tgaa.util.shared" "tgaa.util.shared/thresh" "(tgaa.util.shared/thresh)" "(phase/trapping)" "(tgaa.util.shared/thresh)" "(phase/trapping)" "(tgaa.util.shared/thresh)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.shared/thresh)" "(phase/trapping)" "(tgaa.util.shared/thresh)" "(phase/trapping)" "(tgaa.util.shared/thresh)" "(phase/trapping)" "(tgaa.util.shared/thresh)" "(phase/trapping)" "(tgaa.util.shared/thresh)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.shared/thresh)" "(tgaa.util.image/draw-all-can-paths)" "\\njava.awt.Color" "\\n(java.awt.Color.)" "(. Color WHiTE)" "(java.awt.Color WHiTE)" "(java.awt.Color WHITE)" "(import 'java.awt.Color)" "(java.awt.Color WHITE)" "(. Color WHiTE)" "(. Color WHITE)" "(str \\"(. Color \\"  \\r\\n                                    (upper-case color-name-str) \\")\\")" "(str \\"(. Color \\"  \\r\\n                                    \\"YELLOW\\" \\")\\")" "(tgaa.util.image/draw-all-can-paths)" "(tgaa.util.image/show-image)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/draw-all-can-paths)" "(import  'java.awt.Color)" "(tgaa.util.image/draw-all-can-paths)" "(phase/load-image)" "(phase/trapping)" "(tgaa.util.image/draw-all-can-paths)" "(tgaa.util.image/show-image)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(required tgaa.util.image)" "(required 'tgaa.util.image)" "(require 'tgaa.util.image)" "(tgaa.util.image/show-image)" "(tgaa.util.image/draw-all-can-paths)" "(import 'java.awt.Color)" "(tgaa.util.image/draw-all-can-paths)" "(tgaa.util.image/show-image)" "(require  [mikera.image.core \:as mi])" "(use [mikera.image.core \:as mi])" "(use 'mikera.image.core)" "(require  'mikera.image.core)" "mikera.image.core/copy" "(show (draw-all-can-paths))" "(show (tgaa.util.image/draw-all-can-paths))" "(tgaa.util.image/draw-all-can-paths)" "(show (tgaa.util.image/draw-all-can-paths))" "(phase/load-image)" " (phase/bootstrap)" " (phase/trapping)" "(use 'mikera.image.core)" "(show (tgaa.util.shared/image-ref))" "(show (tgaa.util.image/show-segmentaton))" "(tgaa.util.image/show-segmentaton)" "(tgaa.util.image/show-all-cann-path)" "(tgaa.util.image/draw-all-can-paths)" "(import 'java.awt.Color)" "(tgaa.util.image/draw-all-can-paths)" "(tgaa.util.image/show-all-cann-path)" "(show (tgaa.util.shared/image-ref))" "(tgaa.util.image/show-all-cann-path)" "(phase/load-image)" "(phase/bootstrap)" " (phase/trapping)" "(tgaa.util.image/show-image)" "(tgaa.util.image/show-segmentaton)" "(tgaa.util.image/show-all-cann-path)" "(improt 'java.awt.Color)" "(import 'java.awt.Color)" "(tgaa.util.image/show-all-cann-path)" "tgaa.algo.ant" "tgaa.algo.ant/ant-trial-num" "(draw-can-paths)" "(tgaa.util.image/draw-can-paths)" "((tgaa.util.image/show-cann-path)" "(tgaa.util.image/show-cann-path)" "(tgaa.util.image/show-cann-path 1)" "(tgaa.util.image/show-cann-path 2)" "(tgaa.util.image/show-cann-path 3)" "(tgaa.util.image/show-cann-path 4)" "(tgaa.util.image/show-cann-path 5\\n                                )" "(tgaa.util.image/show-cann-path 10)" "(tgaa.util.image/show-cann-path 15)" "(tgaa.util.image/show-cann-path 20\\n                                )" "(tgaa.util.image/show-cann-path 50\\n                                )" "(tgaa.util.image/show-cann-path 10)" "(def config (get-config))" "(delay (print 101010) 10)" "(def dt (delay (print 101010) 10))" "@dt" "(def dt (delay (print 101010) 100))" "@dt" "(def dt (delay (print 101010) 10000))" "@dt" "(def dtt (delay (print 101010) 10000))" "@dtt" "(force dtt)" "(force @dtt)" "@dtt" "(do (Thread/sleep 500)(print 444))" "(do (Thread/sleep 5000)(print 444))" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.image/show-cann-path 10)" "(phase/load-image)" "(phase/bootstrap)" " (phase/trapping)" "(tgaa.util.image/show-cann-path 10)" "(tgaa.util.image/anim-trail-paths)" "(process-image)" "(tgaa.util.image/show-segmentaton)" "(tgaa.util.image/anim-trail-paths)" "(import 'java.awt.Color)" "(tgaa.util.image/anim-trail-paths)" "(process-image)" "(tgaa.util.image/anim-trail-paths)" "(import 'java.awt.Color)" "(tgaa.util.image/anim-trail-paths)" "(process-image)" "(import 'java.awt.Color)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.image/show-cann-path 1)" "(tgaa.util.image/show-cann-path 2)" "(tgaa.util.image/show-cann-path 3\\n                                )" "  (let [[start-x-1 start-y-1] [0 0]\\r\\n        [end-x-1 end-y-1] [4 4]\\r\\n        [start-x-2 start-y-2] [0 4]\\r\\n        [end-x-2 end-y-2] [4 0]]\\r\\n    (if (< start-x-1 start-x-2)\\r\\n      (if (> end-x-1 end-x-2)\\r\\n        (if (< start-y-1 start-y-2)\\r\\n          (> end-y-1 end-y-2)))))" "  (let [[start-x-1 start-y-1] [0 0]\\r\\n        [end-x-1 end-y-1] [4 4]\\r\\n        [start-x-2 start-y-2] [0 4]\\r\\n        [end-x-2 end-y-2] [4 0]]\\r\\n    (if (< start-x-1 start-x-2)\\r\\n      (if (> end-x-1 end-x-2)\\r\\n        (if (< start-y-1 start-y-2)\\r\\n          (> end-y-1 end-y-2) \\n          true))))" "  (let [[start-x-1 start-y-1] [3 1]\\r\\n        [end-x-1 end-y-1] [150 168]\\r\\n        [start-x-2 start-y-2] [148 3]\\r\\n        [end-x-2 end-y-2] [5 164]]\\r\\n    (if (< start-x-1 start-x-2)\\r\\n      (if (> end-x-1 end-x-2)\\r\\n        (if (< start-y-1 start-y-2)\\r\\n          (> end-y-1 end-y-2) \\n          true))))" "  (let [[start-x-1 start-y-1] [3 1]\\r\\n        [end-x-1 end-y-1] [121 119]\\r\\n        [start-x-2 start-y-2] [148 3]\\r\\n        [end-x-2 end-y-2] [5 164]]\\r\\n    (if (< start-x-1 start-x-2)\\r\\n      (if (> end-x-1 end-x-2)\\r\\n        (if (< start-y-1 start-y-2)\\r\\n          (> end-y-1 end-y-2) \\n          true))))" "  (let [[start-x-1 start-y-1] [3 1]\\r\\n        [end-x-1 end-y-1] [121 119]\\r\\n        [start-x-2 start-y-2] [148 3]\\r\\n        [end-x-2 end-y-2] [5 164]]\\r\\n    (if (< start-x-1 start-x-2)\\r\\n      (if (> end-x-1 end-x-2)\\r\\n        (if (< start-y-1 start-y-2)\\r\\n          (> end-y-1 end-y-2) \\n          true\\n          \\"test\\"))))" "  (let [[start-x-1 start-y-1] [3 1]\\r\\n        [end-x-1 end-y-1] [150 168]\\r\\n        [start-x-2 start-y-2] [148 3]\\r\\n        [end-x-2 end-y-2] [5 164]]\\r\\n    (if (< start-x-1 start-x-2)\\r\\n      (if (> end-x-1 end-x-2)\\r\\n        (if (< start-y-1 start-y-2)\\r\\n          (> end-y-1 end-y-2) \\n          true))))" "  (let [[start-x-1 start-y-1] [3 1]\\r\\n        [end-x-1 end-y-1] [121 119]\\r\\n        [start-x-2 start-y-2] [148 3]\\r\\n        [end-x-2 end-y-2] [5 164]]\\r\\n    (if (< start-x-1 start-x-2)\\r\\n      (if (> end-x-1 end-x-2)\\r\\n        (if (< start-y-1 start-y-2)\\r\\n          (> end-y-1 end-y-2) \\n          true))))" "  (let [[start-x-1 start-y-1] [3 1]\\r\\n        [end-x-1 end-y-1] [121 119]\\r\\n        [start-x-2 start-y-2] [148 3]\\r\\n        [end-x-2 end-y-2] [5 164]]\\r\\n    (if (< start-x-1 start-x-2)\\r\\n      (if (> end-x-1 end-x-2)\\r\\n        (if (< start-y-1 start-y-2)\\r\\n          (> end-y-1 end-y-2) \\n          true\\n          true))))" "  (let [[start-x-1 start-y-1] [3 1]\\r\\n        [end-x-1 end-y-1] [121 119]\\r\\n        [start-x-2 start-y-2] [148 3]\\r\\n        [end-x-2 end-y-2] [5 164]]\\r\\n    (if (< start-x-1 start-x-2)\\r\\n      (if (> end-x-1 end-x-2)\\r\\n        (if (< start-y-1 start-y-2)\\r\\n          (if (> end-y-1 end-y-2) \\n          true))))" "  (let [[start-x-1 start-y-1] [3 1]\\r\\n        [end-x-1 end-y-1] [121 119]\\r\\n        [start-x-2 start-y-2] [148 3]\\r\\n        [end-x-2 end-y-2] [5 164]]\\r\\n    (if (< start-x-1 start-x-2)\\r\\n      (if (> end-x-1 end-x-2)\\r\\n        (if (< start-y-1 start-y-2)\\r\\n          (if (> end-y-1 end-y-2) \\n          true)))))" "  (let [[start-x-1 start-y-1] [3 1]\\r\\n        [end-x-1 end-y-1] [150 168]\\r\\n        [start-x-2 start-y-2] [148 3]\\r\\n        [end-x-2 end-y-2] [5 164]]\\r\\n    (if (< start-x-1 start-x-2)\\r\\n      (if (> end-x-1 end-x-2)\\r\\n        (if (< start-y-1 start-y-2)\\r\\n          (if (> end-y-1 end-y-2) \\n          true)))))" "  (let [[start-x-1 start-y-1] [3 1]\\r\\n        [end-x-1 end-y-1] [121 119]\\r\\n        [start-x-2 start-y-2] [148 3]\\r\\n        [end-x-2 end-y-2] [5 164]]\\r\\n    (if (< start-x-1 start-x-2)\\r\\n      (if (> end-x-1 end-x-2)\\r\\n        (if (< start-y-1 start-y-2)\\r\\n          (if (> end-y-1 end-y-2) \\n          true)))))" "  (let [[start-x-1 start-y-1] [3 1]\\r\\n        [end-x-1 end-y-1] [121 119]\\r\\n        [start-x-2 start-y-2] [148 3]\\r\\n        [end-x-2 end-y-2] [5 164]]\\r\\n    (if (< start-x-1 start-x-2)\\r\\n      (if (> end-x-1 end-x-2)\\r\\n        (if (< start-y-1 start-y-2)\\r\\n          (if (> end-y-1 end-y-2) \\n          true\\n          \\"tet\\")))))" "  (let [[start-x-1 start-y-1] [3 1]\\r\\n        [end-x-1 end-y-1] [121 119]\\r\\n        [start-x-2 start-y-2] [148 3]\\r\\n        [end-x-2 end-y-2] [5 164]]\\r\\n    (if (< start-x-1 start-x-2)\\r\\n      (if (> end-x-1 end-x-2)\\r\\n        (if (< start-y-1 start-y-2)) \\n          true\\n          )))" "  (let [[start-x-1 start-y-1] [3 1]\\r\\n        [end-x-1 end-y-1] [121 119]\\r\\n        [start-x-2 start-y-2] [148 3]\\r\\n        [end-x-2 end-y-2] [5 164]]\\r\\n    (if (< start-x-1 start-x-2)\\r\\n      (if (> end-x-1 end-x-2)\\r\\n        (if (< start-y-1 start-y-2)) \\n          true\\n          \\"more\\"\\n          )))" "  (let [[start-x-1 start-y-1] [3 1]\\r\\n        [end-x-1 end-y-1] [121 119]\\r\\n        [start-x-2 start-y-2] [148 3]\\r\\n        [end-x-2 end-y-2] [5 164]]\\r\\n    (if (< start-x-1 start-x-2)\\r\\n      (if (> end-x-1 end-x-2)\\r\\n        (if (< start-y-1 start-y-2))\\n          true\\n          \\"more\\"\\n          )))" "  (let [[start-x-1 start-y-1] [3 1]\\r\\n        [end-x-1 end-y-1] [121 119]\\r\\n        [start-x-2 start-y-2] [148 3]\\r\\n        [end-x-2 end-y-2] [5 164]]\\r\\n    (if (< start-x-1 start-x-2)\\r\\n      (if (> end-x-1 end-x-2)\\r\\n        (if (< start-y-1 start-y-2)\\n          true\\n          \\"more\\"\\n          )))" "  (let [[start-x-1 start-y-1] [3 1]\\r\\n        [end-x-1 end-y-1] [121 119]\\r\\n        [start-x-2 start-y-2] [148 3]\\r\\n        [end-x-2 end-y-2] [5 164]]\\r\\n    (if (< start-x-1 start-x-2)\\r\\n      (if (> end-x-1 end-x-2)\\r\\n        (if (< start-y-1 start-y-2)\\r\\n          (if (> end-y-1 end-y-2) \\n          true)))))" "  (let [[start-x-1 start-y-1] [3 1]\\r\\n        [end-x-1 end-y-1] [121 119]\\r\\n        [start-x-2 start-y-2] [148 3]\\r\\n        [end-x-2 end-y-2] [5 164]]\\r\\n    (if (< start-x-1 start-x-2)\\r\\n      (if (> end-x-1 end-x-2)\\r\\n        (if (< start-y-1 start-y-2)\\r\\n          true))))" "  (let [[start-x-1 start-y-1] [3 1]\\r\\n        [end-x-1 end-y-1] [52 52]\\r\\n        [start-x-2 start-y-2] [148 3]\\r\\n        [end-x-2 end-y-2] [5 164]]\\r\\n    (if (< start-x-1 start-x-2)\\r\\n      (if (> end-x-1 end-x-2)\\r\\n        (if (< start-y-1 start-y-2)\\r\\n          true))))" "(keys tgaa.util.shared/trial-state)" "(keys @tgaa.util.shared/trial-state)" "(first (\:cand-paths` @tgaa.util.shared/trial-state))" "(\:cand-paths` @tgaa.util.shared/trial-state)" "  (let [[start-x-1 start-y-1] [3 1]\\r\\n        [end-x-1 end-y-1] [52 52]\\r\\n        [start-x-2 start-y-2] [148 3]\\r\\n        [end-x-2 end-y-2] [5 164]]\\r\\n    (and (<\= start-x-1 end-x-2)\\n         (>\= end-x-1 start-x-2)\\n         (<\= start-y-1 end-y-2)\\n         (>\= end-y-1 start-y-2)))" "  (let [[start-x-1 start-y-1] [3 1]\\r\\n        [end-x-1 end-y-1] [121 119]\\r\\n        [start-x-2 start-y-2] [148 3]\\r\\n        [end-x-2 end-y-2] [5 164]]\\r\\n    (and (<\= start-x-1 end-x-2)\\n         (>\= end-x-1 start-x-2)\\n         (<\= start-y-1 end-y-2)\\n         (>\= end-y-1 start-y-2)))" "(defn is-crossed [path-1 path-2]\\r\\n  (let [[start-x-1 start-y-1] (ant/ant-start-point path-1)\\r\\n        [end-x-1 end-y-1] (ant/ant-end-point path-1)\\r\\n        [start-x-2 start-y-2] (ant/ant-start-point path-2)\\r\\n        [end-x-2 end-y-2] (ant/ant-end-point path-2)]\\r\\n    (and (<\= start-x-1 end-x-2)\\r\\n         (>\= end-x-1 start-x-2)\\r\\n         (<\= start-y-1 end-y-2)\\r\\n         (>\= end-y-1 start-y-2))))" "(first (\:cand-paths` @tgaa.util.shared/trial-state))" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(first (\:cand-paths` @tgaa.util.shared/trial-state))" "((\:cand-paths` @tgaa.util.shared/trial-state)" "(\:cand-paths` @tgaa.util.shared/trial-state)" "(first (\:cand-paths @tgaa.util.shared/trial-state))" "(filter \#(\= (\:trail-num %) 50) (\:cand-paths @tgaa.util.shared/trial-state))" "(filter \#(\= (\:trail-num %) 49) (\:cand-paths @tgaa.util.shared/trial-state))" "(filter \#(\= (\:trial-num %) 49) (\:cand-paths @tgaa.util.shared/trial-state))" "(count (filter \#(\= (\:trial-num %) 49) (\:cand-paths @tgaa.util.shared/trial-state)))" "(count (filter \#(\= (\:trial-num %) 50) (\:cand-paths @tgaa.util.shared/trial-state)))" "(count (filter \#(\= (\:trial-num %) 48) (\:cand-paths @tgaa.util.shared/trial-state)))" "(apply count (filter \#(\= (\:trial-num %) 50) (\:cand-paths @tgaa.util.shared/trial-state)))" "(filter \#(\= (\:trial-num %) 50) (\:cand-paths @tgaa.util.shared/trial-state))" "(filter \#(\= (\:trial-num %) 0) (\:cand-paths @tgaa.util.shared/trial-state))" "(filter \#(\= (\:trial-num %) 1) (\:cand-paths @tgaa.util.shared/trial-state))" "(tgaa.util.image/anim-trail-paths)" "(filter \#(\= (\:trial-num %) 25) (\:cand-paths @tgaa.util.shared/trial-state))" "(tgaa.util.image/show-cann-path 25)" "(filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (\:cand-paths @tgaa.util.shared/trial-state))" "(let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (\:cand-paths @tgaa.util.shared/trial-state))\\n      len (dec (count est-can))]\\n  (loop [i 0 grouped est-can]\\n    (if (> i len)\\n      grouped\\n      (recur (inc i) \\n             (map \#(tgaa.algo.ant/ant-group i)" "(in-ns 'tgaa.util.ant-path)" "(ns)" "(ns-name)" "(let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (\:cand-paths @tgaa.util.shared/trial-state))]\\n  (" "(defn is-boxed [path-1 path-2]\\r\\n  (let [[start-x-1 start-y-1] (ant/ant-start-point path-1)\\r\\n        [end-x-1 end-y-1] (ant/ant-end-point path-1)\\r\\n        [start-x-2 start-y-2] (ant/ant-start-point path-2)\\r\\n        [end-x-2 end-y-2] (ant/ant-end-point path-2)]\\r\\n    (and (<\= start-x-1 end-x-2)\\r\\n         (>\= end-x-1 start-x-2)\\r\\n         (<\= start-y-1 end-y-2)\\r\\n         (>\= end-y-1 start-y-2))))\\r\\n\\r\\n(defn group-path [ref-path cann]\\r\\n  (split-with \#(is-boxed ref-path %) cann))" "(let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (\:cand-paths @tgaa.util.shared/trial-state))]\\n  (group-path (first est-can) est-can))" "(let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (\:cand-paths @tgaa.util.shared/trial-state))]\\n  (apply count (group-path (first est-can) est-can)))" "(let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (\:cand-paths @tgaa.util.shared/trial-state))]\\n  (map count (group-path (first est-can) est-can)))" "(let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (\:cand-paths @tgaa.util.shared/trial-state))]\\n  (map count (group-path (second est-can) est-can)))" "(let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (\:cand-paths @tgaa.util.shared/trial-state))]\\n  (map count (group-path (nth est-can 5) est-can)))" "(let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (\:cand-paths @tgaa.util.shared/trial-state))]\\n  (map count (group-path (nth est-can 10) est-can)))" "(let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (\:cand-paths @tgaa.util.shared/trial-state))]\\n  (map count (group-path (nth est-can 14) est-can)))" "(let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (\:cand-paths @tgaa.util.shared/trial-state))]\\n  (map count (group-path (nth est-can 20) est-can)))" "(count (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25))" "(count (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25)))" "(count (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (\:cand-paths @tgaa.util.shared/trial-state)))" "(let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (\:cand-paths @tgaa.util.shared/trial-state))]\\n  (map count (group-path (nth est-can 20) est-can)))" "(defn est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (\:cand-paths @tgaa.util.shared/trial-state)))" "(def est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (\:cand-paths @tgaa.util.shared/trial-state)))" "(is-boxed (first est-can) (first est-can))" "(is-boxed (first est-can) (second est-can))" "(is-boxed (second est-can) (first est-can))" "(is-boxed (second est-can) (second est-can))" "(second est-can)" "(defn is-boxed [path-1 path-2]\\r\\n  (let [[start-x-1 start-y-1] (ant/ant-start-point path-1)\\r\\n        [end-x-1 end-y-1] (ant/ant-end-point path-1)\\r\\n        [start-x-2 start-y-2] (ant/ant-start-point path-2)\\r\\n        [end-x-2 end-y-2] (ant/ant-end-point path-2)\\n        [leftmost-x-1 rightmost-x-1] (if (< start-x-1 end-x-1) [start-x-1 end-x-1] [end-x-1 start-x-1])\\n        [highest-y-1 lowest-y-1] (if (< start-y-1 end-y-1) [start-y-1 end-y-1] [end-y-1 start-y-1])\\n        [leftmost-x-2 rightmost-x-2] (if (< start-x-2 end-x-2) [start-x-2 end-x-2] [end-x-2 start-x-2])\\r\\n        [highest-y-2 lowest-y-2] (if (< start-y-2 end-y-2) [start-y-2 end-y-2] [end-y-2 start-y-2])]\\r\\n    (and (<\= leftmost-x-1 rightmost-x-2)\\r\\n         (>\= rightmost-x-1 leftmost-x-2)\\r\\n         (<\= highest-y-1 lowest-y-2)\\r\\n         (>\= lowest-y-1 highest-y-2))))" "(is-boxed (second est-can) (second est-can))" "(is-boxed (second est-can) (first est-can))" "(let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (\:cand-paths @tgaa.util.shared/trial-state))]\\n  (map count (group-path (nth est-can 20) est-can)))" "(is-boxed (second est-can) (first est-can))" "(is-boxed (second est-can) (second est-can))" "(is-boxed (first est-can) (first est-can))" "(let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (\:cand-paths @tgaa.util.shared/trial-state))]\\n  (map count (group-path (nth est-can 1) est-can)))" "(let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (\:cand-paths @tgaa.util.shared/trial-state))]\\n  (map count (group-path (nth est-can 0) est-can)))" "(let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (\:cand-paths @tgaa.util.shared/trial-state))]\\n  (map count (group-path (nth est-can 2) est-can)))" "(group-path (nth est-can 2) est-can)" "(count (group-path (nth est-can 2) est-can))" "(apply count (group-path (nth est-can 2) est-can))" "(map count (group-path (nth est-can 2) est-can))" "(map count (group-path (nth est-can 0) est-can))" "(is-boxed (nth est-can 0) est-can)" "(is-boxed (nth est-can 0) (nth est-can 0))" "(is-boxed (nth est-can 0) (nth est-can 1))" "(is-boxed (nth est-can 0) (nth est-can 2))" "(is-boxed (nth est-can 0) (nth est-can 3))" "(is-boxed (nth est-can 0) (nth est-can 4))" "(is-boxed (nth est-can 0) (nth est-can 5))" "(is-boxed (nth est-can 0) (nth est-can 6))" "(is-boxed (nth est-can 6) (nth est-can 6))" "(map count (group-path (nth est-can 6) est-can))" "(split-with \#(> 5 %) (range 10))" "(map count (split-with \#(> 5 %) (range 10)))" "(map count (group-path (nth est-can 2) est-can))" "(map count (group-path (nth est-can 0) est-can))" "(map count (group-path (nth est-can 10) est-can))" "(map count (group-path (nth est-can 27) est-can))" "(map count (group-path (nth est-can 26) est-can))" "(map count (filter  \#(is-boxed (nth est-can 0) %) est-can))" "(filter  \#(is-boxed (nth est-can 0) %) est-can)" "(map count (filter  \#(is-boxed (nth est-can 0) %) est-can))" "(map count (filter  \#(is-boxed (nth est-can 1) %) est-can))" "(count (filter  \#(is-boxed (nth est-can 1) %) est-can))" "(count (filter  \#(is-boxed (nth est-can 0) %) est-can))" "(count (filter  \#(is-boxed (nth est-can 10) %) est-can))" "(apply count (filter  \#(split-with (nth est-can 10) %) est-can))" "( count (filter  \#(split-with (nth est-can 10) %) est-can))" "( count (filter  \#(split-by (nth est-can 10) %) est-can))" "(apply count (filter  \#(split-by (nth est-can 10) %) est-can))" "(apply count (split-with  \#(is-boxed (nth est-can 10) %) est-can))" "(map count (split-with  \#(is-boxed (nth est-can 10) %) est-can))" "(map count (split-with  (partial is-boxed (nth est-can 10)) est-can))" "(apply count (filter  \#(split-by (nth est-can 10) %) est-can))" "( count (filter  \#(split-by (nth est-can 10) %) est-can))" "(count (filter  \#(is-boxed (nth est-can 0) %) est-can))" "(count (filter  \#(is-boxed (nth est-can 1) %) est-can))" "(count (split-with  \#(is-boxed (nth est-can 1) %) est-can))" "(apply count (split-with  \#(is-boxed (nth est-can 1) %) est-can))" "(map count (split-with  \#(is-boxed (nth est-can 1) %) est-can))" "(map count (filter  \#(is-boxed (nth est-can 1) %) est-can))" "(map count (split-with  (partial is-boxed (nth est-can 1)) est-can))" "(nth est-can 1)" "(map count (split-with  (partial is-boxed {\:path-length 31,\\r\\n \:local-max [184 376],\\r\\n \:local-min [214 376],\\r\\n \:end [184 376],\\r\\n \:start [214 376],\\r\\n \:dir [-1 0],\\r\\n \:thresh? true,\\r\\n \:trial-num 25}) est-can))" "(map count (split-with  (partial is-boxed (nth est-can 1)) est-can))" "(map count (filter  \#(is-boxed (nth est-can 1) %) est-can))" "(count (filter  \#(is-boxed (nth est-can 1) %) est-can))" "(count (filter  \#(is-boxed (nth est-can 10) %) est-can))" "(class est-can)" "(count (filter  \#(is-boxed (nth est-can 10) %) est-can))" "(count (take-while  \#(is-boxed (nth est-can 10) %) est-can))" "(defn drop-one\\r\\n  [coll]\\r\\n  (when-let [s (seq coll)]\\r\\n    (rest s)))" "(drop-one [1 2 3])" "(when-let [s [1 2 3]]\\r\\n  (rest s))" "(count (filter  \#(is-boxed (nth est-can 10) %) est-can))" "(map  \#(is-boxed (nth est-can 10) %) est-can)" "(count (filter  \#(is-boxed (nth est-can 10) %) est-can))" "(count (split-with  (fn [x] (is-boxed (nth est-can 10) x)) est-can))" "(map count (split-with  (fn [x] (is-boxed (nth est-can 10) x)) est-can))" "(loop [to-group est-can class [] non-class est-can]\\n   (if (empty? cann)\\n     {\:class class  \:non-class non-class}\\n     (recur (rest to-group) \\n            (cons(filter  \#(is-boxed (first to-group) %) non-class)" "(const [1] [1 2])" "(cons\\n  [1] [1 2])" "(apply cons [1] [1 2])" "(apply conj [1] [1 2])" "(apply conj [1 4] [1 2])" "(loop [to-group est-can class [] non-class est-can]\\n   (if (empty? cann)\\n     {\:class class  \:non-class non-class}\\n     (recur (rest to-group) \\n            (conj class (filter  \#(is-boxed (first to-group) %) non-class))\\n            (conj class (filter  \#(not (is-boxed (first to-group) %)) non-class))" "(loop [to-group est-can class [] non-class est-can]\\n   (if (empty? cann)\\n     {\:class class  \:non-class non-class}\\n     (recur (rest to-group) \\n            (conj class (filter  \#(is-boxed (first to-group) %) non-class))\\n            (conj class (filter  \#(not (is-boxed (first to-group) %)) non-class)))))" "(loop [to-group est-can class [] non-class est-can]\\n   (if (empty? to-group)\\n     {\:class class  \:non-class non-class}\\n     (recur (rest to-group) \\n            (conj class (filter  \#(is-boxed (first to-group) %) non-class))\\n            (conj class (filter  \#(not (is-boxed (first to-group) %)) non-class)))))" "(loop [to-group est-can class [] non-class est-can]\\n   (if (empty? to-group)\\n     {\:class class  \:non-class non-class}\\n     (recur (rest to-group) \\n            (conj class (filter  \#(is-boxed (first to-group) %) non-class))\\n            (filter  \#(not (is-boxed (first to-group) %)) non-class))))" "(loop [to-group est-can class [] non-class est-can]\\n   (if (empty? to-group)\\n     {\:class class  \:non-class non-class}\\n            (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)]\\n              (if (not (empty? filter-group)\\n                  (recur (rest to-group) \\n                         (conj class (filter  \#(is-boxed (first to-group) %) non-class))\\n                         (filter  \#(not (is-boxed (first to-group) %)) non-class))\\n                  (recur (rest to-group)\\n                         non-class\\n                         est-can))))))" "(loop [to-group est-can class [] non-class est-can]\\n   (if (empty? to-group)\\n     {\:class class  \:non-class non-class}\\n            (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)]\\n              (if (not (empty? filter-group))\\n                  (recur (rest to-group) \\n                         (conj class (filter  \#(is-boxed (first to-group) %) non-class))\\n                         (filter  \#(not (is-boxed (first to-group) %)) non-class))\\n                  (recur (rest to-group)\\n                         non-class\\n                         est-can)))))" "(loop [to-group est-can class [] non-class est-can]\\n   (if (empty? to-group)\\n     {\:class class  \:non-class non-class}\\n            (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)]\\n              (if (not (empty? filter-group))\\n                  (recur (rest to-group) \\n                         (conj class filter-group)\\n                         (filter  \#(not (is-boxed (first to-group) %)) non-class))\\n                  (recur (rest to-group)\\n                         non-class\\n                         est-can)))))" "(def t (loop [to-group est-can class [] non-class est-can]\\n          (if (empty? to-group)\\n            {\:class class  \:non-class non-class}\\n                   (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)]\\n                     (if (not (empty? filter-group))\\n                         (recur (rest to-group) \\n                                (conj class filter-group)\\n                                (filter  \#(not (is-boxed (first to-group) %)) non-class))\\n                         (recur (rest to-group)\\n                                non-class\\n                                est-can))))))" "(map count t)" "(map (\:class t))" "(count count t)" "(count (\:class t))" "(count (\:non-class t))" "(count est-can)" "(def t (loop [to-group est-can class [] non-class est-can]\\n          (if (empty? to-group)\\n            {\:class class  \:non-class non-class}\\n                   (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)\\n                         _ (print \\"found \: \\" (count filter-group))]\\n                     (if (not (empty? filter-group))\\n                         (recur (rest to-group) \\n                                (conj class filter-group)\\n                                (filter  \#(not (is-boxed (first to-group) %)) non-class))\\n                         (recur (rest to-group)\\n                                non-class\\n                                est-can))))))" "(def t (loop [to-group est-can class [] non-class est-can]\\n          (if (empty? to-group)\\n            {\:class class  \:non-class non-class}\\n                   (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)]\\n                     (if (not (empty? filter-group))\\n                         (recur (rest to-group) \\n                                (apply conj class filter-group)\\n                                (filter  \#(not (is-boxed (first to-group) %)) non-class))\\n                         (recur (rest to-group)\\n                                non-class\\n                                est-can))))))" "(count (\:non-class t))" "(count (\:class t))" "t" "(def t \\n  (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 10) (tgaa.util.shared/canidates))]\\n  (loop [to-group est-can class [] non-class est-can]\\n     (if (empty? to-group)\\n       {\:class class  \:non-class non-class}\\n              (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)]\\n                (if (not (empty? filter-group))\\n                    (recur (rest to-group) \\n                           (apply conj class filter-group)\\n                           (filter  \#(not (is-boxed (first to-group) %)) non-class))\\n                    (recur (rest to-group)\\n                           non-class\\n                           est-can)))))))" "(count (\:class t))" "(count (\:non-class t))" "(def t \\n  (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 5) (tgaa.util.shared/canidates))]\\n  (loop [to-group est-can class [] non-class est-can]\\n     (if (empty? to-group)\\n       {\:class class  \:non-class non-class}\\n              (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)]\\n                (if (not (empty? filter-group))\\n                    (recur (rest to-group) \\n                           (apply conj class filter-group)\\n                           (filter  \#(not (is-boxed (first to-group) %)) non-class))\\n                    (recur (rest to-group)\\n                           non-class\\n                           est-can)))))))" "(count (\:non-class t))" "(count (\:class t))" "(tgaa.util.image/show-cann-path 5)" "(import 'java.awt.Color)" "(tgaa.util.image/show-cann-path 5)" "(tgaa.util.image/show-cann-path 10)" "(def t \\n  (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 15) (tgaa.util.shared/canidates))]\\n  (loop [to-group est-can class [] non-class est-can]\\n     (if (empty? to-group)\\n       {\:class class  \:non-class non-class}\\n              (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)]\\n                (if (not (empty? filter-group))\\n                    (recur (rest to-group) \\n                           (apply conj class filter-group)\\n                           (filter  \#(not (is-boxed (first to-group) %)) non-class))\\n                    (recur (rest to-group)\\n                           non-class\\n                           est-can)))))))" "(count (\:class t))" "(count (\:non-class t))" "(tgaa.util.image/show-cann-path 15)" "(def t \\n  (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 15) (tgaa.util.shared/canidates))]\\n  (loop [to-group (first est-can) class [] non-class est-can]\\n     (if (empty? to-group)\\n       {\:class class  \:non-class non-class}\\n              (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)]\\n                (if (not (empty? filter-group))\\n                    (recur (apply conj filter-group (rest to-group))\\n                           (apply conj class filter-group)\\n                           (filter  \#(not (is-boxed (first to-group) %)) non-class))\\n                    (recur (rest to-group)\\n                           non-class\\n                           est-can)))))))" "(def t \\n  (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 15) (tgaa.util.shared/canidates))]\\n  (loop [to-group (first est-can) class [] non-class est-can]\\n     (if (empty? to-group)\\n       {\:class class  \:non-class non-class}\\n              (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)\\n                    _ (print \\"hear\\")]\\n                (if (not (empty? filter-group))\\n                    (recur (apply conj filter-group (rest to-group))\\n                           (apply conj class filter-group)\\n                           (filter  \#(not (is-boxed (first to-group) %)) non-class))\\n                    (recur (rest to-group)\\n                           non-class\\n                           est-can)))))))" "(def t \\n  (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 15) (tgaa.util.shared/canidates))]\\n  (loop [to-group [(first est-can)] class [] non-class est-can]\\n     (if (empty? to-group)\\n       {\:class class  \:non-class non-class}\\n              (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)\\n                    _ (print \\"hear\\")]\\n                (if (not (empty? filter-group))\\n                    (recur (apply conj filter-group (rest to-group))\\n                           (apply conj class filter-group)\\n                           (filter  \#(not (is-boxed (first to-group) %)) non-class))\\n                    (recur (rest to-group)\\n                           non-class\\n                           est-can)))))))" "(def t \\n  (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 15) (tgaa.util.shared/canidates))]\\n  (loop [to-group [(first est-can)] class [] non-class est-can]\\n     (if (empty? to-group)\\n       {\:class class  \:non-class non-class}\\n              (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)\\n                    _ (print \\"hear\\" (rest to-group))]\\n                (if (not (empty? filter-group))\\n                    (recur (apply conj filter-group (rest to-group))\\n                           (apply conj class filter-group)\\n                           (filter  \#(not (is-boxed (first to-group) %)) non-class))\\n                    (recur (rest to-group)\\n                           non-class\\n                           est-can)))))))" "(def t \\n  (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (tgaa.util.shared/canidates))]\\n  (loop [to-group [(first est-can)] class [] non-class est-can]\\n     (if (empty? to-group)\\n       {\:class class  \:non-class non-class}\\n              (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)\\n                    _ (print \\"hear\\" (rest to-group))]\\n                (if (not (empty? filter-group))\\n                    (recur (apply conj filter-group (rest to-group))\\n                           (apply conj class filter-group)\\n                           (filter  \#(not (is-boxed (first to-group) %)) non-class))\\n                    (recur (rest to-group)\\n                           non-class\\n                           est-can)))))))" "(apply conj [1 2 2] [])" "(apply conj [][1 2 2])" "(def t \\n  (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (tgaa.util.shared/canidates))]\\n  (loop [to-group [(first est-can)] class [] non-class est-can]\\n     (if (empty? to-group)\\n       {\:class class  \:non-class non-class}\\n              (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)\\n                    _ (print \\"hear\\" (rest to-group))]\\n                (if (not (empty? filter-group))\\n                    (recur (apply conj  (rest to-group) filter-group )\\n                           (apply conj class filter-group)\\n                           (filter  \#(not (is-boxed (first to-group) %)) non-class))\\n                    (recur (rest to-group)\\n                           non-class\\n                           est-can)))))))" "\=> (def t \\n     (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (tgaa.util.shared/canidates))]\\n     (loop [to-group [(first est-can)] class [] non-class (rest est-can)]\\n        (if (empty? to-group)\\n          {\:class class  \:non-class non-class}\\n                 (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)\\n                       _ (print \\"test\\")]\\n                   (if (not (empty? filter-group))\\n                       (recur (apply conj  (rest to-group) filter-group )\\n                              (apply conj class filter-group)\\n                              (filter  \#(not (is-boxed (first to-group) %)) non-class))\\n                       (recur (rest to-group)\\n                              non-class\\n                              est-can)))))))" "\=> (def t \\n     (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (tgaa.util.shared/canidates))]\\n     (loop [to-group [(first est-can)] class [] non-class (rest est-can)]\\n        (if (empty? to-group)\\n          {\:class class  \:non-class non-class}\\n                 (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)\\n                       _ (println \\"test\:\\" (count filter-group))]\\n                   (if (not (empty? filter-group))\\n                       (recur (apply conj  (rest to-group) filter-group )\\n                              (apply conj class filter-group)\\n                              (filter  \#(not (is-boxed (first to-group) %)) non-class))\\n                       (recur (rest to-group)\\n                              non-class\\n                              est-can)))))))" "\=> (def t \\n     (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (tgaa.util.shared/canidates))]\\n     (loop [to-group [(first est-can)] class [] non-class (rest est-can)]\\n        (if (empty? to-group)\\n          {\:class class  \:non-class non-class}\\n                 (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)\\n                       _ (println \\"test\:\\" (count filter-group))]\\n                   (if (not (empty? filter-group))\\n                       (recur (apply conj  (rest to-group) filter-group )\\n                              (apply conj class filter-group)\\n                              (filter  \#(not (is-boxed (first to-group) %)) non-class))\\n                       (recur (rest to-group)\\n                              class\\n                              non-class)))))))" "(+ 1 1)" "\=> (def t \\r\\n     (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (tgaa.util.shared/canidates))]\\r\\n     (loop [to-group [(first est-can)] class [] non-class (rest est-can)]\\r\\n        (if (empty? to-group)\\r\\n          {\:class class  \:non-class non-class}\\r\\n                 (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)\\r\\n                       _ (println \\"test\:\\" (count filter-group))]\\r\\n                   (if (not (empty? filter-group))\\r\\n                       (recur (apply conj  (rest to-group) filter-group )\\r\\n                              (apply conj class filter-group)\\r\\n                              (filter  \#(not (is-boxed (first to-group) %)) non-class))\\r\\n                       (recur (rest to-group)\\r\\n                              class\\r\\n                              non-class)))))))" "(process-image)" "\=> (def t \\r\\n     (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (tgaa.util.shared/canidates))]\\r\\n     (loop [to-group [(first est-can)] class [] non-class (rest est-can)]\\r\\n        (if (empty? to-group)\\r\\n          {\:class class  \:non-class non-class}\\r\\n                 (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)\\r\\n                       _ (println \\"test\:\\" (count filter-group))]\\r\\n                   (if (not (empty? filter-group))\\r\\n                       (recur (apply conj  (rest to-group) filter-group )\\r\\n                              (apply conj class filter-group)\\r\\n                              (filter  \#(not (is-boxed (first to-group) %)) non-class))\\r\\n                       (recur (rest to-group)\\r\\n                              class\\r\\n                              non-class)))))))" "(def t \\r\\n     (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (tgaa.util.shared/canidates))]\\r\\n     (loop [to-group [(first est-can)] class [] non-class (rest est-can)]\\r\\n        (if (empty? to-group)\\r\\n          {\:class class  \:non-class non-class}\\r\\n                 (let [filter-group (filter  \#(is-boxed (first to-group) %) non-class)\\r\\n                       _ (println \\"test\:\\" (count filter-group))]\\r\\n                   (if (not (empty? filter-group))\\r\\n                       (recur (apply conj  (rest to-group) filter-group )\\r\\n                              (apply conj class filter-group)\\r\\n                              (filter  \#(not (is-boxed (first to-group) %)) non-class))\\r\\n                       (recur (rest to-group)\\r\\n                              class\\r\\n                              non-class)))))))" "(def t \\r\\n     (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (tgaa.util.shared/canidates))]\\r\\n     (loop [to-group [(first est-can)] class [] non-class (rest est-can)]\\r\\n        (if (empty? to-group)\\r\\n          {\:class class  \:non-class non-class}\\r\\n                 (let [filter-group (filter  \#(tgaa.algo.trial/is-boxed (first to-group) %) non-class)\\r\\n                       _ (println \\"test\:\\" (count filter-group))]\\r\\n                   (if (not (empty? filter-group))\\r\\n                       (recur (apply conj  (rest to-group) filter-group )\\r\\n                              (apply conj class filter-group)\\r\\n                              (filter  \#(not (tgaa.algo.trial/is-boxed (first to-group) %)) non-class))\\r\\n                       (recur (rest to-group)\\r\\n                              class\\r\\n                              non-class)))))))" "(def t \\r\\n     (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (tgaa.util.shared/canidates))]\\r\\n     (loop [to-group [(first est-can)] class [] non-class (rest est-can)]\\r\\n        (if (empty? to-group)\\r\\n          {\:class class  \:non-class non-class}\\r\\n                 (let [filter-group (filter  \#(tgaa.algo.trial/is-boxed (first to-group) %) non-class)]\\r\\n                   (if (not (empty? filter-group))\\r\\n                       (recur (apply conj  (rest to-group) filter-group )\\r\\n                              (apply conj class filter-group)\\r\\n                              (filter  \#(not (tgaa.algo.trial/is-boxed (first to-group) %)) non-class))\\r\\n                       (recur (rest to-group)\\r\\n                              class\\r\\n                              non-class)))))))" "(count (\:non-class t))" "(count (\:class t))" "(tgaa.util.image/show-cann-path 25)" "(import 'java.awt.Color)" "(tgaa.util.image/show-cann-path 25)" "(def t \\r\\n     (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 10) (tgaa.util.shared/canidates))]\\r\\n     (loop [to-group [(first est-can)] class [] non-class (rest est-can)]\\r\\n        (if (empty? to-group)\\r\\n          {\:class class  \:non-class non-class}\\r\\n                 (let [filter-group (filter  \#(tgaa.algo.trial/is-boxed (first to-group) %) non-class)]\\r\\n                   (if (not (empty? filter-group))\\r\\n                       (recur (apply conj  (rest to-group) filter-group )\\r\\n                              (apply conj class filter-group)\\r\\n                              (filter  \#(not (tgaa.algo.trial/is-boxed (first to-group) %)) non-class))\\r\\n                       (recur (rest to-group)\\r\\n                              class\\r\\n                              non-class)))))))" "(count (\:class t))" "(count (\:non-class t))" "(tgaa.util.image/show-cann-path 10)" "(def t \\r\\n     (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 10) (tgaa.util.shared/canidates))]\\r\\n     (loop [to-group [(first est-can)] class [(first est-can)] non-class (rest est-can)]\\r\\n        (if (empty? to-group)\\r\\n          {\:class class  \:non-class non-class}\\r\\n                 (let [filter-group (filter  \#(tgaa.algo.trial/is-boxed (first to-group) %) non-class)]\\r\\n                   (if (not (empty? filter-group))\\r\\n                       (recur (apply conj  (rest to-group) filter-group )\\r\\n                              (apply conj class filter-group)\\r\\n                              (filter  \#(not (tgaa.algo.trial/is-boxed (first to-group) %)) non-class))\\r\\n                       (recur (rest to-group)\\r\\n                              class\\r\\n                              non-class)))))))" "(count (\:class t))" "(def t \\r\\n     (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 1) (tgaa.util.shared/canidates))]\\r\\n     (loop [to-group [(first est-can)] class [(first est-can)] non-class (rest est-can)]\\r\\n        (if (empty? to-group)\\r\\n          {\:class class  \:non-class non-class}\\r\\n                 (let [filter-group (filter  \#(tgaa.algo.trial/is-boxed (first to-group) %) non-class)]\\r\\n                   (if (not (empty? filter-group))\\r\\n                       (recur (apply conj  (rest to-group) filter-group )\\r\\n                              (apply conj class filter-group)\\r\\n                              (filter  \#(not (tgaa.algo.trial/is-boxed (first to-group) %)) non-class))\\r\\n                       (recur (rest to-group)\\r\\n                              class\\r\\n                              non-class)))))))" "(count (\:class t))" "(count (\:non-class t))" "(tgaa.util.image/show-cann-path 1)" "(tgaa.util.image/show-cann-path 2)" "(def t \\r\\n     (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 2) (tgaa.util.shared/canidates))]\\r\\n     (loop [to-group [(first est-can)] class [(first est-can)] non-class (rest est-can)]\\r\\n        (if (empty? to-group)\\r\\n          {\:class class  \:non-class non-class}\\r\\n                 (let [filter-group (filter  \#(tgaa.algo.trial/is-boxed (first to-group) %) non-class)]\\r\\n                   (if (not (empty? filter-group))\\r\\n                       (recur (apply conj  (rest to-group) filter-group )\\r\\n                              (apply conj class filter-group)\\r\\n                              (filter  \#(not (tgaa.algo.trial/is-boxed (first to-group) %)) non-class))\\r\\n                       (recur (rest to-group)\\r\\n                              class\\r\\n                              non-class)))))))" "(count (\:non-class t))" "(count (\:class t))" "(tgaa.util.image/show-cann-path 2)" "(tgaa.util.image/show-cann-path 3)" "(def t \\r\\n     (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 3) (tgaa.util.shared/canidates))]\\r\\n     (loop [to-group [(first est-can)] class [(first est-can)] non-class (rest est-can)]\\r\\n        (if (empty? to-group)\\r\\n          {\:class class  \:non-class non-class}\\r\\n                 (let [filter-group (filter  \#(tgaa.algo.trial/is-boxed (first to-group) %) non-class)]\\r\\n                   (if (not (empty? filter-group))\\r\\n                       (recur (apply conj  (rest to-group) filter-group )\\r\\n                              (apply conj class filter-group)\\r\\n                              (filter  \#(not (tgaa.algo.trial/is-boxed (first to-group) %)) non-class))\\r\\n                       (recur (rest to-group)\\r\\n                              class\\r\\n                              non-class)))))))" "(count (\:class t))" "(count (\:non-class t))" "(tgaa.util.image/show-cann-path 3)" "(defn group [non-group]\\r\\n     (loop [to-group [(first non-group)] grouping [(first non-group)] working-non-group (rest non-group)]\\r\\n        (if (empty? to-group)\\r\\n          {\:group grouping  \:non-group working-non-group}\\r\\n                 (let [filter-group (filter  \#(tgaa.algo.trial/is-boxed (first to-group) %) working-non-group)]\\r\\n                   (if (not (empty? filter-group))\\r\\n                       (recur (apply conj  (rest to-group) filter-group )\\r\\n                              (apply conj grouping filter-group)\\r\\n                              (filter  \#(not (tgaa.algo.trial/is-boxed (first to-group) %)) working-non-group))\\r\\n                       (recur (rest to-group)\\r\\n                              grouping\\r\\n                              working-non-group))))))" "(def t (group (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 3) (tgaa.util.shared/canidates))))" "(count (\:grouping t))" "(count (\:group\\n         t))" "(count (\:non-group\\n         t))" "(def t \\r\\n  (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 2) (tgaa.util.shared/canidates))]\\r\\n    (loop [non-group est-can groups [] group-id 0]\\n      (if (empty? non-group)\\n        group\\n        (let [[group-res non-group-res  ] (make-group non-group)]\\n        (recur non-group-res  \\n               (apply conj groups (map \#(assoc % \:group group-id) group-res))\\n               (inc group-id)))))))" "\\r\\n(defn make-group [non-group]\\r\\n  (loop [to-group [(first non-group)] grouping [(first non-group)] working-non-group (rest non-group)]\\r\\n    (if (empty? to-group)\\r\\n      [grouping  working-non-group]\\r\\n      (let [filter-group (filter  \#(tgaa.algo.trial/is-boxed (first to-group) %) working-non-group)]\\r\\n        (if (not (empty? filter-group))\\r\\n          (recur (apply conj  (rest to-group) filter-group )\\r\\n                 (apply conj grouping filter-group)\\r\\n                 (filter  \#(not (tgaa.algo.trial/is-boxed (first to-group) %)) working-non-group))\\r\\n          (recur (rest to-group)\\r\\n                 grouping\\r\\n                 working-non-group))))))" "(def t \\r\\n  (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 2) (tgaa.util.shared/canidates))]\\r\\n    (loop [non-group est-can groups [] group-id 0]\\n      (if (empty? non-group)\\n        group\\n        (let [[group-res non-group-res  ] (make-group non-group)]\\n        (recur non-group-res  \\n               (apply conj groups (map \#(assoc % \:group group-id) group-res))\\n               (inc group-id)))))))" "t" "(def t \\r\\n  (let [est-can (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 2) (tgaa.util.shared/canidates))]\\r\\n    (loop [non-group est-can groups [] group-id 0]\\n      (if (empty? non-group)\\n        groups\\n        (let [[group-res non-group-res  ] (make-group non-group)]\\n        (recur non-group-res  \\n               (apply conj groups (map \#(assoc % \:group group-id) group-res))\\n               (inc group-id)))))))" "t" "\\r\\n(defn make-groups [cann-path]\\r\\n  (loop [non-group cann-path groups [] group-id 0]\\n    (if (empty? non-group)\\n      groups\\n      (let [[group-res non-group-res  ] (make-group non-group)]\\n        (recur non-group-res  \\n               (apply conj groups (map \#(assoc % \:group group-id) group-res))\\n               (inc group-id))))))" "(make-groups)" "(make-groups (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 2) (tgaa.util.shared/canidates)))" "\\r\\n(key 1)" "\\r\\n(key \\"1\\")" "\\r\\n(keyword 1)" "\\r\\n(keyword \\"1\\")" "\\r\\n(keyword (str 1))" "(defn make-groups [cann-path]\\r\\n  (loop [non-group cann-path groups [] meta-data {} group-id 0]\\r\\n    (if (empty? non-group)\\r\\n      [groups meta-data]\\r\\n      (let [[group-res non-group-res  ] (make-group non-group)]\\r\\n        (recur non-group-res  \\r\\n               (apply conj groups (map \#(assoc % \:group group-id) group-res))\\r\\n               (assoc meta-data (keyword (str group-id)) (count group-res))\\r\\n               (inc group-id))))))" "(make-groups (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 2) (tgaa.util.shared/canidates)))" "(defn make-groups [cann-path]\\r\\n  (loop [non-group cann-path groups [] meta-data {} group-id 0]\\r\\n    (if (empty? non-group)\\r\\n      [\:groups groups \:group-data meta-data]\\r\\n      (let [[group-res non-group-res  ] (make-group non-group)]\\r\\n        (recur non-group-res  \\r\\n               (apply conj groups (map \#(assoc % \:group group-id) group-res))\\r\\n               (assoc meta-data (keyword (str group-id)) (count group-res))\\r\\n               (inc group-id))))))" "(make-groups (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 2) (tgaa.util.shared/canidates)))" "(make-groups (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25) (tgaa.util.shared/canidates)))" "(filter \#(print %) {\:2 1, \:1 1, \:0 19})" "(filter \#(>\= (second) 4) {\:2 1, \:1 1, \:0 19})" "(filter \#(>\= (second %) 4) {\:2 1, \:1 1, \:0 19})" "(contains? 1 [1 2])" "(contains? [1 2] 1)" "(contains? [1 2] 2)" "(contains? [1 2 3 4] 2)" "(contains? [1 2 3 4] 4)" "(contains? [1 2 3 4] 3)" "(contains? {\:2 3\\n            } 3)" "(contains? {\:3 3\\n            } 3)" "(contain? {\:1 1} 1)" "(contains? {\:1 1} 1)" "(contains? {\:1 1} \:1)" "(phase/load-image)" " (phase/bootstrap)" "(phase/trapping)" "(phase/evaluation)" "(tgaa.algo.trial )" "(tgaa.algo.trial/salient-regions )" "(+ 1 10)" "(def groups (make-groups \\r\\n                 (filter \#(\= (tgaa.algo.ant/ant-trial-num %) (shared/get-num-trails)) \\r\\n                         (tgaa.util.shared/canidates))))" "(def groups (tgaa.algo.trial/make-groups \\r\\n                 (filter \#(\= (tgaa.algo.ant/ant-trial-num %) (shared/get-num-trails)) \\r\\n                         (tgaa.util.shared/canidates))))" "(def groups (tgaa.algo.trial/make-groups \\r\\n                 (filter \#(\= (tgaa.algo.ant/ant-trial-num %) (tgaa.util.shared/get-num-trails)) \\r\\n                         (tgaa.util.shared/canidates))))" "(def  min-conn-group-ids (filter \#(>\= (second %) shared/min-conn-thresh) (\:group-data groups)))" "(tgaa.algo.trial/salient-regions )" "( shared/min-conn-thresh)" "(def min-conn-group-ids (filter \#(>\= (second %)( tgaa.util.shared/min-conn-thresh)) (\:group-data groups)))" " (shared/add-salient-paths  (filter \#(contains? min-conn-group-ids (keyword (str (ant/ant-group %)))) groups))))" " (shared/add-salient-paths  (filter \#(contains? min-conn-group-ids (keyword (str (ant/ant-group %)))) groups))" " (tgaa.util.shared/add-salient-paths  (filter \#(contains? min-conn-group-ids (keyword (str (ant/ant-group %)))) groups))" " (tgaa.util.shared/add-salient-paths  (filter \#(contains? min-conn-group-ids (keyword (str (tgaa.algo.ant/ant-group %)))) groups))" " (tgaa.util.shared/add-salient-paths  (filter \#(contains? {\:1 1} (keyword (str (tgaa.algo.ant/ant-group %)))) groups))" "min-conn-group-ids" "groups" "( tgaa.util.shared/min-conn-thresh)" "(\:group-data groups)" "groups" "(\:group-data groups)" "(\:group-data group)" "(keys groups)" "(tgaa.algo.trial/salient-regions )" "(def groups (tgaa.algo.trial/make-groups \\r\\n                 (filter \#(\= (tgaa.algo.ant/ant-trial-num %) (tgaa.util.shared/get-num-trails)) \\r\\n                         (tgaa.util.shared/canidates))))" "groups" "(def min-conn-group-ids (filter \#(>\= (second %)( tgaa.util.shared/min-conn-thresh)) (\:group-data groups)))" " min-conn-group-ids" "(def min-conn-group-ids (into {} (flatten (filter \#(>\= (second %)( tgaa.util.shared/min-conn-thresh)) (\:group-data groups)))))" "(def min-conn-group-ids (flatten (filter \#(>\= (second %)( tgaa.util.shared/min-conn-thresh)) (\:group-data groups))))" " min-conn-group-ids" "(def min-conn-group-ids (into {} (flatten (filter \#(>\= (second %)( tgaa.util.shared/min-conn-thresh)) (\:group-data groups)))))" "(flatten (filter \#(>\= (second %)( tgaa.util.shared/min-conn-thresh)) (\:group-data groups)))" "(keys (flatten (filter \#(>\= (second %)( tgaa.util.shared/min-conn-thresh)) (\:group-data groups))))" "(flatten (filter \#(>\= (second %)( tgaa.util.shared/min-conn-thresh)) (\:group-data groups)))" "(into {} '(\:1 7))" "(flatten (map first (filter \#(>\= (second %)( tgaa.util.shared/min-conn-thresh)) (\:group-data groups))))" "(def min-conn-group-ids (flatten (map first (filter \#(>\= (second %)( tgaa.util.shared/min-conn-thresh)) (\:group-data groups))))" "(def min-conn-group-ids (flatten (map first (filter \#(>\= (second %)( tgaa.util.shared/min-conn-thresh)) (\:group-data groups)))))" " (tgaa.util.shared/add-salient-paths  (filter \#(contains? {\:1 1} (keyword (str (tgaa.algo.ant/ant-group %)))) groups))" "tgaa.util.shared/salient-paths" "(tgaa.util.shared/salient-paths)" " (tgaa.util.shared/add-salient-paths  (filter \#(contains? min-conn-group-ids (keyword (str (tgaa.algo.ant/ant-group %)))) groups))" "(tgaa.algo.trial/salient-regions)" "min-conn-group-ids" "(def groups (tgaa.algo.trial/make-groups \\r\\n                 (filter \#(\= (tgaa.algo.ant/ant-trial-num %) (tgaa.util.shared/get-num-trails)) \\r\\n                         (tgaa.util.shared/canidates))))" "(def min-conn-group-ids (flatten (map first (filter \#(>\= (second %)( tgaa.util.shared/min-conn-thresh)) (\:group-data groups)))))" " (tgaa.util.shared/add-salient-paths  (filter \#(contains? min-conn-group-ids (keyword (str (tgaa.algo.ant/ant-group %)))) groups))" "min-conn-group-ids" " (tgaa.util.shared/add-salient-paths  (filter \#(contains? min-conn-group-ids (keyword (str (tgaa.algo.ant/ant-group %)))) groups))" " (tgaa.util.shared/add-salient-paths  (filter \#(contains? '(\:1) min-conn-group-ids (keyword (str (tgaa.algo.ant/ant-group %)))) groups))" " (filter \#(contains? '(\:1) min-conn-group-ids (keyword (str (tgaa.algo.ant/ant-group %)))) groups)" " (filter \#(contains? min-conn-group-ids (keyword (str (tgaa.algo.ant/ant-group %)))) groups)" " (filter \#(contains? (into [] min-conn-group-ids) (keyword (str (tgaa.algo.ant/ant-group %)))) groups)" "(map \#(keyword (str (tgaa.algo.ant/ant-group %))) groups)" "(map \#((tgaa.algo.ant/ant-group %)) groups)" "(map \#(tgaa.algo.ant/ant-group %) groups)" "groups" " (filter \#(contains? (into [] min-conn-group-ids) (keyword (str (tgaa.algo.ant/ant-group %)))) (\:groups groups))" "(map \#(tgaa.algo.ant/ant-group %) (\:groups groups))" " (filter \#(contains? (into [] min-conn-group-ids) (keyword (str (tgaa.algo.ant/ant-group %)))) (\:groups groups))" " (filter \#(contains? (into [] min-conn-group-ids) (apply keyword (str (tgaa.algo.ant/ant-group %)))) (\:groups groups))" "(map \#(tgaa.algo.ant/ant-group %) (\:groups groups))" "(map \#(keyworkd (str tgaa.algo.ant/ant-group %)) (\:groups groups))" "(map \#(keyworkd (str (tgaa.algo.ant/ant-group %))) (\:groups groups))" "(map \#(keyword (str (tgaa.algo.ant/ant-group %))) (\:groups groups))" " (filter \#(contains? (into [] min-conn-group-ids) (apply keyword (str (tgaa.algo.ant/ant-group %)))) (\:groups groups))" " (filter \#(contains? (into [] min-conn-group-ids) (keyword (str 1))) (\:groups groups))" " (filter \#(contains? (into [] min-conn-group-ids) (keyword (str 1 (tgaa.algo.ant/ant-group %)))) (\:groups groups))" " (filter \#(contains? (into [] min-conn-group-ids) (do (println (tgaa.algo.ant/ant-group %)) (keyword (str 1))) (\:groups groups))" " (filter \#(contains? (into [] min-conn-group-ids) (do (println (tgaa.algo.ant/ant-group %)) (keyword (str 1)))) (\:groups groups))" " (filter \#(contains? (into [] min-conn-group-ids) (do (println (keyword (str tgaa.algo.ant/ant-group %))) (keyword (str 1)))) (\:groups groups))" "(first (\:groups groups))" "(tgaa.algo.ant/ant-group (first (\:groups groups)))" " (filter \#(contains? (into [] min-conn-group-ids) (do (println (keyword (str (tgaa.algo.ant/ant-group %)))) (keyword (str 1)))) (\:groups groups))" " (filter \#(contains? (into [] min-conn-group-ids) (keyword (str (tgaa.algo.ant/ant-group %)))) (\:groups groups))" " (filter \#(contains? \:1(keyword (str (tgaa.algo.ant/ant-group %)))) (\:groups groups))" " (filter \#(contains? [\:1] (keyword (str (tgaa.algo.ant/ant-group %)))) (\:groups groups))" " (filter \#(contains? [\:0] (keyword (str (tgaa.algo.ant/ant-group %)))) (\:groups groups))" " (filter \#(contains? [\:0] (do (keyword (str (tgaa.algo.ant/ant-group %)))(keyword (str (tgaa.algo.ant/ant-group %))))) (\:groups groups))" " (filter \#(contains? [\:0] (do (println (keyword (str (tgaa.algo.ant/ant-group %))))(keyword (str (tgaa.algo.ant/ant-group %))))) (\:groups groups))" "(contains? [\:1] \:1)" "(contains? {\:1 1} \:1)" "(def min-conn-group-ids (flatten (map first (filter \#(>\= (second %)( tgaa.util.shared/min-conn-thresh)) (\:group-data groups)))))" "(def min-conn-group-ids (flatten (filter \#(>\= (second %)( tgaa.util.shared/min-conn-thresh)) (\:group-data groups))))" " min-conn-group-ids" "(into [] min-conn-group-ids)" "(into {} min-conn-group-ids)" "(hash-map min-conn-group-ids)" "(apply hash-map min-conn-group-ids)" "(def min-conn-group-ids (apply hash-map (flatten (filter \#(>\= (second %)( tgaa.util.shared/min-conn-thresh)) (\:group-data groups)))))" "(def min-conn-group-ids (flatten (filter \#(>\= (second %)( tgaa.util.shared/min-conn-thresh)) (\:group-data groups))))" "(def min-conn-group-ids (apply hash-map (flatten (filter \#(>\= (second %)( tgaa.util.shared/min-conn-thresh)) (\:group-data groups)))))" " (filter \#(contains? (into [] min-conn-group-ids) (keyword (str 1 (tgaa.algo.ant/ant-group %)))) (\:groups groups))" " (filter \#(contains? min-conn-group-ids (keyword (str 1 (tgaa.algo.ant/ant-group %)))) (\:groups groups))" "min-conn-group-ids" " (filter \#(contains? min-conn-group-ids (keyword (str (tgaa.algo.ant/ant-group %)))) (\:groups groups))" "(tgaa.algo.trial/salient-regions)" "(in-ns 'tgaa.algo.trial\\n       )" "(def groups (make-groups \\r\\n                 (filter \#(\= (tgaa.algo.ant/ant-trial-num %) (shared/get-num-trails)))))" "(def groups (make-groups (filter \#(\= (tgaa.algo.ant/ant-trial-num %)) (shared/get-num-trails))))" "(def groups groups (make-groups \\r\\n                 (filter \#(\= (tgaa.algo.ant/ant-trial-num %) (shared/get-num-trails)) \\r\\n                         (tgaa.util.shared/canidates))))" "(def groups  (make-groups \\r\\n                 (filter \#(\= (tgaa.algo.ant/ant-trial-num %) (shared/get-num-trails)) \\r\\n                         (tgaa.util.shared/canidates))))" "(def min-conn-group-ids (apply hash-map (flatten (map first (filter \#(>\= (second %)( shared/min-conn-thresh)) (\:group-data groups))))))" "(def min-conn-group-ids (apply hash-map (flatten (filter \#(>\= (second %)( shared/min-conn-thresh)) (\:group-data groups)))))" "min-conn-group-ids" "(salient-regions)" "(process-image)" "(tgaa.util.shared/salient-paths)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(phase/evaluation)" "(salient-regions)" "(tgaa.util.shared/salient-paths)" "(tgaa.util.image/anim-trail-paths)" "(import 'java.awt.Color)" "(tgaa.util.image/anim-trail-paths)" "(phase/load-image)\\r\\n       (phase/bootstrap)\\r\\n       (phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(phase/load-image)\\r\\n       (phase/bootstrap)\\r\\n       (phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(filter \#(\= (tgaa.algo.ant/ant-trial-num %) 1)(tgaa.util.shared/canidates))" "(filter \#(\= (tgaa.algo.ant/ant-trial-num %) 0)(tgaa.util.shared/canidates))" "(map \#(tgaa.algo.ant/ant-trial-num %) (tgaa.util.shared/canidates))" "(filter \#(\= (tgaa.algo.ant/ant-trial-num %) 2)(tgaa.util.shared/canidates))" "(filter \#(\= (tgaa.algo.ant/ant-trial-num %) 75)(tgaa.util.shared/canidates))" "(shared/get-num-trails)" "(tgaa.util.shared/get-num-trails)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.shared/thresh)" "(tgaa.util.image/anim-trail-paths)" "(import 'java.awt.Color)" "(tgaa.util.image/anim-trail-paths)" "(filter \#(- tgaa.algo.ant/ant-trial-num 25)  tgaa.util.shared/canidates)" "(filter \#(\= tgaa.algo.ant/ant-trial-num 25)  tgaa.util.shared/canidates)" "(filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25)  tgaa.util.shared/canidates)" "(filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25)  (tgaa.util.shared/canidates))" "(map \#(\:path-length %) (filter \#(\= (tgaa.algo.ant/ant-trial-num %) 25)  (tgaa.util.shared/canidates)))" "(tgaa.util.image/anim-trail-paths)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(import 'java.awt.Color)" "(tgaa.util.image/anim-trail-paths)" "(reset\! t)" "(keyword? t)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/init-trail-state)" "(process-image)" "(tgaa.util.image/anim-trail-paths)" "(phase/load-image)" " (phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/get-config)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" " (phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" " (phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(map (tgaa.algo.ant/ant-trial-num) tgaa.util.shared/canidates)" "(map (tgaa.algo.ant/ant-trial-num %) tgaa.util.shared/canidates)" "(map \#(tgaa.algo.ant/ant-trial-num %) tgaa.util.shared/canidates)" "(map \#(tgaa.algo.ant/ant-trial-num %) (tgaa.util.shared/canidates))" "(phase/load-image)" " (phase/bootstrap)" "(phase/trapping)" "(tgaa.util.shared/config)" "(tgaa.util.shared/get-config)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" " (phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(import 'java.awt.Color)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" " (phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(phase/evaluation)" "(shared/salient-paths)" "(tgaa.util.shared/salient-paths)" "(count (tgaa.util.shared/salient-paths))" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" " (phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(take 10 [4 4])" "(take 1 [4 4])" "(take 10 [4 4])" "(take 4 (cycle [4 4]))" "(take 4 (cycle [4 5]))" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" " (phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" " (phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" " (phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" " (phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" " (phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" " (phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" " (phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" " (phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/init-trail-state)\\r\\n    (phase/load-image)\\r\\n       (phase/bootstrap)\\r\\n       (phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/init-trail-state)\\r\\n    (phase/load-image)\\r\\n       (phase/bootstrap)\\r\\n       (phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(import 'java.awt.Color)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/config)" "(tgaa.util.shared/get-config)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/get-config)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/init-trail-state)" "(tgaa.util.shared/get-config)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/init-trail-state)" "(tgaa.util.shared/get-config)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(phase/load-image)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.ant-path/init-trail-paths)" "(tgaa.util.ant-path/num-of-random-starts)" "(tgaa.util.ant-path/num-of-phero-starts)" "(in-ns 'tgaa.util.ant-path)" "(random-point 2)" "(random-point num-of-random-starts))" "(random-point num-of-random-starts)" "(random-point (num-of-random-starts))" "(phero-points \\r\\n           (num-of-phero-starts))" "(num-of-phero-starts)" "(phero-points \\r\\n           (num-of-phero-starts))" "(phero-points 4)" "(phero-points 1)" "(or (empty? (shared/canidates)) (> 1 num))" "(empty? (shared/canidates))" "(phero-points 4)" "(def bias-paths (take 10 (cycle (shuffle (shared/canidates)))))" "bias-paths" "(def  lengths (map \#(ant/ant-path-length %) bias-paths))" "lengths" "(count lengths)" "(def           start-loc (map \#(ant/path-loc-at-time %1 %2)\\r\\n                         bias-paths\\r\\n                         (map rand-int lengths)))" "start-loc" "(phero-points 4)" "    (let [bias-paths (take 5 (cycle (shuffle (shared/canidates))))\\r\\n          lengths (map \#(ant/ant-path-length %) bias-paths)\\r\\n          start-loc (map \#(ant/path-loc-at-time %1 %2)\\r\\n                         bias-paths\\r\\n                         (map rand-int lengths))]\\r\\n      \\r\\n    start-loc)" "(phero-points 4)" "(in-ns 'tgaa.algo.core)" "(tgaa.util.ant-path/init-trail-paths)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/thresh)" "(in-ns 'tgaa.algo.trial/trap-escaped-thresh [])" "(in-ns 'tgaa.algo.trial/trap-escaped-thresh)" "(trap-escaped-thresh nil)" "(tgaa.algo.trial/trap-escaped-thresh nil)" "(tgaa.algo.trial/trap-escaped-thresh [])" "(in-ns 'tgaa.algo.phases)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(in-ns 'tgaa.algo.phases)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(import 'java.awt.Color)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/get-config)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(map \#(tgaa.algo.ant/ant-path-length %)(filter \#(\= 25 (tgaa.util.shared/trial-num %)) (tgaa.util.shared/canidates)))" "(map \#(tgaa.algo.ant/ant-path-length %)(filter \#(\= 25 (tgaa.algo.ant/ant-trial-num %)) (tgaa.util.shared/canidates)))" "(tgaa.util.shared/get-config)" "(tgaa.util.shared/config (tgaa.util.shared/get-config))" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(map \#(tgaa.algo.ant/ant-path-length %)(filter \#(\= 25 (tgaa.algo.ant/ant-trial-num %)) (tgaa.util.shared/canidates)))" "(map \#(tgaa.algo.ant/ant-path-length %)(filter \#(\= 24 (tgaa.algo.ant/ant-trial-num %)) (tgaa.util.shared/canidates)))" "(tgaa.util.image/anim-trail-paths)" "(map \#(tgaa.algo.ant/ant-path-length %)(filter \#(\= 24 (tgaa.algo.ant/ant-trial-num %)) (tgaa.util.shared/canidates)))" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(keyword 1)" "(keyword (str 1))" "(assoc {\:1 1 \:2 2} \:3 2)" "(assoc {\:1 1 \:2 2} \:3 3)" "(assoc {\:1 1 \:2 2} \:2 [3])" "(defn trial-info \\r\\n  [key value]\\r\\n  (if-not (or (nill? key) (nil? value))\\r\\n    (let [trail-key (keyword (str (trial-num)))\\r\\n          info-run (if (nil? (\:trial-log  @trial-state ))\\r\\n                             {}\\r\\n                             (\:trial-log  @trial-state ))\\r\\n          info-trial (if (nil? (trail-key info-run))\\r\\n                       {}\\r\\n                       (trail-key info-run))]\\r\\n      ((reset\! trial-state  (assoc @trail-state \:trail-log  (assoc info-run trial-key (assoc info-trial key value))))))))" "(defn trial-info \\r\\n  [key value]\\r\\n  (if-not (or (nil? key) (nil? value))\\r\\n    (let [trail-key (keyword (str (trial-num)))\\r\\n          info-run (if (nil? (\:trial-log  @trial-state ))\\r\\n                             {}\\r\\n                             (\:trial-log  @trial-state ))\\r\\n          info-trial (if (nil? (trail-key info-run))\\r\\n                       {}\\r\\n                       (trail-key info-run))]\\r\\n      ((reset\! trial-state  (assoc @trail-state \:trail-log  (assoc info-run trial-key (assoc info-trial key value))))))))" "(in-ns 'tgaa.util.shared)" "(defn trial-info \\r\\n  [key value]\\r\\n  (if-not (or (nil? key) (nil? value))\\r\\n    (let [trail-key (keyword (str (trial-num)))\\r\\n          info-run (if (nil? (\:trial-log  @trial-state ))\\r\\n                             {}\\r\\n                             (\:trial-log  @trial-state ))\\r\\n          info-trial (if (nil? (trail-key info-run))\\r\\n                       {}\\r\\n                       (trail-key info-run))]\\r\\n      ((reset\! trial-state  (assoc @trail-state \:trail-log  (assoc info-run trial-key (assoc info-trial key value))))))))" "(trial-info \:test 4)" "(keyword (str (trial-num)))" "(if (nil? (\:trial-log  @trial-state ))\\r\\n                             {}\\r\\n                             (\:trial-log  @trial-state ))" "(\:0 {})" "(trial-info \:test 4)" "(+ 1 1)" "(trial-info \:test 4)" "(trial-info \:test2 4)" "(trial-info \:t 4)" "@trial-state" "(trial-info \:tw 4)" "(trial-info \:tw 43)" "(trial-info \:tw 4)" "@trial-state" "(trial-info \:tw 4)" "(trial-info \:twq 4)" "(trial-info \:twqw 4q)" "(trial-info \:twqw 132323)" "(inc-trial)" "(trial-info \:twqw 132323)" "(trial-info \:twqw 4q)" "(trial-info \:tw 4)" "(gensym)" "(str \\"error\\" gensym)" "(str \\"error\\" (gensym))" "(trial-info-error \\"this is an error\\")" "(trial-info \:tw 4)" "(trial-info-error \\"this is an error\\")" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(tgaa.util.shared/init-trail-state)" " (phase/load-image)" " (phase/bootstrap)" "(phase/trapping)" "(tgaa.util.shared/trial-logs)" "(tgaa.util.image/anim-trail-paths)" "(import 'java.awt.Color)" "(tgaa.util.image/anim-trail-paths)" "(sort \#(compare (last %1) (last %2)) (tgaa.util.image/anim-trail-paths))" "(sort \#(compare (last %1) (last %2)) (tgaa.util.shared/trial-logs))" "(name \:1)" "(class (name \:1))" "(sort \#(name %) (tgaa.util.shared/trial-logs))" "(name \:1)" "(int (name \:1))" "(Integer (name \:1))" "(Integer. (name \:1))" "(sort \#(< (Integer. name %1) (Integer. name %2)) (tgaa.util.shared/trial-logs))" "(sort \#(< (Integer. (name %1)) (Integer. (name %2))) (tgaa.util.shared/trial-logs))" "(sort \#(< (Integer. (name (first %1))) (Integer. (first (name %2)))) (tgaa.util.shared/trial-logs))" "(sort \#(< (Integer. (name (first %1))) (Integer. (name (first %2)))) (tgaa.util.shared/trial-logs))" "(tgaa.util.shared/trial-logs)" "(sort \#(< (Integer. (name (first %1))) (Integer. (name (first %2)))) (tgaa.util.shared/trial-logs))" "(tgaa.util.shared/trial-logs)" "(sort \#(< (Integer. (name (first %1))) (Integer. (name (first %2)))) (tgaa.util.shared/trial-logs))" "tgaa.util.shared/trial-state" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.shared/trial-logs)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/trial-logs)" "(tgaa.util.shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(tgaa.util.shared/trial-logs)" "(tgaa.util.image/anim-trail-paths)" "(tgaa.util.shared/trial-logs)"]
eclipse.preferences.version=1
