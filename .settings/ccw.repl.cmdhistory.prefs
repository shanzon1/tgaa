cmdhistory=["(first (shared/salient-ids))" "(filter \#(\= \:13 (keyword (\:group %))) (shared/salient-ids))" "(map \:13 (shared/salient-ids))" "(shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(phase/evaluation)" "(viz/animate-algo)" "(import 'java.awt.Color)" "(viz/animate-algo)" "(shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(phase/evaluation)" "(viz/animate-algo)" "(tgaa.algo.analysis/salient-regions)" "(tgaa.algo.analysis/edge-stats-by-group)" "(shared/salient-ids)" "(shared/salient-results)" "(viz/animate-algo)" "(first (shared/salient-ids))" "(count (shared/salient-ids))" "(viz/animate-algo)" "(shared/thresh)" "(viz/show-segmentaton 158)" "(viz/show-segmentaton 100)" "(shared/trial-info-cand 10)" "(viz/animate-algo)" "(shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(phase/evaluation)" "(viz/animate-algo)" "(first(shared/salient-results))" "(shared/salient-results)" "(tgaa.util.visualize/show-cann-path)" "(tgaa.util.visualize/show-cann-path 15)" "(tgaa.util.visualize/show-cann-path 20)" "(shared/salient-results)" "(shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(phase/evaluation)" "(viz/animate-algo)" "(shared/salient-ids)" "(shared/salient-results)" "(tgaa.util.visualize/show_salient_paths)" "(draw-salient-paths)" "(tgaa.util.visualize/draw-salient-paths)" "(tgaa.util.visualize/show_salient_paths)" "(tgaa.util.visualize/show-salient-paths)" "(first (shared/salient-ids))" "(tgaa.util.visualize/show-salient-paths)" "(shared/salient-results)" "(filter \#(contains? [\:0 \:1] (\:t %)) [{\:t \:0} {\:t \:3}])" "(\:t {\:t \:1})" "(filter \#(\= \:0 (\:t %)) [{\:t \:0} {\:t \:3}])" "(filter \#(some? \:0 (\:t %)) [{\:t \:0} {\:t \:3}])" "(filter \#(some? [\:0 \:1] (\:t %)) [{\:t \:0} {\:t \:3}])" "(\:group (shared/salient-ids))" "(count (filter \#(get (shared/salient-results) (\:group %) (shared/salient-ids)))" "(count (filter \#(get (shared/salient-results) (\:group %) (shared/salient-ids))))" " (filter \#(get (shared/salient-results) (\:group %) (shared/salient-ids)))" " (count (filter \#(get (shared/salient-results) (\:group %)) (shared/salient-ids)))" "(first (shared/salient-ids))" "(\:keyword 10)" "(keyword 10)" " (count (filter \#(get (shared/salient-results) (key (\:group %))) (shared/salient-ids)))" "(key 0)" " (count (filter \#(get (shared/salient-results) (key (str (\:group %)))) (shared/salient-ids)))" "(key (str 0))" "(keyword (set 0))" "(keyword \\"a\\")" "(keyword (str 0))" " (count (filter \#(get (shared/salient-results) (keyword (str (\:group %)))) (shared/salient-ids)))" "(shared/salient-results)" "(flatten ([\:4 35] [\:0 1576]))" "(flatten '([\:4 35] [\:0 1576]))" "(into {} (flatten '([\:4 35] [\:0 1576])))" "(into {} ([\:4 35] [\:0 1576]))" "(flatten '([\:4 35] [\:0 1576]))" "(hash-map '([\:4 35] [\:0 1576]))" "(hash-map [\:4 35] [\:0 1576])" "(hash-map \:4 35 \:0 1576)" "(shared/salient-results)" "(hash-map (shared/salient-results))" "(hash-map (flatten (shared/salient-results)))" "(flatten (shared/salient-results))" "(apply hash-map (flatten (shared/salient-results)))" "(flatten (filter \#(>\= (second %)( shared/min-conn-thresh)) (\:group-data groups)))" "(shared/salient-results)" "(apply hash-map (flatten (shared/salient-results)))" " (count (filter \#(get (apply hash-map (flatten (shared/salient-results))) (keyword (str (\:group %)))) (shared/salient-ids)))" " (count (filter \#(get {\:0 1} (keyword (str (\:group %)))) (shared/salient-ids)))" " (count (filter \#(get {\:4 1} (keyword (str (\:group %)))) (shared/salient-ids)))" "(shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(phase/evaluation)" "(viz/animate-algo)" "(shared/salient-results)" "(tgaa.util.visualize/show-segmentaton (shared/thresh))" "(shared/thresh)" "(tgaa.util.visualize/show-segmentaton 100)" "(viz/animate-algo)" "(shared/thresh)" "(tgaa.util.visualize/show-segmentaton)" "(shared/trial-logs)" "(tgaa.util.visualize/show-segmentaton 100)" "(viz/animate-algo)" "(shared/init-trail-state)" "  (phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(phase/evaluation)" "(phase/trapping)" "(phase/bootstrap)" "(shared/init-trail-state)" "(phase/load-image)" " (phase/bootstrap)" "(phase/trapping)" " (phase/evaluation)" "(viz/animate-algo)" "(import 'java.awt.Color)" "(viz/animate-algo)" "(shared/init-trail-state)" "(phase/load-image)" "(process-image)" "(shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(phase/evaluation)" "(viz/animate-algo)" "(shared/thresh)" "(viz/show-segmentaton 149)" "(viz/animate-algo)" "(viz/show-image)" "(viz/animate-algo)" "(shared/salient-ids)" "(shared/salient-results)" "(viz/show-cann-path)" "(count (shared/canidates))" "(viz/show-val-boundry-pnts)" "(count (shared/eval-paths))" "(count (shared/canidates))" "(viz/show-all-boundry-pnts)" "(viz/show-all-boundry-pnts-cann)" "(viz/show-all-boundry-pnts)" "(viz/show-all-boundry-pnts-cann)" "(viz/show-cann-path)" "(shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(phase/evaluation)" "(viz/show-cann-path)" "(viz/show-eval-paths)" "(viz/show-cann-path 24)" "(viz/show-cann-path 23)" "(viz/show-cann-path 10)" "(viz/show-eval-paths)" "(viz/show-cann-path 23)" "(viz/show-all-boundry-pnts-cann)" "(shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(viz/show-all-boundry-pnts-cann)" "(first (shared/canidates))" "(map (tgaa.struct.image/pix-value (\:local-max %)) (shared/canidates))" "(map \#(tgaa.struct.image/pix-value (\:local-max %)) (shared/canidates))" "(map \#(tgaa.struct.image/pix-value (\:local-max %) (shared/image-gry-ref)) (shared/canidates))" "(-> (map \#(tgaa.struct.image/pix-value (\:local-max %) (shared/image-gry-ref)) (shared/canidates)) (fn [v] (/ (+ v) (count v))))" "(-> (map \#(tgaa.struct.image/pix-value (\:local-max %) (shared/image-gry-ref)) (shared/canidates)) (fn [v] (/ (apply + v) (count v))))" "(-> (map \#(tgaa.struct.image/pix-value (\:local-max %) (shared/image-gry-ref)) (shared/canidates)) (fn [v] (print \\"nothing\\")))" "(count (map \#(tgaa.struct.image/pix-value (\:local-max %) (shared/image-gry-ref)) (shared/canidates)))" "(apply + (map \#(tgaa.struct.image/pix-value (\:local-max %) (shared/image-gry-ref)) (shared/canidates)))" "(/ (apply + (map \#(tgaa.struct.image/pix-value (\:local-max %) (shared/image-gry-ref)) (shared/canidates))) (count (shared/canidates)))" "(Integer (/ (apply + \\n               (map \#(tgaa.struct.image/pix-value (\:local-max %) (shared/image-gry-ref)) (shared/canidates))) \\n       (count (shared/canidates))))" "(Integer. (/ (apply + \\n                (map \#(tgaa.struct.image/pix-value (\:local-max %) (shared/image-gry-ref)) (shared/canidates))) \\n       (count (shared/canidates))))" "(int (/ (apply + \\n           (map \#(tgaa.struct.image/pix-value (\:local-max %) (shared/image-gry-ref)) (shared/canidates))) \\n     (count (shared/canidates))))" "(int (/ (apply + \\n           (map \#(tgaa.struct.image/pix-value (\:local-min %) (shared/image-gry-ref)) (shared/canidates))) \\n     (count (shared/canidates))))" "(viz/show-segmentaton 212)" "(viz/show-segmentaton 252)" "(first (shared/canidates))" "(int (/ (apply + \\n           (map \#(tgaa.struct.image/pix-value (\:start %) (shared/image-gry-ref)) (shared/canidates))) \\n     (count (shared/canidates))))" "(int (/ (apply + \\n           (map \#(tgaa.struct.image/pix-value (\:end %) (shared/image-gry-ref)) (shared/canidates))) \\n     (count (shared/canidates))))" "(viz/show-segmentaton 126)" "(viz/show-segmentaton 106)" "(viz/show-segmentaton 126)" "(viz/show-segmentaton 106)" "(int (/ (apply + \\n           (map \#(tgaa.struct.image/pix-value (\:end %) (shared/image-gry-ref)) (shared/canidates))) \\n     (count (shared/canidates))))" "(int (/ (apply + \\n           (map \#(tgaa.struct.image/pix-value (\:start %) (shared/image-gry-ref)) (shared/canidates))) \\n     (count (shared/canidates))))" "           (map \#(tgaa.struct.image/pix-value (\:start %) (shared/image-gry-ref)) (shared/canidates))" "           (map \#(tgaa.struct.image/pix-value (\:end %) (shared/image-gry-ref)) (shared/canidates))" "(appy Math/min (map \#(tgaa.struct.image/pix-value (\:start %) (shared/image-gry-ref)) (shared/canidates))" "(apply Math/min (map \#(tgaa.struct.image/pix-value (\:start %) (shared/image-gry-ref)) (shared/canidates))" "(apply Math/min (map \#(tgaa.struct.image/pix-value (\:start %) (shared/image-gry-ref)) (shared/canidates)))" "(Math/min (map \#(tgaa.struct.image/pix-value (\:start %) (shared/image-gry-ref)) (shared/canidates)))" "(apply min (map \#(tgaa.struct.image/pix-value (\:start %) (shared/image-gry-ref)) (shared/canidates)))" "(apply max (map \#(tgaa.struct.image/pix-value (\:start %) (shared/image-gry-ref)) (shared/canidates)))" "(first (shared/canidates))" "(viz/show-image)" "(viz/show-segmentaton 106)" "(shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(viz/show-cann-path)" "(first (shared/canidates))" "(viz/show-cann-path)" "(filter (tgaa.util.filters/edge))" "(mikera.image.core/show (filter (tgaa.util.filters/edge)))" "(mikera.image.core/show (mikera.image.core/filter-image (shared/image-ref) (tgaa.util.filters/edge)))" "(mikera.image.core/show (tgaa.util.filters/->Filter (shared/image-ref)) (tgaa.util.filters/edge))" " (mi/show ((tgaa.util.filters/edge) (shared/image-ref)))" " (mikera.image.core/show ((tgaa.util.filters/edge) (shared/image-ref)))" "(shared/thresh)" "(tgaa.algo.analysis/max-pxl-avg-can)" "(((tgaa.util.filters/edge) ((filter/threshold (shared/thresh) (shared/image-ref)))" "((tgaa.util.filters/edge) ((filter/threshold (shared/thresh) (shared/image-ref))))" "((tgaa.util.filters/edge) ((tgaa.util.filter/threshold (shared/thresh) (shared/image-ref))))" "\\n((tgaa.util.filter/threshold (shared/thresh) (shared/image-ref)))" "((tgaa.util.filters/edge) (shared/image-ref))" "((tgaa.util.filters/edge) ((tgaa.util.filter/threshold (shared/thresh) (shared/image-ref))))" "((tgaa.util.filters/edge) ((tgaa.util.filter/threshold) (shared/thresh) (shared/image-ref)))" " ((tgaa.util.filter/threshold) (shared/thresh) (shared/image-ref))" " ((tgaa.util.filter/threshold (shared/thresh)) (shared/image-ref))" "((filter/threshold 10) (shared/image-ref))" " ((tgaa.util.filters/threshold (shared/thresh)) (shared/image-ref))" "((tgaa.util.filters/edge) ((tgaa.util.filters/threshold (shared/thresh)) (shared/image-ref)))" " (mi/show ((tgaa.util.filters/edge) ((tgaa.util.filters/threshold (shared/thresh)) (shared/image-ref))))" " (mikera.image.core/show ((tgaa.util.filters/edge) ((tgaa.util.filters/threshold (shared/thresh)) (shared/image-ref))))" " (mikera.image.core/show ((tgaa.util.filters/edge) ((tgaa.util.filters/threshold (int (/ (shared/thresh)))) (shared/image-ref))))" "(int (/ (shared/thresh))" "(int (/ (shared/thresh)))" "(shared/thresh)" "(/ (shared/thresh) 2)" "(int (/ (shared/thresh) 2))" " (mikera.image.core/show ((tgaa.util.filters/edge) ((tgaa.util.filters/threshold (int (/ (shared/thresh) 2))) (shared/image-ref))))" " (mikera.image.core/show ((tgaa.util.filters/edge) ((tgaa.util.filters/threshold (shared/thresh)) (shared/image-ref))))" " (mikera.image.core/show ((tgaa.util.filters/edge) ((tgaa.util.filters/threshold (int (/ (shared/thresh) 2))) (shared/image-ref))))" "(defn homo-contigous [image pos value]\\n  (" "(let [pos [5 5]]\\n  (range (dec (first pos)) (inc (first pos))))" "(let [pos [5 5]]\\n  (range (dec (first pos)) (+ (first pos) 2)))" "(let [pos [5 5]]\\n  (map \#() [-1 0 1] (repeat 3 pos)))" "(apply - 1 [5 5])" "(for [x (range -1 2)\\n      y (range -1 2)]\\n  [x y])" "(count (for [x (range -1 2)\\n             y (range -1 2)]\\n         [x y]))" "(let [pos [ 4 4]]\\n(for [x (range -1 2)\\n      y (range -1 2)]\\n  [(+ x (first pos)) (+ (second pos y))]))" "(let [pos [ 4 4]]\\n  (for [x (range -1 2)\\n        y (range -1 2)]\\n    [(+ x (first pos)) (+ (second pos) y)]))" "(let [pos [ 4 4]]\\n(remove 5  (for [x (range -1 2)\\n                 y (range -1 2)]\\n             [(+ x (first pos)) (+ (second pos) y)])))" "(let [pos [ 4 4]]\\n  (drop 5  (for [x (range -1 2)\\n                 y (range -1 2)]\\n             [(+ x (first pos)) (+ (second pos) y)])))" "(let [pos [ 4 4]]\\n  (drop 5  (for [x (range -1 2)\\n                 y (range -1 2)\\n                 \:while (not\= x y)]\\n             [(+ x (first pos)) (+ (second pos) y)])))" "(let [pos [ 4 4]]\\n  (drop 5  (for [x (range -1 2)\\n                 y (range -1 2)\\n                 \:while (\= x y)]\\n             [(+ x (first pos)) (+ (second pos) y)])))" "(let [pos [ 4 4]]\\n  (drop 5  (for [x (range -1 2)\\n                 y (range -1 2)\\n                 \:while (< x y)]\\n             [(+ x (first pos)) (+ (second pos) y)])))" "(let [pos [ 4 4]]\\n (for [x (range -1 2)\\n       y (range -1 2)\\n       \:while (< x y)]\\n   [(+ x (first pos)) (+ (second pos) y)]))" "(let [pos [ 4 4]]\\n (for [x (range -1 2)\\n       y (range -1 2)\\n       ]\\n   [(+ x (first pos)) (+ (second pos) y)]))" "(let [pos [ 4 4]]\\n (for [x (range -1 2)\\n       y (range -1 2)\\n       \:while (> x -2)]\\n   [(+ x (first pos)) (+ (second pos) y)]))" "(let [pos [ 4 4]]\\n (for [x (range -1 2)\\n       y (range -1 2)\\n       \:while (> x 0)]\\n   [(+ x (first pos)) (+ (second pos) y)]))" "(let [pos [ 4 4]]\\n (for [x (range -1 2)\\n       y (range -1 2)\\n       \:while (> x y)]\\n   [(+ x (first pos)) (+ (second pos) y)]))" "(let [pos [ 4 4]]\\n (for [x (range -1 2)\\n       y (range -1 2)\\n       \:while (not\= x y)]\\n   [(+ x (first pos)) (+ (second pos) y)]))" "(let [pos [ 4 4]]\\n (for [x (range -1 2)\\n       y (range -1 2)\\n       \:while (and (not\= x 0) (not\= y 0)))]\\n   [(+ x (first pos)) (+ (second pos) y)]))" "(let [pos [ 4 4]]\\n (for [x (range -1 2)\\n       y (range -1 2)\\n       \:while (and (not\= x 0) (not\= y 0))]\\n   [(+ x (first pos)) (+ (second pos) y)]))" "(let [pos [ 4 4]]\\n (for [x (range -1 2)\\n       y (range -1 2)]\\n   [(+ x (first pos)) (+ (second pos) y)]))" "(\= [4 4] [4 4])" "(\= [4 4] [4 5])" "(let [pos [ 4 4]]\\n (filter \#(not\= pos)(for [x (range -1 2)\\n                        y (range -1 2)]\\n                    [(+ x (first pos)) (+ (second pos) y)])))" "(let [pos [ 4 4]]\\n (filter \#(not\= pos %)(for [x (range -1 2)\\n                          y (range -1 2)]\\n                      [(+ x (first pos)) (+ (second pos) y)])))" "(let [pos [ 4 4]]\\n (filter \#(and (not\= pos %)\\n               (> (first %) 0)\\n               (> (second %) 0))\\n         (for [x (range -1 2)\\n             y (range -1 2)]\\n         [(+ x (first pos)) (+ (second pos) y)])))" "(let [pos [ 4 4]\\n      x-max 10\\n      y-max 10]\\n (filter \#(and (not\= pos %)\\n               (> (first %) 0)\\n               (> (second %) 0)\\n               (< (first %) x-max)\\n               (> (second %) y-max))\\n         (for [x (range -1 2)\\n             y (range -1 2)]\\n         [(+ x (first pos)) (+ (second pos) y)])))" "(let [pos [ 4 4]\\n      x-max 10\\n      y-max 10]\\n (filter \#(and (not\= pos %)\\n               (> (first %) 0)\\n               (> (second %) 0)\\n               (< (first %) x-max)\\n               (< (second %) y-max))\\n         (for [x (range -1 2)\\n             y (range -1 2)]\\n         [(+ x (first pos)) (+ (second pos) y)])))" "(defn neighbor-pnts [pos x-max y-max]\\n  \\"provides nearest neighborhood pnts. Returns only safe points\\"\\n  (filter \#(and (not\= pos %)\\n                (> (first %) 0)\\n                (> (second %) 0)\\n                (< (first %) x-max)\\n                (< (second %) y-max))\\n          (for [x (range -1 2)\\n                y (range -1 2)]\\n            [(+ x (first pos)) (+ (second pos) y)])))" "(let [pos [5 5]\\n      image (shared/image-gry-ref)\\n      val (tgaa.struct.image/pix-value pos)\\n      nb-pnts (neighbor-pnts pos (tgaa.struct.image/image-width image) (tgaa.struct.image/image-height image))]\\n  nb-pnts)" "(let [pos [5 5]\\n      image (shared/image-gry-ref)\\n      val (tgaa.struct.image/pix-value pos image)\\n      nb-pnts (neighbor-pnts pos (tgaa.struct.image/image-width image) (tgaa.struct.image/image-height image))]\\n  nb-pnts)" "(let [pos [5 5]\\n      image (shared/image-gry-ref)\\n      val (tgaa.struct.image/pix-value pos image)\\n      nb-pnts (map \#([(first %) (second %) (tgaa.struct.image/pix-value % image)])   \\n                   (neighbor-pnts pos (tgaa.struct.image/image-width image) (tgaa.struct.image/image-height image)))]\\n  nb-pnts)" "(let [pos [5 5]\\n      image (shared/image-gry-ref)\\n      val (tgaa.struct.image/pix-value pos image)\\n      nb-pnts (map \#(vec (first %) (second %) (tgaa.struct.image/pix-value % image))   \\n                   (neighbor-pnts pos (tgaa.struct.image/image-width image) (tgaa.struct.image/image-height image)))]\\n  nb-pnts)" "(let [pos [5 5]\\n      image (shared/image-gry-ref)\\n      val (tgaa.struct.image/pix-value pos image)\\n      nb-pnts (map \#((first %) (second %) (tgaa.struct.image/pix-value % image))   \\n                   (neighbor-pnts pos (tgaa.struct.image/image-width image) (tgaa.struct.image/image-height image)))]\\n  nb-pnts)" "(let [pos [5 5]\\n      image (shared/image-gry-ref)\\n      val (tgaa.struct.image/pix-value pos image)\\n      nb-pnts (map \#([(first %) (second %) (tgaa.struct.image/pix-value % image)])   \\n                   (neighbor-pnts pos (tgaa.struct.image/image-width image) (tgaa.struct.image/image-height image)))]\\n  nb-pnts)" "(let [pos [5 5]\\n      image (shared/image-gry-ref)\\n      val (tgaa.struct.image/pix-value pos image)\\n      nb-pnts (map (fn [x] [(first x) (second x) (tgaa.struct.image/pix-value x image)])   \\n                   (neighbor-pnts pos (tgaa.struct.image/image-width image) (tgaa.struct.image/image-height image)))]\\n  nb-pnts)" "(let [pos [45 56]\\n      image (shared/image-gry-ref)\\n      val (tgaa.struct.image/pix-value pos image)\\n      nb-pnts (map (fn [x] [(first x) (second x) (tgaa.struct.image/pix-value x image)])   \\n                   (neighbor-pnts pos (tgaa.struct.image/image-width image) (tgaa.struct.image/image-height image)))]\\n  nb-pnts)" "(let [pos [100 56]\\n      image (shared/image-gry-ref)\\n      val (tgaa.struct.image/pix-value pos image)\\n      nb-pnts (map (fn [x] [(first x) (second x) (tgaa.struct.image/pix-value x image)])   \\n                   (neighbor-pnts pos (tgaa.struct.image/image-width image) (tgaa.struct.image/image-height image)))]\\n  nb-pnts)" "(defn neighbor-homo [pos image val oper]\\n  (filter \#(oper val (nth % 2))\\n          (map (fn [x] [(first x) (second x) (tgaa.struct.image/pix-value x image)])   \\n              (neighbor-pnts pos (tgaa.struct.image/image-width image) (tgaa.struct.image/image-height image)))))" "(neighbor-homo [100 56] (shared/image-gry-ref) 0 \=)" "(neighbor-homo [100 56] (shared/image-gry-ref) 0 >)" "(neighbor-homo [100 56] (shared/image-gry-ref) 0 <)" "(neighbor-homo [100 56] (shared/image-gry-ref) 256 \=)" "(defn fill-threshold-eval [pos image val oper thresh-count]" "(defn area-meets-thresh? [pos image val oper thresh-count]\\r\\n  (let[locatons [location]]\\r\\n    (loop [location-stack locatons fill-count 1]\\r\\n      (if (empty? location-stack)\\r\\n        false\\n        (if (> (count location-stack) thresh-count)\\n          true\\n          (let [locs-add (neighbor-homo (first location-stack) image val oper)]\\r\\n            (recur \\r\\n              (conj (rest location-stack)) (inc fill-count))))))))" "(defn area-meets-thresh? [pos image val oper thresh-count]\\r\\n  (let[locatons [pos]]\\r\\n    (loop [location-stack locatons fill-count 1]\\r\\n      (if (empty? location-stack)\\r\\n        false\\n        (if (> (count location-stack) thresh-count)\\n          true\\n          (let [locs-add (neighbor-homo (first location-stack) image val oper)]\\r\\n            (recur \\r\\n              (conj (rest location-stack)) (inc fill-count))))))))" "(area-meets-thresh? [10 10] (shared/image-ref) 100 \= 10)" "(area-meets-thresh? [10 10] (shared/image-ref) 256 \= 10)" "(defn area-meets-thresh? [pos image val oper thresh-count]\\r\\n  (let[locatons [pos]]\\r\\n    (loop [location-stack [locatons] fill-count 1]\\r\\n      (if (empty? location-stack)\\r\\n        false\\n        (if (> (count location-stack) thresh-count)\\n          true\\n          (let [locs-add (neighbor-homo (first location-stack) image val oper)]\\r\\n            (recur \\r\\n              (conj (rest location-stack)) (inc fill-count))))))))" "(area-meets-thresh? [10 10] (shared/image-ref) 256 \= 10)" "(defn area-meets-thresh? [pos image val oper thresh-count]\\r\\n  (let[locatons [pos]]\\r\\n    (loop [location-stack [locatons] fill-count 1]\\r\\n      (if (not (empty? location-stack))\\r\\n        false\\n        (if (> (count location-stack) thresh-count)\\n          true\\n          (let [locs-add (neighbor-homo (first location-stack) image val oper)]\\r\\n            (recur \\r\\n              (conj (rest location-stack)) (inc fill-count))))))))" "(area-meets-thresh? [10 10] (shared/image-ref) 256 \= 10)" "(defn area-meets-thresh? [pos image val oper thresh-count]\\r\\n  (let[locatons [pos]]\\r\\n    (loop [location-stack [locatons] fill-count 1]\\r\\n      (if (not (empty? location-stack))\\r\\n        false\\n        (if (> (count location-stack) thresh-count)\\n          true\\n          (let [locs-add (neighbor-homo (first location-stack) image val oper)\\n                _ (print \\"here\\")]\\r\\n            (recur \\r\\n              (conj (rest location-stack)) (inc fill-count))))))))" "(area-meets-thresh? [10 10] (shared/image-ref) 256 \= 10)" "(defn area-meets-thresh? [pos image val oper thresh-count]\\r\\n    (loop [location-stack [pos] fill-count 1]\\r\\n      (if (not (empty? location-stack))\\r\\n        false\\n        (if (> (count location-stack) thresh-count)\\n          true\\n          (let [locs-add (neighbor-homo (first location-stack) image val oper)\\n                _ (print \\"here\\")]\\r\\n            (recur \\r\\n              (conj (rest location-stack)) (inc fill-count)))))))" "(area-meets-thresh? [10 10] (shared/image-ref) 256 \= 10)" "(defn area-meets-thresh? [pos image val oper thresh-count]\\r\\n    (loop [location-stack [pos] fill-count 1]\\r\\n      (if (not (empty? location-stack))\\r\\n        false\\n        (if (> (count location-stack) thresh-count)\\n          true\\n          (let [locs-add (neighbor-homo (first location-stack) image val oper)\\n                _ (print \\"here\\")]\\r\\n            (recur \\r\\n              (conj (rest location-stack)) (inc fill-count)))))))" "(area-meets-thresh? [10 10] (shared/image-ref) 256 \= 10)" "(defn area-meets-thresh? [pos image val oper thresh-count]\\r\\n    (loop [location-stack [pos] fill-count 1]\\n      (let [_ (print location-stack)]\\r\\n      (if (not (empty? location-stack))\\r\\n        false\\n        (if (> (count location-stack) thresh-count)\\n          true\\n          (let [locs-add (neighbor-homo (first location-stack) image val oper)\\n                _ (print \\"here\\")]\\r\\n            (recur \\r\\n              (conj (rest location-stack)) (inc fill-count))))))))" "(area-meets-thresh? [10 10] (shared/image-ref) 256 \= 10)" "(defn area-meets-thresh? [pos image val oper thresh-count]\\r\\n    (loop [location-stack [pos] fill-count 1]\\n      (let [_ (print (not (empty? location-stack))]\\r\\n      (if (not (empty? location-stack))\\r\\n        false\\n        (if (> (count location-stack) thresh-count)\\n          true\\n          (let [locs-add (neighbor-homo (first location-stack) image val oper)\\n                _ (print \\"here\\")]\\r\\n            (recur \\r\\n              (conj (rest location-stack)) (inc fill-count))))))))" "(defn area-meets-thresh? [pos image val oper thresh-count]\\r\\n    (loop [location-stack [pos] fill-count 1]\\n      (let [_ (print (not (empty? location-stack)))]\\r\\n      (if (not (empty? location-stack))\\r\\n        false\\n        (if (> (count location-stack) thresh-count)\\n          true\\n          (let [locs-add (neighbor-homo (first location-stack) image val oper)\\n                _ (print \\"here\\")]\\r\\n            (recur \\r\\n              (conj (rest location-stack)) (inc fill-count))))))))" "(defn area-meets-thresh? [pos image val oper thresh-count]\\r\\n    (loop [location-stack [pos] fill-count 1]\\n      (let [_ (print (not (empty? location-stack))]\\r\\n      (if (not (empty? location-stack))\\r\\n        false\\n        (if (> (count location-stack) thresh-count)\\n          true\\n          (let [locs-add (neighbor-homo (first location-stack) image val oper)\\n                _ (print \\"here\\")]\\r\\n            (recur \\r\\n              (conj (rest location-stack)) (inc fill-count))))))))" "(defn area-meets-thresh? [pos image val oper thresh-count]\\r\\n    (loop [location-stack [pos] fill-count 1]\\n      (let [_ (print (not (empty? location-stack)))]\\r\\n      (if (not (empty? location-stack))\\r\\n        false\\n        (if (> (count location-stack) thresh-count)\\n          true\\n          (let [locs-add (neighbor-homo (first location-stack) image val oper)\\n                _ (print \\"here\\")]\\r\\n            (recur \\r\\n              (conj (rest location-stack)) (inc fill-count))))))))" "(area-meets-thresh? [10 10] (shared/image-ref) 256 \= 10)" "(defn area-meets-thresh? [pos image val oper thresh-count]\\r\\n    (loop [location-stack [pos] fill-count 1]\\n      (let [_ (print (not (empty? location-stack)))]\\r\\n      (if (empty? location-stack)\\r\\n        false\\n        (if (> (count location-stack) thresh-count)\\n          true\\n          (let [locs-add (neighbor-homo (first location-stack) image val oper)\\n                _ (print \\"here\\")]\\r\\n            (recur \\r\\n              (conj (rest location-stack)) (inc fill-count))))))))" "(area-meets-thresh? [10 10] (shared/image-ref) 256 \= 10)" "(defn area-meets-thresh? [pos image val oper thresh-count]\\r\\n    (loop [location-stack [pos] fill-count 1]\\r\\n      (if (empty? location-stack)\\r\\n        false\\n        (if (> (count location-stack) thresh-count)\\n          true\\n          (let [locs-add (neighbor-homo (first location-stack) image val oper)\\n                _ (println locs-add)]\\r\\n            (recur \\r\\n              (conj (rest location-stack)) (inc fill-count)))))))" "(area-meets-thresh? [10 10] (shared/image-ref) 256 \= 10)" "(defn fill-area [pos image val oper thresh-count]\\r\\n  (loop [location-stack [pos] fill-count 1]\\r\\n    (if (empty? location-stack)\\r\\n      false\\n      (if (> (count location-stack) thresh-count)\\n        true\\n        (let [ _ (tgaa.struct.image/pix-value-upd (first location-stack) val)\\n              locs-add (neighbor-homo (first location-stack) image val oper)\\n              _ (println locs-add)]\\r\\n          (recur \\r\\n            (rest location-stack) (inc fill-count)))))))" "(fill-area [10 10] (shared/image-ref) 256 \= 10)" "(defn fill-area [pos image val oper thresh-count]\\r\\n  (loop [location-stack [pos] fill-count 1]\\r\\n    (if (empty? location-stack)\\r\\n      false\\n      (if (> (count location-stack) thresh-count)\\n        true\\n        (let [ _ (tgaa.struct.image/pix-value-upd (first location-stack) val image)\\n              locs-add (neighbor-homo (first location-stack) image val oper)\\n              _ (println locs-add)]\\r\\n          (recur \\r\\n            (rest location-stack) (inc fill-count)))))))" "(fill-area [10 10] (shared/image-ref) 256 \= 10)" "(defn neighbor-homo [pos image val oper]\\r\\n  \\"gets types contiguous based on val and operator within the nearest neighborhood\\"\\r\\n  (map (fn [x] [(first x) (second x)])\\r\\n    (filter \#(oper val (nth % 2))\\r\\n          (map (fn [x] [(first x) (second x) (tgaa.struct.image/pix-value x image)])   \\r\\n               (neighbor-pnts pos (tgaa.struct.image/image-width image) (tgaa.struct.image/image-height image))))))" "(fill-area [10 10] (shared/image-ref) 256 \= 10)" "(neighbor-homo [10 10] (shared/image-ref) 256 \= 10)" "(neighbor-homo [10 10] (shared/image-ref) 256 \= )" "(defn fill-area [pos image val oper thresh-count]\\r\\n  (loop [location-stack [pos] fill-count 1]\\r\\n    (if (empty? location-stack)\\r\\n      false\\n      (if (> (count location-stack) thresh-count)\\n        true\\n        (let [ _ (tgaa.struct.image/pix-value-upd (first location-stack) val image)\\n              locs-add (neighbor-homo (first location-stack) image val oper)\\n              _ (println locs-add)]\\r\\n          (recur \\r\\n            (rest location-stack) (inc fill-count)))))))" "(fill-area [10 10] (shared/image-ref) 256 \= 10)" "(defn fill-area [pos image val oper thresh-count]\\r\\n  (loop [location-stack [pos] fill-count 1]\\r\\n    (if (empty? location-stack)\\r\\n      false\\n      (if (> (count location-stack) thresh-count)\\n        true\\n        (let [ _ (tgaa.struct.image/pix-value-upd (first location-stack) val image)\\n              _ (println \\"here1\\")\\n              locs-add (neighbor-homo (first location-stack) image val oper)\\n              _ (println \\"here2\\")]\\r\\n          (recur \\r\\n            (rest location-stack) (inc fill-count)))))))" "(fill-area [10 10] (shared/image-ref) 256 \= 10)" "(defn fill-area [pos image val oper thresh-count]\\r\\n  (loop [location-stack [pos] fill-count 1]\\r\\n    (if (empty? location-stack)\\r\\n      false\\n      (if (> (count location-stack) thresh-count)\\n        true\\n        (let [_ (println \\"here1\\") \\n              _ (tgaa.struct.image/pix-value-upd (first location-stack) val image)\\n              _ (println \\"here1\\")\\n              locs-add (neighbor-homo (first location-stack) image val oper)\\n              _ (println \\"here2\\")]\\r\\n          (recur \\r\\n            (rest location-stack) (inc fill-count)))))))" "(fill-area [10 10] (shared/image-ref) 256 \= 10)" "(defn pix-value-upd \\r\\n  ([x y val image]\\r\\n  {\:pre [(and (is (< x (. image getWidth))) \\r\\n              (is (<\= 0 x)) \\r\\n              (is(< y (. image getHeight))) \\r\\n              (is (<\= 0 y)))]}\\r\\n  (shared/target-intensity (. image setRGB x y val)))\\r\\n  ([[x y] val image]\\r\\n    (pix-value-upd x y val image)))" "(fill-area [10 10] (shared/image-ref) 256 \= 10)" "(defn fill-area [pos image val oper thresh-count]\\r\\n  (loop [location-stack [pos] fill-count 1]\\r\\n    (if (empty? location-stack)\\r\\n      false\\n      (if (> (count location-stack) thresh-count)\\n        true\\n        (let [_ (println \\"here1\\") \\n              _ (tgaa.struct.image/pix-value-upd (first location-stack) val image)\\n              _ (println \\"here2\\")\\n              locs-add (neighbor-homo (first location-stack) image val oper)\\n              _ (println \\"here3\\")]\\r\\n          (recur \\r\\n            (rest location-stack) (inc fill-count)))))))" "(fill-area [10 10] (shared/image-ref) 256 \= 10)" "(defn fill-area [pos image val oper thresh-count]\\r\\n  (loop [location-stack [pos] fill-count 1]\\r\\n    (if (empty? location-stack)\\r\\n      false\\n      (if (> (count location-stack) thresh-count)\\n        true\\n        (let [_ (println \\"here1\\" (first location-stack)) \\n              _ (tgaa.struct.image/pix-value-upd (first location-stack) val image)\\n              _ (println \\"here2\\")\\n              locs-add (neighbor-homo (first location-stack) image val oper)\\n              _ (println \\"here3\\")]\\r\\n          (recur \\r\\n            (rest location-stack) (inc fill-count)))))))" "(fill-area [10 10] (shared/image-ref) 256 \= 10)" "(defn fill-area [pos image val oper thresh-count]\\r\\n  (loop [location-stack [pos] fill-count 1]\\r\\n    (if (empty? location-stack)\\r\\n      false\\n      (if (> (count location-stack) thresh-count)\\n        true\\n        (let [_ (println \\"here1\\" (first location-stack) val) \\n              _ (tgaa.struct.image/pix-value-upd (first location-stack) val image)\\n              _ (println \\"here2\\")\\n              locs-add (neighbor-homo (first location-stack) image val oper)\\n              _ (println \\"here3\\")]\\r\\n          (recur \\r\\n            (rest location-stack) (inc fill-count)))))))" "(fill-area [10 10] (shared/image-ref) 256 \= 10)" "(shared/image-ref)" "(tgaa.struct.image/pix-value-upd [10 10] 256 (shared/image-ref))" "(defn fill-area [pos image val oper thresh-count]\\r\\n  (loop [location-stack [pos] fill-count 1]\\r\\n    (if (empty? location-stack)\\r\\n      false\\n      (if (> (count location-stack) thresh-count)\\n        true\\n        (let [_ (println \\"here1\\" (first location-stack) val) \\n              _ (tgaa.struct.image/pix-value-upd (first location-stack) val image)\\n              _ (println \\"here2\\")\\n              locs-add (neighbor-homo (first location-stack) image val oper)\\n              _ (println \\"here3\\")]\\r\\n          (recur \\r\\n            (rest location-stack) (inc fill-count)))))))" "(fill-area [10 10] (shared/image-ref) 256 \= 10)" "(defn fill-area [pos image val oper thresh-count]\\r\\n  (loop [location-stack [pos] fill-count 1]\\r\\n    (if (empty? location-stack)\\r\\n      false\\n      (if (> (count location-stack) thresh-count)\\n        true\\n        (let [\\n              _ (tgaa.struct.image/pix-value-upd (first location-stack) val image)\\n              locs-add (neighbor-homo (first location-stack) image val oper)]\\r\\n          (recur \\r\\n            (rest location-stack) (inc fill-count)))))))" "(conj [[1 1]] [2 1])" "(conj [[1 1]] [2 1] [3 1])" "(conj [[1 1]] [[2 1] [3 1]])" "(apply conj [[1 1]] [[2 1] [3 1]])" "(rest (apply conj [[1 1]] [[2 1] [3 1]]))" "(rest (apply conj [[1 1] [5 6]] [[2 1] [3 1]]))" "(defn fill-area [pos image val oper thresh-count]\\r\\n  (loop [location-stack [pos] fill-count 1]\\r\\n    (if (empty? location-stack)\\r\\n      false\\n      (if (> (count location-stack) thresh-count)\\n        true\\n        (let [ _ (tgaa.struct.image/pix-value-upd (first location-stack) val image)]\\r\\n          (recur (rest (apply conj location-stack \\n                              (neighbor-homo (first location-stack) image val oper)))\\n                 (inc fill-count)))))))" "(fill-area [10 10] (shared/image-ref) 256 \= 10)" "(viz/show-image)" "(fill-area [10 10] (shared/image-ref) 256 \= 0)" "(viz/show-image)" "(defn fill-area [pos image val oper thresh-count]\\r\\n  (loop [location-stack [pos] fill-count 1]\\r\\n    (if (empty? location-stack)\\r\\n      false\\n      (if (> (count location-stack) thresh-count)\\n        true\\n        (let [ _ (tgaa.struct.image/pix-value-upd (first location-stack) val image)]\\r\\n          (recur (rest (apply conj location-stack \\n                              (neighbor-homo (first location-stack) image val oper)))\\n                 (inc fill-count)))))))" "(viz/show-all-boundry-pnts-cann)" "(shared/init-trail-state)" "(phase/load-image)" "(shared/time-start)" "(phase/bootstrap)" "(phase/trapping)" "(viz/animate-algo)" "(viz/show-all-boundry-pnts-cann)" "(shared/thresh)" "(viz/show-segmentaton 173/2)" "(viz/show-all-boundry-pnts-cann)" "(viz/show-all-boundry-pnts)" "(viz/show-all-boundry-pnts-cann)" "(viz/show-val-end-pnts)" "(shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(viz/animate-algo)" "(viz/show-all-boundry-pnts)" "(shared/thresh)" "(viz/show-segmentaton 156/2)" "(viz/show-all-boundry-pnts-cann)" "(viz/show-segmentaton 156/2)" "(tgaa.algo.analysis/min-pxl-avg-can)" "(tgaa.algo.analysis/max-pxl-avg-can)" "(viz/show-segmentaton 207/2)" "(viz/show-segmentaton 256/2)" "(viz/show-image)" "(viz/show-segmentaton 256/2)" "(viz/show-segmentaton 207/2)" "(first (shared/canidates))" "(tgaa.algo.analysis/get-att-point-avg \:end)" "(map \#(image/pix-value (\:end %) (shared/image-gry-ref)) (shared/canidates))" "(map \#(tgaa.struct.image/pix-value (\:end %) (shared/image-gry-ref)) (shared/canidates))" "(map \#(tgaa.struct.image/pix-value (\:end %) (shared/image-ref)) (shared/canidates))" "(tgaa.algo.analysis/get-att-point-avg \:end)" "(viz/show-segmentaton 177)" "(viz/show-segmentaton 177/2)" "(phase/evaluation)" "(viz/animate-algo)" "(viz/show-segmentaton 177/2)" "(viz/show-all-boundry-pnts-cann)" "(phase/evaluation)" "(viz/animate-algo)" "(phase/evaluation)" "(count (shared/canidates))" "(phase/evaluation)" "(viz/animate-algo)" "(phase/evaluation)" "(viz/animate-algo)" "(count (shared/eval-paths))" "(count (shared/canidates))" "(first (shared/canidates))" "(last (shared/canidates))" "(first (ap/reprocess-paths (shared/canidates)))" "(first (tgaa.algo.ant-path/reprocess-paths (shared/canidates)))" "(keys (tgaa.algo.ant-path/reprocess-paths (shared/canidates)))" "(last (tgaa.algo.ant-path/reprocess-paths (shared/canidates)))" "(first (shared/canidates))" "  (count (filter \#(\=  ant/status-trapped (ant/ant-status %))\\r\\n          (map \\r\\n            proc-ant  \\r\\n            (filter \#(not\=  ant/status-dead (ant/ant-status %))\\r\\n                    ant-paths))))" "  (count (filter \#(\=  tgaa.struct.ant/status-trapped (ant/ant-status %))\\r\\n          (map \\r\\n            tgaa.struct.ant/proc-ant  \\r\\n            (filter \#(not\=  tgaa.struct.ant/status-dead (ant/ant-status %))\\r\\n                    (shared/canidates)))))" "  (count (filter \#(\=  tgaa.struct.ant/status-trapped (tgaa.struct.ant//ant-status %))\\r\\n          (map \\r\\n            tgaa.struct.ant/proc-ant  \\r\\n            (filter \#(not\=  tgaa.struct.ant/status-dead (tgaa.struct.ant//ant-status %))\\r\\n                    (shared/canidates)))))" "  (count (filter \#(\=  tgaa.struct.ant/status-trapped (tgaa.struct.ant/ant-status %))\\r\\n          (map \\r\\n            tgaa.struct.ant/proc-ant  \\r\\n            (filter \#(not\=  tgaa.struct.ant/status-dead (tgaa.struct.ant/ant-status %))\\r\\n                    (shared/canidates)))))" "  (count (filter \#(\=  tgaa.struct.ant/status-trapped (tgaa.struct.ant/ant-status %))\\r\\n          (map \\r\\n            tgaa.algo.ant-path/proc-ant  \\r\\n            (filter \#(not\=  tgaa.struct.ant/status-dead (tgaa.struct.ant/ant-status %))\\r\\n                    (shared/canidates)))))" "  (count \\r\\n            (filter \#(not\=  tgaa.struct.ant/status-dead (tgaa.struct.ant/ant-status %))\\r\\n                    (shared/canidates)))" "  (count \\r\\n          (map \\r\\n            tgaa.algo.ant-path/proc-ant  \\r\\n            (filter \#(not\=  tgaa.struct.ant/status-dead (tgaa.struct.ant/ant-status %))\\r\\n                    (shared/canidates))))" "(map \#(tgaa.struct.ant/ant-status %)\\r\\n          (map \\r\\n            tgaa.algo.ant-path/proc-ant  \\r\\n            (filter \#(not\=  tgaa.struct.ant/status-dead (tgaa.struct.ant/ant-status %))\\r\\n                    (shared/canidates))))" "  (count (filter \#(\=  tgaa.struct.ant/status-trapped (tgaa.struct.ant/ant-status %))\\r\\n          (map \\r\\n            tgaa.algo.ant-path/proc-ant  \\r\\n            (filter \#(not\=  tgaa.struct.ant/status-dead (tgaa.struct.ant/ant-status %))\\r\\n                    (shared/canidates)))))" "(shared/thresh)" "  (count (filter \#(\=  tgaa.struct.ant/status-trapped (tgaa.struct.ant/ant-status %))\\r\\n          (map \\r\\n            tgaa.algo.ant-path/proc-ant  \\r\\n            (filter \#(not\=  tgaa.struct.ant/status-dead (tgaa.struct.ant/ant-status %))\\r\\n                    (shared/canidates)))))" "(phase/evaluation)" "(viz/animate-algo)" "  (count (filter \#(\=  tgaa.struct.ant/status-trapped (tgaa.struct.ant/ant-status %))\\r\\n          (map \\r\\n            tgaa.algo.ant-path/proc-ant  \\r\\n            (filter \#(not\=  tgaa.struct.ant/status-dead (tgaa.struct.ant/ant-status %))\\r\\n                    (shared/canidates)))))" "(viz/animate-algo)" "(shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(phase/evaluation)" "(viz/animate-algo)" "(use 'java.awt.Color)" "(use 'java.awt Color)" "(import 'java.awt Color)" "(import 'java.awt.Color)" "(viz/animate-algo)" "(viz/show-segmentaton)" "(tgaa.algo.analysis/max-pxl-avg-can)" "(viz/show-segmentaton (tgaa.algo.analysis/max-pxl-avg-can))" "(viz/show-segmentaton (tgaa.algo.analysis/min-pxl-avg-can))" "(viz/show-val-boundry-pnts)" "(viz/show-segmentaton (tgaa.algo.analysis/max-pxl-avg-can))" "(viz/show-segmentaton ( \\\\(tgaa.algo.analysis/max-pxl-avg-can)))" "(viz/show-segmentaton (/ (tgaa.algo.analysis/max-pxl-avg-can)))" "(viz/show-segmentaton (/ (tgaa.algo.analysis/max-pxl-avg-can) 2))" "(viz/show-segmentaton (/ (tgaa.struct.shared/thresh) 2))" "(let [img (((filter/threshold (/ (tgaa.struct.shared/thresh) 2)) (shared/image-ref)))])" "(let [img (((tgaa.util.filters/threshold (/ (tgaa.struct.shared/thresh) 2)) (tgaa.struct.shared/image-ref)))])" "(let [img ((tgaa.util.filters/threshold (/ (tgaa.struct.shared/thresh) 2)) (tgaa.struct.shared/image-ref))])" "(let [img ((tgaa.util.filters/threshold (/ (tgaa.struct.shared/thresh) 2)) (tgaa.struct.shared/image-ref))]\\n (loop [pnt-cls (for [x (range 1 (dec (tgaa.struct.image/image-width img))) \\n                      y (range 1 (dec (tgaa.struct.image/image-height img)))]\\n                  [x y])" "(for [x (range 1 10) \\r\\n                      y (range 1 10)]\\r\\n                  [x y])" "(let [ds {\:img ((tgaa.util.filters/threshold (/ (tgaa.struct.shared/thresh) 2)) (tgaa.struct.shared/image-ref))\\n          \:x-max 5\\n          \:y-max 5\\n          \:meta-image []\\n          \:curr-loc [1 1]}]\\n  (loop [i 0]\\n    (if (>\= i (* (\:x-max ds) (\:y-max)))\\n            ds\\n         (do (recur (inc ))))))" "(let [ds {\:img ((tgaa.util.filters/threshold (/ (tgaa.struct.shared/thresh) 2)) (tgaa.struct.shared/image-ref))\\n          \:x-max 5\\n          \:y-max 5\\n          \:meta-image []\\n          \:curr-loc [1 1]}]\\n  (loop [i 0]\\n    (if (>\= i (* (\:x-max ds) (\:y-max)))\\n            ds\\n         (do (recur (inc i))))))" "(let [ds {\:img ((tgaa.util.filters/threshold (/ (tgaa.struct.shared/thresh) 2)) (tgaa.struct.shared/image-ref))\\n          \:x-max 5\\n          \:y-max 5\\n          \:meta-image []\\n          \:curr-loc [1 1]}]\\n  (loop [i 0]\\n    (if (>\= i (* (\:x-max ds) (\:y-max ds)))\\n            ds\\n         (do (recur (inc i))))))" "(let [ds {\:img ((tgaa.util.filters/threshold (/ (tgaa.struct.shared/thresh) 2)) (tgaa.struct.shared/image-ref))\\n          \:x-max 5\\n          \:y-max 5\\n          \:meta-image []\\n          \:curr-loc [1 1]}]\\n  (loop [i 0]\\n    (if (>\= i (* (\:x-max ds) (\:y-max ds)))\\n            ds\\n         (do (println (mod i (\:x-max ds) (int (/ i (\:y-max ds))) (recur (inc i))))))" "(int (/ 1 3))" "(int (/ 17 3))" "(let [ds {\:img ((tgaa.util.filters/threshold (/ (tgaa.struct.shared/thresh) 2)) (tgaa.struct.shared/image-ref))\\n          \:x-max 5\\n          \:y-max 5\\n          \:meta-image []\\n          \:curr-loc [1 1]}]\\n  (loop [i 0]\\n    (if (>\= i (* (\:x-max ds) (\:y-max ds)))\\n            ds\\n         (do (println (mod i (\:x-max ds) (int (/ i (\:y-max ds))) (recur (inc i))))))))" "(let [ds {\:img ((tgaa.util.filters/threshold (/ (tgaa.struct.shared/thresh) 2)) (tgaa.struct.shared/image-ref))\\n          \:x-max 5\\n          \:y-max 5\\n          \:meta-image []\\n          \:curr-loc [1 1]}]\\n  (loop [i 0]\\n    (if (>\= i (* (\:x-max ds) (\:y-max ds)))\\n            ds\\n         (do (println (mod i (\:x-max ds) (int (/ i (\:y-max ds))))) (recur (inc i))))))" "(let [ds {\:img ((tgaa.util.filters/threshold (/ (tgaa.struct.shared/thresh) 2)) (tgaa.struct.shared/image-ref))\\n          \:x-max 5\\n          \:y-max 5\\n          \:meta-image []\\n          \:curr-loc [1 1]}]\\n  (loop [i 0]\\n    (if (>\= i (* (\:x-max ds) (\:y-max ds)))\\n            ds\\n         (do (println (mod i (\:x-max ds)) (int (/ i (\:y-max ds)))) (recur (inc i))))))" "(let [ds {\:img ((tgaa.util.filters/threshold (/ (tgaa.struct.shared/thresh) 2)) (tgaa.struct.shared/image-ref))\\n          \:x-max 5\\n          \:y-max 5\\n          \:meta-image []}]\\n  (loop [i 0]\\n    (if (>\= i (* (\:x-max ds) (\:y-max ds)))\\n            ds\\n         (do (println (mod i (\:x-max ds)) (int (/ i (\:y-max ds)))) (recur (inc i))))))" "(viz/show-segmentaton)" "(viz/show-all-boundry-pnts)" "(viz/show-all-boundry-pnts-cann)" "(viz/show-segmentaton)" "(viz/show-all-boundry-pnts-cann)" "(map \#(tgaa.algo.ant-path/ant-start-point %) (shared/canidates))" "(map \#(tgaa.algo.ant/ant-start-point %) (shared/canidates))" "(map \#(tgaa.struct.ant/ant-start-point %) (shared/canidates))" "(count (map \#(tgaa.struct.ant/ant-start-point %) (shared/canidates)))" "(let [ img (shared/image-ref)\\n       thresh (/ (shared/thresh) 2)]\\n      (filter \#(< thresh tgaa.struct.image/pix-value %) (map \#(tgaa.struct.ant/ant-start-point %) (shared/canidates))))" "(first(shared/eval-paths))" "(count (map \#(tgaa.struct.ant/ant-start-point %) (shared/eval-paths)))" "(tgaa.util.flood-fill/neighbor-homo [10 10] (shared/image-ref) 100 '<)" "(tgaa.util.flood-fill/neighbor-homo [10 10] (shared/image-ref) 100 '>)" "(tgaa.util.flood-fill/neighbor-homo [10 10] (shared/image-ref) 100 >)" "(tgaa.util.flood-fill/neighbor-homo [10 10] (shared/image-ref) 100 <)" "(tgaa.util.flood-fill/neighbor-homo [10 10] (shared/image-ref) 100 >)" "(tgaa.util.flood-fill/neighbor-homo [10 10] (shared/image-ref) 100 <)" "[[0 0 0 0 0][0 0 0 0 0]]" "(nth[[0 0 0 0 0][0 0 0 0 0]] 1)" "(nth[[1 2 3 4 5][6 7 8 9 10]] 1)" "(nth 4 (nth [[1 2 3 4 5][6 7 8 9 10]] 1))" "(nth (nth [[1 2 3 4 5][6 7 8 9 10]] 1) 4)" "{\:1 {\:1 0 \:2}}" "{\:1 {\:0 0 \:1 1}}" "(\:1 {\:1 {\:0 0 \:1 1}})" "(\:1 \:0 {\:1 {\:0 0 \:1 1}})" "(get {\:1 {\:0 0 \:1 1}} \:1)" "(get {\:1 {\:0 0 \:1 1}} \:1 \:1)" "(get-in {\:1 {\:0 0 \:1 1}} \:1)" "(get-in {\:1 {\:0 0 \:1 1}} \:1 \:1)" "(get-in {\:1 {\:0 0 \:1 1}} [\:1 \:1])" "(get-in {\:1 {\:0 0 \:1 1}} [\:1 \:0])" "(get-in {\:1 {\:0 0 \:1 1}} [\:1 \:3] false)" "(get-in {1 {0 0 1 1}} [1 1])" "(get-in {1 {0 0 1 5}} [1 1])" "(get-in {1 {4 0 1 5}} [1 1])" "(assoc {1 {1 2 3 4}})" "(assoc {1 {1 2 3 4}} 2\\n       )" "(assoc {1 {1 2 3 4}} 0 2)" "(let [ struct {1 {1 2 3 4}}]\\n  (case\\n    (nil? (get struct 1 5))\\n     (assoc struct 1 5)))" "(let [ struct {1 {1 2 3 4}}]\\n  (case\\n    (nil? (get struct 1 5))\\n     (assoc struct 2 5)))" "(let [ struct {1 {1 2 3 4} 3 {1 2 3 4}}\\n      loc-x 1\\n      loc-y 5\\n      val 11]\\n  (case\\n    (nil? (get-in struct loc-x loc-y))\\n     (assoc struct loc-x (assoc (get struct  loc-x) loc-y val))))" "(let [ struct {1 {1 2 3 4} 3 {1 2 3 4}}\\n      loc-x 1\\n      loc-y 5\\n      val 11]\\n  (if\\n    (nil? (get-in struct loc-x loc-y))\\n     (assoc struct loc-x (assoc (get struct  loc-x) loc-y val))))" "(let [ \\\\struct {1 {1 2 3 4} 3 {1 2 3 4}}\\n      loc-x 1\\n      loc-y 5\\n      val 11]\\n  (if\\n    (nil? (get-in struct [loc-x loc-y]))\\n     (assoc struct loc-x (assoc (get struct  loc-x) loc-y val))))" "(let [ struct {1 {1 2 3 4} 3 {1 2 3 4}}\\n      loc-x 1\\n      loc-y 5\\n      val 11]\\n  (if\\n    (nil? (get-in struct [loc-x loc-y]))\\n     (assoc struct loc-x (assoc (get struct  loc-x) loc-y val))))" "(let [ struct {1 {1 2 3 4} 3 {1 2 3 4}}\\n      loc-x 1\\n      loc-y 5\\n      val 11]\\n  (case\\n    (nil? (get struct x))\\r\\n    (assoc struct x {y val})\\n    (nil? (get-in struct [loc-x loc-y]))\\n    (assoc struct loc-x (assoc (get struct  loc-x) loc-y val))))" "(let [ struct {1 {1 2 3 4} 3 {1 2 3 4}}\\n      loc-x 1\\n      loc-y 5\\n      val 11]\\n  (case\\n    (nil? (get struct loc-x))\\r\\n    (assoc struct loc-x {loc-y val})\\n    (nil? (get-in struct [loc-x loc-y]))\\n    (assoc struct loc-x (assoc (get struct  loc-x) loc-y val))))" "(let [ struct {1 {1 2 3 4} 3 {1 2 3 4}}\\n      loc-x 4\\n      loc-y 5\\n      val 11]\\n  (case\\n    (nil? (get struct loc-x))\\r\\n    (assoc struct loc-x {loc-y val})\\n    (nil? (get-in struct [loc-x loc-y]))\\n    (assoc struct loc-x (assoc (get struct  loc-x) loc-y val))))" "(let [ struct {1 {1 2 3 4} 3 {1 2 3 4}}\\n      loc-x 4\\n      loc-y 5\\n      val 11]\\n  (if (nil? (get struct loc-x))\\r\\n    (assoc struct loc-x {loc-y val})\\n    (assoc struct loc-x (assoc (get struct  loc-x) loc-y val))))" "(let [ struct {1 {1 2 3 4} 3 {1 2 3 4}}\\n      loc-x 1\\n      loc-y 5\\n      val 11]\\n  (if (nil? (get struct loc-x))\\r\\n    (assoc struct loc-x {loc-y val})\\n    (assoc struct loc-x (assoc (get struct  loc-x) loc-y val))))" "(let [ struct {1 {1 2 3 4} 3 {1 2 3 4}}\\n      loc-x 1\\n      loc-y 3\\n      val 11]\\n  (if (nil? (get struct loc-x))\\r\\n    (assoc struct loc-x {loc-y val})\\n    (assoc struct loc-x (assoc (get struct  loc-x) loc-y val))))" "(def meta-img-val \\r\\n  ([x y stuct]\\r\\n    (get-in struct x y false))\\r\\n  ([x y val struct]\\r\\n    (if (nil? (get struct x))\\r\\n    (assoc struct x {y val})\\r\\n    (assoc struct x (assoc (get struct  x) y val)))))" "(defn meta-img-val \\r\\n  ([x y stuct]\\r\\n    (get-in struct x y false))\\r\\n  ([x y val struct]\\r\\n    (if (nil? (get struct x))\\r\\n    (assoc struct x {y val})\\r\\n    (assoc struct x (assoc (get struct  x) y val)))))" "(def struct {1 {1 2 3 4} 3 {1 2 3 4}})" "(def struct-t {1 {1 2 3 4} 3 {1 2 3 4}})" "(meta-img-val 1 1 struct-t)" "(defn meta-img-val \\r\\n  ([x y stuct]\\r\\n    (get-in struct [x y] false))\\r\\n  ([x y val struct]\\r\\n    (if (nil? (get struct x))\\r\\n    (assoc struct x {y val})\\r\\n    (assoc struct x (assoc (get struct  x) y val)))))" "(meta-img-val 1 1 struct-t)" "(meta-img-val 1 1 struct-t 20)" "(meta-img-val 1 1 20 struct-t)" "(meta-img-val 10 10 20 struct-t)" "(loop [img (shared/image-gry-ref)" "\\r\\n(defn meta-img\\r\\n  ({\:meta-image nil})\\r\\n  ([x y stuct]\\r\\n    (get-in struct [x y] false))\\r\\n  ([x y val struct]\\r\\n    (if (nil? (get struct x))\\r\\n    (assoc struct x {y val})\\r\\n    (assoc struct x (assoc (get struct  x) y val)))))" "(defn meta-img\\r\\n  ([] {\:meta-image {\:groups []}})\\r\\n  ([x y stuct]\\r\\n    (get-in struct [x y] false))\\r\\n  ([x y val struct]\\r\\n    (if (nil? (get struct x))\\r\\n    (assoc struct x {y val})\\r\\n    (assoc struct x (assoc (get struct  x) y val)))))" "(let [img (shared/image-gry-ref)]\\n    (loop [cluster-struct {\:unproc (shared/eval-paths) \:proc struct (meta-img)}]\\n      (if (empty? paths-unproc)\\n        (\:proc paths)\\n        (recur (cluster-by-thresh cluster-struct)))))" "(defn clust-by-thresh []\\n  (loop [paths (shared/eval-paths) finished? false]\\n    (if finished?\\n      paths\\n    (let [paths-upd (region-cluster paths)]\\n      (recur paths-upd" "(some? \#(nil? (\:x %)) [{\:x 1} {\:x 1} {\:x nil}])" "(some \#(nil? (\:x %)) [{\:x 1} {\:x 1} {\:x nil}])" "(some \#(nil? (\:x %)) [{\:x 1} {\:x 1} {\:x 4}])" "(some \#(nil? (\:x %)) [{\:x 1} {\:x 1} {\:x 4} {}])" "(defn clust-by-thresh []\\r\\n  (loop [paths (shared/eval-paths) finished? false]\\r\\n    (if finished?\\r\\n      paths\\r\\n    (let [paths-upd (region-cluster paths)\\r\\n          finished? (nil? (some \#(nil? (tgaa.struct.ant/ant-cluster %)) paths-upd))]\\r\\n      (recur paths-upd paths-upd finished?)))))" "(clust-region [paths cnt]\\n    (let [unprocessed (filter \#(nil? (tgaa.struct.ant/ant-cluster %)) paths)\\n          processed (filter \#(not (nil? (tgaa.struct.ant/ant-cluster %))) paths)\\n          seed (tgaa.struct.ant/ant-start-point (first unprocessed))]\\n      (loop [points seed]\\n        (if (empty? seed) \\n          (concat unprocessed processed)" "(concat [{\:x 2 \:t 6}] [{\:x 2 \:t 6}])" "(concat [{\:x 2 \:t 6}] {\:x 4 \:t 4} [{\:x 2 \:t 4}])" "(concat [{\:x 2 \:t 6}] [{\:x 4 \:t 4} {\:x 2 \:t 4}])" "(shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(phase/evaluation)" "(use [java.awt.Color])" "(use 'java.awt.Color)" "(use java.awt.Color)" "(import 'java.awt.Color)" "(viz/show-cann-path)" "(Math/signum -1)" "(Math/signum 10)" "(signum 10)" "(Math/PI\\n  )" "(signum 10)" "(Math/signum 10)" "(Math/signum 10.0)" "(Math/signum -10.0)" "(let [axis-pnt-1 10 axis-pnt-2 100 axis-int-pnt 20]\\n  (case \\n    (and (< axis-pnt-1 axis-pnt-2) (< axis-pnt-1 axis-int-pnt) (> axis-pnt-2 axis-pnt)) true\\n    (and (> axis-pnt-1 axis-pnt-2) (> axis-pnt-1 axis-int-pnt) (< axis-pnt-2 axis-pnt)) true\\n    \:default false))" "(let [axis-pnt-1 10 axis-pnt-2 100 axis-int-pnt 20]\\n  (if (or  \\n    (and (< axis-pnt-1 axis-pnt-2) (< axis-pnt-1 axis-int-pnt) (> axis-pnt-2 axis-pnt))\\n    (and (> axis-pnt-1 axis-pnt-2) (> axis-pnt-1 axis-int-pnt) (< axis-pnt-2 axis-pnt)))\\n    true\\n    false))" "(let [axis-pnt-1 10 axis-pnt-2 100 axis-int-pnt 20]\\n  (if (or  \\n    (and (< axis-pnt-1 axis-pnt-2) (< axis-pnt-1 axis-int-pnt) (> axis-pnt-2 axis-int-pnt))\\n    (and (> axis-pnt-1 axis-pnt-2) (> axis-pnt-1 axis-int-pnt) (< axis-pnt-2 axis-int-pnt)))\\n    true\\n    false))" "(let [axis-pnt-1 30 axis-pnt-2 100 axis-int-pnt 20]\\n  (if (or  \\n    (and (< axis-pnt-1 axis-pnt-2) (< axis-pnt-1 axis-int-pnt) (> axis-pnt-2 axis-int-pnt))\\n    (and (> axis-pnt-1 axis-pnt-2) (> axis-pnt-1 axis-int-pnt) (< axis-pnt-2 axis-int-pnt)))\\n    true\\n    false))" "(let [axis-pnt-1 300 axis-pnt-2 100 axis-int-pnt 20]\\n  (if (or  \\n    (and (< axis-pnt-1 axis-pnt-2) (< axis-pnt-1 axis-int-pnt) (> axis-pnt-2 axis-int-pnt))\\n    (and (> axis-pnt-1 axis-pnt-2) (> axis-pnt-1 axis-int-pnt) (< axis-pnt-2 axis-int-pnt)))\\n    true\\n    false))" "(let [axis-pnt-1 300 axis-pnt-2 100 axis-int-pnt 150]\\n  (if (or  \\n    (and (< axis-pnt-1 axis-pnt-2) (< axis-pnt-1 axis-int-pnt) (> axis-pnt-2 axis-int-pnt))\\n    (and (> axis-pnt-1 axis-pnt-2) (> axis-pnt-1 axis-int-pnt) (< axis-pnt-2 axis-int-pnt)))\\n    true\\n    false))" "(let [axis-pnt-1 300 axis-pnt-2 100 axis-int-pnt 300]\\n  (if (or  \\n    (and (< axis-pnt-1 axis-pnt-2) (< axis-pnt-1 axis-int-pnt) (> axis-pnt-2 axis-int-pnt))\\n    (and (> axis-pnt-1 axis-pnt-2) (> axis-pnt-1 axis-int-pnt) (< axis-pnt-2 axis-int-pnt)))\\n    true\\n    false))" "(let [axis-pnt-1 300 axis-pnt-2 100 axis-int-pnt 300]\\n  (if (or  \\n    (and (<\= axis-pnt-1 axis-pnt-2) (<\= axis-pnt-1 axis-int-pnt) (>\= axis-pnt-2 axis-int-pnt))\\n    (and (>\= axis-pnt-1 axis-pnt-2) (>\= axis-pnt-1 axis-int-pnt) (<\= axis-pnt-2 axis-int-pnt)))\\n    true\\n    false))" "(defn axis-intersect? [axis-pnt-1 axis-pnt-2 axis-int-pnt]\\n                 (if (or  \\n                       (and (<\= axis-pnt-1 axis-pnt-2) (<\= axis-pnt-1 axis-int-pnt) (>\= axis-pnt-2 axis-int-pnt))\\n                       (and (>\= axis-pnt-1 axis-pnt-2) (>\= axis-pnt-1 axis-int-pnt) (<\= axis-pnt-2 axis-int-pnt)))\\n                   true\\n                   false))" "(let [start-x 10 end-x 10 end-y 100 start-y 100 x-int 50 y-int]\\n  (and (axis-intersect? start-x end-x x-int)\\n       (axis-intersect? start-y end-y y-int)))" "(let [start-x 10 end-x 10 end-y 100 start-y 100 x-int 50 y-int 10]\\n  (and (axis-intersect? start-x end-x x-int)\\n       (axis-intersect? start-y end-y y-int)))" "(let [start-x 10 end-x 10 start-y 100 end-y 100 x-int 50 y-int 10]\\n  (and (axis-intersect? start-x end-x x-int)\\n       (axis-intersect? start-y end-y y-int)))" "(let [start-x 10 end-x 10 start-y 100 end-y 100 x-int 50 y-int 50]\\n  (and (axis-intersect? start-x end-x x-int)\\n       (axis-intersect? start-y end-y y-int)))" "(let [start-x 10 end-x 100 start-y 10 end-y 100 x-int 50 y-int 50]\\n  (and (axis-intersect? start-x end-x x-int)\\n       (axis-intersect? start-y end-y y-int)))" "(defn line-intersect? [start-x end-x start-y end-y x-int y-int]\\n  (and (axis-intersect? start-x end-x x-int)\\n       (axis-intersect? start-y end-y y-int)))" "(shared/init-trail-state)" " (phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(phase/evaluation)" "(viz/animate-algo)" "(import 'java.awt.Color)" "(viz/animate-algo)" "(shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" " (phase/trapping)" "(phase/evaluation)" "(let [[x y] [1 0]]\\n  (" "not-any?" "(shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(phase/evaluation)" " (viz/animate-algo)" "(process-image)" "(let [[x y] [1 0]]\\n  (/ y x))" "(let [[x y] [1 0]]\\n  (if (\= x 0)\\n    (if (\= y 0)\\n      (do (print \\"Invalid Slope\\") 0)\\n      \\"inf\\")\\n  (/ y x)))" "(let [[x y] [1 1]]\\n  (if (\= x 0)\\n    (if (\= y 0)\\n      (do (print \\"Invalid Slope\\") 0)\\n      \\"inf\\")\\n  (/ y x)))" "(let [[x y] [0 1]]\\n  (if (\= x 0)\\n    (if (\= y 0)\\n      (do (print \\"Invalid Slope\\") 0)\\n      \\"inf\\")\\n  (/ y x)))" "(let [[x y] [-1 1]]\\n  (if (\= x 0)\\n    (if (\= y 0)\\n      (do (print \\"Invalid Slope\\") 0)\\n      \\"inf\\")\\n  (/ y x)))" "(let [[x y] [-1 0]]\\n  (if (\= x 0)\\n    (if (\= y 0)\\n      (do (print \\"Invalid Slope\\") 0)\\n      \\"inf\\")\\n  (/ y x)))" "(let [[x y] [-1 -1]]\\n  (if (\= x 0)\\n    (if (\= y 0)\\n      (do (print \\"Invalid Slope\\") 0)\\n      \\"inf\\")\\n  (/ y x)))" "(let [[x y] [1 -1]]\\n  (if (\= x 0)\\n    (if (\= y 0)\\n      (do (print \\"Invalid Slope\\") 0)\\n      \\"inf\\")\\n  (/ y x)))" "(let [[x y] [-1 -1]]\\n  (if (\= x 0)\\n    (if (\= y 0)\\n      (do (print \\"Invalid Slope\\") 0)\\n      \\"inf\\")\\n  (/ y x)))" "(let [[x y] [-1 0]]\\n  (if (\= x 0)\\n    (if (\= y 0)\\n      (do (print \\"Invalid Slope\\") 0)\\n      \\"inf\\")\\n  (/ y x)))" "(\= \\"test\\" \\"test\\")" "(shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(phase/evaluation)" " (viz/animate-algo)" "(do (print 1) (print 2))" "(shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(phase/evaluation)" "(first (shared/eval-paths))" "(first (shared/canidates))" "(shared/salient-ids)" "(viz/animate-algo)" "(viz/show-salient-paths)" "(first (shared/salient-ids))" "(filter \#(\= (\:group %) 1) (shared/salient-ids))" "(viz/show-salient-paths 1)" "(viz/show-salient-paths 2)" "(shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" " (phase/evaluation)" "(shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(phase/evaluation)" "(def e \\n  (phase/evaluation))" "(viz/show-salient-paths 1)" "(viz/show-salient-paths 2)" "(viz/show-salient-paths 0)" "(shared/canidates)" "(first (shared/canidates))" "(let [ap (first (shared/canidates))\\n      ref-pnt (if (< (first (tgaa.struct.ant/ant-start-point)) (first (tgaa.struct.ant/end-start-point)))\\n                     (tgaa.struct.ant/ant-start-point)\\n                     (tgaa.struct.ant/end-start-point))" "(defn slope-decode [x y]\\r\\n    (if (\= x 0)\\r\\n      (if (\= y 0)\\r\\n        (do (print \\"Invalid Slope\\") \\"fail\\")\\r\\n        \\"inf\\")\\r\\n      (/ y x)))" "(let [ap (first (shared/canidates))\\n      ref-pnt (if (< (first (tgaa.struct.ant/ant-start-point)) (first (tgaa.struct.ant/end-start-point)))\\n                     [(tgaa.struct.ant/ant-start-point) \\n                     (tgaa.struct.ant/end-start-point))" "(let [ap (first (shared/canidates))]\\r\\n        (if (< (first (tgaa.struct.ant/ant-start-point)) (first (tgaa.struct.ant/end-start-point)))\\r\\n                        (- (tgaa.struct.ant/ant-start-point) (tgaa.struct.ant/end-start-point))\\r\\n                        (- (tgaa.struct.ant/ant-start-point) (tgaa.struct.ant/end-start-point))))" "(- [1 1] [2 2])" "(map \#(- % %) [1 1] [2 2])" "(map \#(- %1 %2) [1 1] [2 2])" "(let [ap (first (shared/canidates))]\\r\\n        (if (< (first (tgaa.struct.ant/ant-start-point)) (first (tgaa.struct.ant/end-start-point)))\\r\\n                        (map \#(- %1 %2) (tgaa.struct.ant/ant-start-point) (tgaa.struct.ant/end-start-point))\\r\\n                        (- (tgaa.struct.ant/ant-start-point) (tgaa.struct.ant/end-start-point))))" "(let [ap (first (shared/canidates))]\\r\\n                        (- (tgaa.struct.ant/ant-start-point) (tgaa.struct.ant/end-start-point)))" "(let [ap (first (shared/canidates))]\\r\\n  (- (tgaa.struct.ant/ant-start-point) (tgaa.struct.ant/ant-end-point)))" "(let [ap (first (shared/canidates))]\\r\\n  (map \#(- %1 %2) (tgaa.struct.ant/ant-start-point) (tgaa.struct.ant/ant-end-point)))" "(let [ap (first (shared/canidates))]\\r\\n  (map \#(- %1 %2) (tgaa.struct.ant/ant-start-point ap) (tgaa.struct.ant/ant-end-point ap)))" "(first (shared/canidates))" "(let [ap (first (shared/canidates))\\r\\n      [x y] (map \#(- %1 %2) (tgaa.struct.ant/ant-start-point ap) (tgaa.struct.ant/ant-end-point ap))])" "(let [ap (first (shared/canidates))\\r\\n      [x y] (map \#(- %1 %2) (tgaa.struct.ant/ant-start-point ap) (tgaa.struct.ant/ant-end-point ap))]\\n  (if (\= 0 y) \\n    \\"inf\\"\\n    (/ x y)))" "(let [ap (second (shared/canidates))\\r\\n      [x y] (map \#(- %1 %2) (tgaa.struct.ant/ant-start-point ap) (tgaa.struct.ant/ant-end-point ap))]\\n  (if (\= 0 y) \\n    \\"inf\\"\\n    (/ x y)))" "(let [ap (nth (shared/canidates) 100)\\r\\n      [x y] (map \#(- %1 %2) (tgaa.struct.ant/ant-start-point ap) (tgaa.struct.ant/ant-end-point ap))]\\n  (if (\= 0 y) \\n    \\"inf\\"\\n    (/ x y)))" "(nth (shared/canidates) 100)" "(let [ap (nth (shared/canidates) 101)\\r\\n      [x y] (map \#(- %1 %2) (tgaa.struct.ant/ant-start-point ap) (tgaa.struct.ant/ant-end-point ap))]\\n  (if (\= 0 y) \\n    \\"inf\\"\\n    (/ x y)))" "(let [ap (nth (shared/canidates) 105)\\r\\n      [x y] (map \#(- %1 %2) (tgaa.struct.ant/ant-start-point ap) (tgaa.struct.ant/ant-end-point ap))]\\n  (if (\= 0 y) \\n    \\"inf\\"\\n    (/ x y)))" "(let [ap (nth (shared/canidates) 106)\\r\\n      [x y] (map \#(- %1 %2) (tgaa.struct.ant/ant-start-point ap) (tgaa.struct.ant/ant-end-point ap))]\\n  (if (\= 0 y) \\n    \\"inf\\"\\n    (/ x y)))" "(let [ap (nth (shared/canidates) 107)\\r\\n      [x y] (map \#(- %1 %2) (tgaa.struct.ant/ant-start-point ap) (tgaa.struct.ant/ant-end-point ap))]\\n  (if (\= 0 y) \\n    \\"inf\\"\\n    (/ x y)))" "(nth (shared/canidates) 106)" "(nth (shared/canidates) 107)" "(defn derive-slope [ap]\\r\\n  (let [[x y] (map \#(- %1 %2) (tgaa.struct.ant/ant-start-point ap) (tgaa.struct.ant/ant-end-point ap))]\\n    (if (and (\= x 0) (\= y 0))\\n      \\"fail\\"\\n      (if (\= 0 y) \\n        \\"inf\\"\\n        (/ x y)))))" "(let [ap (first (shared/canidates))\\n      ref-pnt (if (< (first (tgaa.struct.ant/ant-start-point)) (first (tgaa.struct.ant/end-start-point)))\\n                     (tgaa.struct.ant/ant-start-point) \\n                     (tgaa.struct.ant/end-start-point))])" "(let [ap (first (shared/canidates))\\n      ref-pnt (if (< (first (tgaa.struct.ant/ant-start-point)) (first (tgaa.struct.ant/end-start-point)))\\n                     (tgaa.struct.ant/ant-start-point) \\n                     (tgaa.struct.ant/ant-end-point))])" "(let [ap (first (shared/canidates))\\n      ref-pnt (if (< (first (tgaa.struct.ant/ant-start-point ap)) (first (tgaa.struct.ant/end-start-point ap)))\\n                     (tgaa.struct.ant/ant-start-point ap) \\n                     (tgaa.struct.ant/ant-end-point ap))])" "(let [ap (first (shared/canidates))\\n      ref-pnt (if (< (first (tgaa.struct.ant/ant-start-point ap)) (first (tgaa.struct.ant/ant-end-point ap)))\\n                     (tgaa.struct.ant/ant-start-point ap) \\n                     (tgaa.struct.ant/ant-end-point ap))])" "(let [ap (first (shared/canidates))]\\n      ref-pnt (if (< (first (tgaa.struct.ant/ant-start-point ap)) (first (tgaa.struct.ant/ant-end-point ap)))\\n                     (tgaa.struct.ant/ant-start-point ap) \\n                     (tgaa.struct.ant/ant-end-point ap)))" "(let [ap (first (shared/canidates))]\\n  (if (< (first (tgaa.struct.ant/ant-start-point ap)) (first (tgaa.struct.ant/ant-end-point ap)))\\n    (tgaa.struct.ant/ant-start-point ap) \\n    (tgaa.struct.ant/ant-end-point ap)))" "(let [ap (second (shared/canidates))]\\n  (if (< (first (tgaa.struct.ant/ant-start-point ap)) (first (tgaa.struct.ant/ant-end-point ap)))\\n    (tgaa.struct.ant/ant-start-point ap) \\n    (tgaa.struct.ant/ant-end-point ap)))" "(let [ap (nth (shared/canidates) 10)]\\n  (if (< (first (tgaa.struct.ant/ant-start-point ap)) (first (tgaa.struct.ant/ant-end-point ap)))\\n    (tgaa.struct.ant/ant-start-point ap) \\n    (tgaa.struct.ant/ant-end-point ap)))" "(let [ap (nth (shared/canidates) 100)]\\n  (if (< (first (tgaa.struct.ant/ant-start-point ap)) (first (tgaa.struct.ant/ant-end-point ap)))\\n    (tgaa.struct.ant/ant-start-point ap) \\n    (tgaa.struct.ant/ant-end-point ap)))" "(defn formula-ref-point [ap]\\n  (if (< (first (tgaa.struct.ant/ant-start-point ap)) (first (tgaa.struct.ant/ant-end-point ap)))\\n    (tgaa.struct.ant/ant-start-point ap) \\n    (tgaa.struct.ant/ant-end-point ap)))" "\\r\\n\\r\\n(defn derive-slope [ap]\\r\\n  (let [[x y] (map \#(- %1 %2) (tgaa.struct.ant/ant-start-point ap) (tgaa.struct.ant/ant-end-point ap))]\\r\\n    (if (and (\= x 0) (\= y 0))\\r\\n      (do (print \\"Invalid Slope\\") \\"fail\\")\\r\\n      (if (\= 0 y) \\r\\n        \\"inf\\"\\r\\n        (/ y x)))))\\r\\n\\r\\n(defn formula-ref-point [ap]\\r\\n  (if (< (first (tgaa.struct.ant/ant-start-point ap)) (first (tgaa.struct.ant/ant-end-point ap)))\\r\\n    (tgaa.struct.ant/ant-start-point ap) \\r\\n    (tgaa.struct.ant/ant-end-point ap)))" "(defn slp-int-formula [ap]\\n  (let [slp (derive-slope ap)\\n        [x c] (formula-ref-point ap)]\\n    [slp x c]))" "(slp-int-formula (first (shared/canidates)))" "(slp-int-formula (nth (shared/canidates) 10))" "(slp-int-formula (nth (shared/canidates) 15))" "(defn find-intercept [ap1 ap2]\\n  (let [[slp1 x1 c1] (slp-int-formula ap1)\\n        [slp2 x2 c2] (slp-int-formula ap2)]   \\n  (cond \\r\\n      (or (\= slp1 \\"fail\\") (\= slp2 \\"fail\\"))\\r\\n      \\"none\\"\\r\\n      (and (\= slp1 \\"inf\\") (\= slp2 \\"inf\\"))\\r\\n      (if (not\= x1 x2) \\"none\\" \\"all\\")\\r\\n      (\= slp1 \\"inf\\") \\r\\n       [x1 (+ (* slp2 x1) c2)]\\r\\n      (\= slp2 \\"inf\\")  \\r\\n       [x2 (+ (* slp1 x2) c1)]\\r\\n      \:defualt         \\n      (let [x (/ (- c2 c1) (- slp1 slp2))]\\r\\n       [ x (+ (* slp2 x) c2)]))))" "(find-intercept (first (shared/canidates)) (second (shared/canidates)) )" "(find-intercept (first (shared/canidates)) (nth (shared/canidates)) 10)" "(find-intercept (first (shared/canidates)) (nth (shared/canidates)10) )" "(find-intercept (first (shared/canidates)) (nth (shared/canidates)100) )" "(defn find-intercept [ap1 ap2]\\n  (let [[slp1 x1 c1] (slp-int-formula ap1)\\n        [slp2 x2 c2] (slp-int-formula ap2)]   \\n  (cond \\r\\n      (or (\= slp1 \\"fail\\") (\= slp2 \\"fail\\"))\\r\\n      \\"none\\"\\r\\n      (and (\= slp1 \\"inf\\") (\= slp2 \\"inf\\"))\\r\\n      (if (not\= x1 x2) \\"none\\" \\"par\\")\\n      (\= slp1 slp2)\\n      \\"par\\"\\r\\n      (\= slp1 \\"inf\\") \\r\\n       [x1 (+ (* slp2 x1) c2)]\\r\\n      (\= slp2 \\"inf\\")  \\r\\n       [x2 (+ (* slp1 x2) c1)]\\r\\n      \:defualt         \\n      (let [x (/ (- c2 c1) (- slp1 slp2))]\\r\\n       [ x (+ (* slp2 x) c2)]))))" "(find-intercept (first (shared/canidates)) (nth (shared/canidates)100) )" "(defn find-intercept [ap1 ap2]\\n  (let [[slp1 x1 c1] (slp-int-formula ap1)\\n        [slp2 x2 c2] (slp-int-formula ap2)]   \\n  (cond \\r\\n      (or (\= slp1 \\"fail\\") (\= slp2 \\"fail\\"))\\r\\n      \\"none\\"\\r\\n      (and (\= slp1 \\"inf\\") (\= slp2 \\"inf\\"))\\r\\n      (if (not\= x1 x2) \\"none\\" \\"par\\")\\n      (\= slp1 slp2)\\n      \\"par\\"\\r\\n      (\= slp1 \\"inf\\") \\r\\n       [x1 (+ (* slp2 x1) c2)]\\r\\n      (\= slp2 \\"inf\\")  \\r\\n       [x2 (+ (* slp1 x2) c1)]\\r\\n      \:defualt         \\n      (let [x (/ (- c2 c1) (- slp1 slp2))]\\r\\n       [ x (+ (* slp2 x) c2)]))))" "(find-intercept (first (shared/canidates)) (nth (shared/canidates)100) )" "(defn find-intercept [ap1 ap2]\\n  (let [[slp1 x1 c1] (slp-int-formula ap1)\\n        [slp2 x2 c2] (slp-int-formula ap2)]   \\n  (cond \\r\\n      (do (print \\"here\\") (or (\= slp1 \\"fail\\") (\= slp2 \\"fail\\")))\\r\\n      \\"none\\"\\r\\n      (and (\= slp1 \\"inf\\") (\= slp2 \\"inf\\"))\\r\\n      (if (not\= x1 x2) \\"none\\" \\"par\\")\\n      (\= slp1 slp2)\\n      \\"par\\"\\r\\n      (\= slp1 \\"inf\\") \\r\\n       [x1 (+ (* slp2 x1) c2)]\\r\\n      (\= slp2 \\"inf\\")  \\r\\n       [x2 (+ (* slp1 x2) c1)]\\r\\n      \:defualt         \\n      (let [x (/ (- c2 c1) (- slp1 slp2))]\\r\\n       [ x (+ (* slp2 x) c2)]))))" "(find-intercept (first (shared/canidates)) (nth (shared/canidates)100) )" "(defn find-intercept [ap1 ap2]\\n  (let [_ (print \\"here\\")\\n        [slp1 x1 c1] (slp-int-formula ap1)\\n        [slp2 x2 c2] (slp-int-formula ap2)]   \\n  (cond \\r\\n      (or (\= slp1 \\"fail\\") (\= slp2 \\"fail\\"))\\r\\n      \\"none\\"\\r\\n      (and (\= slp1 \\"inf\\") (\= slp2 \\"inf\\"))\\r\\n      (if (not\= x1 x2) \\"none\\" \\"par\\")\\n      (\= slp1 slp2)\\n      \\"par\\"\\r\\n      (\= slp1 \\"inf\\") \\r\\n       [x1 (+ (* slp2 x1) c2)]\\r\\n      (\= slp2 \\"inf\\")  \\r\\n       [x2 (+ (* slp1 x2) c1)]\\r\\n      \:defualt         \\n      (let [x (/ (- c2 c1) (- slp1 slp2))]\\r\\n       [ x (+ (* slp2 x) c2)]))))" "(find-intercept (first (shared/canidates)) (nth (shared/canidates)100) )" "(defn find-intercept [ap1 ap2]\\n  (let [_ (print \\"here\\")\\n        [slp1 x1 c1] (slp-int-formula ap1)\\n        _ (print \\"here\\")\\n        [slp2 x2 c2] (slp-int-formula ap2)]   \\n  (cond \\r\\n      (or (\= slp1 \\"fail\\") (\= slp2 \\"fail\\"))\\r\\n      \\"none\\"\\r\\n      (and (\= slp1 \\"inf\\") (\= slp2 \\"inf\\"))\\r\\n      (if (not\= x1 x2) \\"none\\" \\"par\\")\\n      (\= slp1 slp2)\\n      \\"par\\"\\r\\n      (\= slp1 \\"inf\\") \\r\\n       [x1 (+ (* slp2 x1) c2)]\\r\\n      (\= slp2 \\"inf\\")  \\r\\n       [x2 (+ (* slp1 x2) c1)]\\r\\n      \:defualt         \\n      (let [x (/ (- c2 c1) (- slp1 slp2))]\\r\\n       [ x (+ (* slp2 x) c2)]))))" "(find-intercept (first (shared/canidates)) (nth (shared/canidates)100) )" "(defn find-intercept [ap1 ap2]\\n  (let [_ (print \\"here\\")\\n        [slp1 x1 c1] (slp-int-formula ap1)\\n        _ (print \\"here\\")\\n        [slp2 x2 c2] (slp-int-formula ap2)\\n        (print \\"here\\")]   \\n  (cond \\r\\n      (or (\= slp1 \\"fail\\") (\= slp2 \\"fail\\"))\\r\\n      \\"none\\"\\r\\n      (and (\= slp1 \\"inf\\") (\= slp2 \\"inf\\"))\\r\\n      (if (not\= x1 x2) \\"none\\" \\"par\\")\\n      (\= slp1 slp2)\\n      \\"par\\"\\r\\n      (\= slp1 \\"inf\\") \\r\\n       [x1 (+ (* slp2 x1) c2)]\\r\\n      (\= slp2 \\"inf\\")  \\r\\n       [x2 (+ (* slp1 x2) c1)]\\r\\n      \:defualt         \\n      (let [x (/ (- c2 c1) (- slp1 slp2))]\\r\\n       [ x (+ (* slp2 x) c2)]))))" "(defn find-intercept [ap1 ap2]\\n  (let [_ (print \\"here\\")\\n        [slp1 x1 c1] (slp-int-formula ap1)\\n        _ (print \\"here\\")\\n        [slp2 x2 c2] (slp-int-formula ap2)\\n        _ (print \\"here\\")]   \\n  (cond \\r\\n      (or (\= slp1 \\"fail\\") (\= slp2 \\"fail\\"))\\r\\n      \\"none\\"\\r\\n      (and (\= slp1 \\"inf\\") (\= slp2 \\"inf\\"))\\r\\n      (if (not\= x1 x2) \\"none\\" \\"par\\")\\n      (\= slp1 slp2)\\n      \\"par\\"\\r\\n      (\= slp1 \\"inf\\") \\r\\n       [x1 (+ (* slp2 x1) c2)]\\r\\n      (\= slp2 \\"inf\\")  \\r\\n       [x2 (+ (* slp1 x2) c1)]\\r\\n      \:defualt         \\n      (let [x (/ (- c2 c1) (- slp1 slp2))]\\r\\n       [ x (+ (* slp2 x) c2)]))))" "(find-intercept (first (shared/canidates)) (nth (shared/canidates)100) )" "(defn find-intercept [ap1 ap2]\\n  (let [_ (print \\"here\\")\\n        [slp1 x1 c1] (slp-int-formula ap1)\\n        _ (print \\"here\\")\\n        [slp2 x2 c2] (slp-int-formula ap2)]   \\n  (cond \\r\\n      (or (\= slp1 \\"fail\\") (\= slp2 \\"fail\\"))\\r\\n      \\"none\\"\\r\\n      (and (\= slp1 \\"inf\\") (\= slp2 \\"inf\\"))\\r\\n      (if (not\= x1 x2) \\"none\\" \\"par\\")\\n      (\= slp1 slp2)\\n      \\"par\\"\\r\\n      (\= slp1 \\"inf\\") \\r\\n       [x1 (+ (* slp2 x1) c2)]\\r\\n      (\= slp2 \\"inf\\")  \\r\\n       [x2 (+ (* slp1 x2) c1)]\\r\\n      \:defualt         \\n      (let [x (/ (- c2 c1) (- slp1 slp2))]\\r\\n       [ x (+ (* slp2 x) c2)]))))" "(defn derive-slope [ap]\\r\\n  (let [[x y] (map \#(- %1 %2) (tgaa.struct.ant/ant-start-point ap) (tgaa.struct.ant/ant-end-point ap))]\\r\\n    (if (and (\= x 0) (\= y 0))\\r\\n      (do (print \\"Invalid Slope\\") \\"fail\\")\\r\\n      (if (\= 0 x) \\r\\n        \\"inf\\"\\r\\n        (/ y x)))))" "(defn find-intercept [ap1 ap2]\\n  (let [[slp1 x1 c1] (slp-int-formula ap1)\\n        [slp2 x2 c2] (slp-int-formula ap2)]   \\n  (cond \\r\\n      (or (\= slp1 \\"fail\\") (\= slp2 \\"fail\\"))\\r\\n      \\"none\\"\\r\\n      (and (\= slp1 \\"inf\\") (\= slp2 \\"inf\\"))\\r\\n      (if (not\= x1 x2) \\"none\\" \\"par\\")\\n      (\= slp1 slp2)\\n      \\"par\\"\\r\\n      (\= slp1 \\"inf\\") \\r\\n       [x1 (+ (* slp2 x1) c2)]\\r\\n      (\= slp2 \\"inf\\")  \\r\\n       [x2 (+ (* slp1 x2) c1)]\\r\\n      \:defualt         \\n      (let [x (/ (- c2 c1) (- slp1 slp2))]\\r\\n       [ x (+ (* slp2 x) c2)]))))" "(find-intercept (first (shared/canidates)) (nth (shared/canidates)100) )" "(find-intercept (first (shared/canidates)) (nth (shared/canidates)101) )" "(find-intercept (first (shared/canidates)) (nth (shared/canidates)110) )" "(find-intercept (first (shared/canidates)) (nth (shared/canidates)120) )" "(find-intercept (first (shared/canidates)) (nth (shared/canidates)10) )" "(find-intercept (first (shared/canidates)) (nth (shared/canidates)11) )" "(defn find-intercept [ap1 ap2]\\n  (let [[slp1 x1 c1] (slp-int-formula ap1)\\n        [slp2 x2 c2] (slp-int-formula ap2)]   \\n  (cond \\r\\n      (or (\= slp1 \\"fail\\") (\= slp2 \\"fail\\"))\\r\\n      \\"none\\"\\r\\n      (and (\= slp1 \\"inf\\") (\= slp2 \\"inf\\"))\\r\\n      (if (not\= x1 x2) \\"none\\" \\"par\\")\\n      (\= slp1 slp2)\\n      \\"par\\"\\r\\n      (\= slp1 \\"inf\\") \\r\\n       [x1 (+ (* slp2 x1) c2)]\\r\\n      (\= slp2 \\"inf\\")  \\r\\n       [x2 (+ (* slp1 x2) c1)]\\r\\n      \:defualt         \\n      (let [x (/ (- c2 c1) (- slp1 slp2))]\\r\\n       [ x (+ (* slp2 x) c2) c2]))))" "(find-intercept (first (shared/canidates)) (nth (shared/canidates)11) )" "(find-intercept (first (shared/canidates)) (nth (shared/canidates)15) )" "(defn find-intercept [ap1 ap2]\\n  (let [[slp1 x1 c1] (slp-int-formula ap1)\\n        [slp2 x2 c2] (slp-int-formula ap2)]   \\n  (cond \\r\\n      (or (\= slp1 \\"fail\\") (\= slp2 \\"fail\\"))\\r\\n      \\"none\\"\\r\\n      (and (\= slp1 \\"inf\\") (\= slp2 \\"inf\\"))\\r\\n      (if (not\= x1 x2) \\"none\\" \\"par\\")\\n      (\= slp1 slp2)\\n      \\"par\\"\\r\\n      (\= slp1 \\"inf\\") \\r\\n       [x1 (+ (* slp2 x1) c2)]\\r\\n      (\= slp2 \\"inf\\")  \\r\\n       [x2 (+ (* slp1 x2) c1)]\\r\\n      \:defualt         \\n      (let [x (/ (- c2 c1) (- slp1 slp2))]\\r\\n       [ x (+ (* slp2 x) c2) c2 slp2]))))" "(find-intercept (first (shared/canidates)) (nth (shared/canidates)15) )" "(defn find-intercept [ap1 ap2]\\n  (let [[slp1 x1 c1] (slp-int-formula ap1)\\n        [slp2 x2 c2] (slp-int-formula ap2)]   \\n  (cond \\r\\n      (or (\= slp1 \\"fail\\") (\= slp2 \\"fail\\"))\\r\\n      \\"none\\"\\r\\n      (and (\= slp1 \\"inf\\") (\= slp2 \\"inf\\"))\\r\\n      (if (not\= x1 x2) \\"none\\" \\"par\\")\\n      (\= slp1 slp2)\\n      \\"par\\"\\r\\n      (\= slp1 \\"inf\\") \\r\\n       [x1 (+ (* slp2 x1) c2)]\\r\\n      (\= slp2 \\"inf\\")  \\r\\n       [x2 (+ (* slp1 x2) c1)]\\r\\n      \:defualt         \\n      (let [x (/ (- c2 c1) (- slp1 slp2))]\\r\\n       [ x (+ (* slp2 x) c2) c2 slp2 x]))))" "(find-intercept (first (shared/canidates)) (nth (shared/canidates)15) )" "(defn find-intercept [ap1 ap2]\\n  (let [[slp1 x1 c1] (slp-int-formula ap1)\\n        [slp2 x2 c2] (slp-int-formula ap2)\\n        _ (println [slp1 x1 c1])\\n        (println [slp2 x2 c2])]   \\n  (cond \\r\\n      (or (\= slp1 \\"fail\\") (\= slp2 \\"fail\\"))\\r\\n      \\"none\\"\\r\\n      (and (\= slp1 \\"inf\\") (\= slp2 \\"inf\\"))\\r\\n      (if (not\= x1 x2) \\"none\\" \\"par\\")\\n      (\= slp1 slp2)\\n      \\"par\\"\\r\\n      (\= slp1 \\"inf\\") \\r\\n       [x1 (+ (* slp2 x1) c2)]\\r\\n      (\= slp2 \\"inf\\")  \\r\\n       [x2 (+ (* slp1 x2) c1)]\\r\\n      \:defualt         \\n      (let [x (/ (- c2 c1) (- slp1 slp2))]\\r\\n       [ x (+ (* slp2 x) c2) c2 slp2 x]))))" "(defn find-intercept [ap1 ap2]\\n  (let [[slp1 x1 c1] (slp-int-formula ap1)\\n        [slp2 x2 c2] (slp-int-formula ap2)\\n        _ (println [slp1 x1 c1])\\n        _ (println [slp2 x2 c2])]   \\n  (cond \\r\\n      (or (\= slp1 \\"fail\\") (\= slp2 \\"fail\\"))\\r\\n      \\"none\\"\\r\\n      (and (\= slp1 \\"inf\\") (\= slp2 \\"inf\\"))\\r\\n      (if (not\= x1 x2) \\"none\\" \\"par\\")\\n      (\= slp1 slp2)\\n      \\"par\\"\\r\\n      (\= slp1 \\"inf\\") \\r\\n       [x1 (+ (* slp2 x1) c2)]\\r\\n      (\= slp2 \\"inf\\")  \\r\\n       [x2 (+ (* slp1 x2) c1)]\\r\\n      \:defualt         \\n      (let [x (/ (- c2 c1) (- slp1 slp2))]\\r\\n       [ x (+ (* slp2 x) c2) c2 slp2 x]))))" "(find-intercept (first (shared/canidates)) (nth (shared/canidates)15) )" "(find-intercept (nth (shared/canidates)20) (nth (shared/canidates)15) )" "(defn is-intersect [path-1 path-2]\\r\\n  (let [max-width (image/image-width (shared/image-ref))\\r\\n        max-height (image/image-height (shared/image-ref))\\r\\n        [start-x-1 start-y-1] (ant/ant-start-point path-1)\\r\\n        [end-x-1 end-y-1] (ant/ant-end-point path-1)\\r\\n        intercept (find-intercept path-1 path-2)\\r\\n        [x-int y-int] intercept]\\r\\n    (cond \\r\\n      (\= \\"none\\" intercept)\\r\\n      false\\r\\n      (\= \\"par\\" intercept)\\r\\n      \\"not done yet\\"\\r\\n      (and (line-intersect? start-x-1 end-x-1 start-y-1 end-y-1 x-int y-int)\\r\\n           (line-intersect? start-x-2 end-x-2 start-y-2 end-y-2 x-int y-int))\\r\\n           true\\r\\n           false)))" "(defn is-intersect [path-1 path-2]\\r\\n  (let [max-width (tgaa.struct.image/image-width (shared/image-ref))\\r\\n        max-height (tgaa.struct.image/image-height (shared/image-ref))\\r\\n        [start-x-1 start-y-1] (ant/ant-start-point path-1)\\r\\n        [end-x-1 end-y-1] (ant/ant-end-point path-1)\\r\\n        intercept (find-intercept path-1 path-2)\\r\\n        [x-int y-int] intercept]\\r\\n    (cond \\r\\n      (\= \\"none\\" intercept)\\r\\n      false\\r\\n      (\= \\"par\\" intercept)\\r\\n      \\"not done yet\\"\\r\\n      (and (line-intersect? start-x-1 end-x-1 start-y-1 end-y-1 x-int y-int)\\r\\n           (line-intersect? start-x-2 end-x-2 start-y-2 end-y-2 x-int y-int))\\r\\n           true\\r\\n           false)))" "(defn is-intersect [path-1 path-2]\\r\\n  (let [max-width (tgaa.struct.image/image-width (shared/image-ref))\\r\\n        max-height (tgaa.struct.image/image-height (shared/image-ref))\\r\\n        [start-x-1 start-y-1] (ant/ant-start-point path-1)\\r\\n        [end-x-1 end-y-1] (tgaa.struct.ant/ant-end-point path-1)\\r\\n        intercept (find-intercept path-1 path-2)\\r\\n        [x-int y-int] intercept]\\r\\n    (cond \\r\\n      (\= \\"none\\" intercept)\\r\\n      false\\r\\n      (\= \\"par\\" intercept)\\r\\n      \\"not done yet\\"\\r\\n      (and (line-intersect? start-x-1 end-x-1 start-y-1 end-y-1 x-int y-int)\\r\\n           (line-intersect? start-x-2 end-x-2 start-y-2 end-y-2 x-int y-int))\\r\\n           true\\r\\n           false)))" "(defn is-intersect [path-1 path-2]\\r\\n  (let [max-width (tgaa.struct.image/image-width (shared/image-ref))\\r\\n        max-height (tgaa.struct.image/image-height (shared/image-ref))\\r\\n        [start-x-1 start-y-1] (tgaa.struct.ant/ant-start-point path-1)\\r\\n        [end-x-1 end-y-1] (tgaa.struct.ant/ant-end-point path-1)\\r\\n        intercept (find-intercept path-1 path-2)\\r\\n        [x-int y-int] intercept]\\r\\n    (cond \\r\\n      (\= \\"none\\" intercept)\\r\\n      false\\r\\n      (\= \\"par\\" intercept)\\r\\n      \\"not done yet\\"\\r\\n      (and (line-intersect? start-x-1 end-x-1 start-y-1 end-y-1 x-int y-int)\\r\\n           (line-intersect? start-x-2 end-x-2 start-y-2 end-y-2 x-int y-int))\\r\\n           true\\r\\n           false)))" "(defn slp-int-formula [ap]\\r\\n  (let [slp (derive-slope ap)\\r\\n        [x c] (formula-ref-point ap)]\\r\\n    [slp x c]))\\r\\n\\r\\n(defn axis-intersect? [axis-pnt-1 axis-pnt-2 axis-int-pnt]\\r\\n                 (if (or  \\r\\n                       (and (<\= axis-pnt-1 axis-pnt-2) (<\= axis-pnt-1 axis-int-pnt) (>\= axis-pnt-2 axis-int-pnt))\\r\\n                       (and (>\= axis-pnt-1 axis-pnt-2) (>\= axis-pnt-1 axis-int-pnt) (<\= axis-pnt-2 axis-int-pnt)))\\r\\n                   true\\r\\n                   false))\\r\\n\\r\\n(defn find-intercept [ap1 ap2]\\r\\n  (let [[slp1 x1 c1] (slp-int-formula ap1)\\r\\n        [slp2 x2 c2] (slp-int-formula ap2)]   \\r\\n  (cond \\r\\n      (or (\= slp1 \\"fail\\") (\= slp2 \\"fail\\"))\\r\\n      \\"none\\"\\r\\n      (and (\= slp1 \\"inf\\") (\= slp2 \\"inf\\"))\\r\\n      (if (not\= x1 x2) \\"none\\" \\"par\\")\\r\\n      (\= slp1 slp2)\\r\\n      \\"par\\"\\r\\n      (\= slp1 \\"inf\\") \\r\\n       [x1 (+ (* slp2 x1) c2)]\\r\\n      (\= slp2 \\"inf\\")  \\r\\n       [x2 (+ (* slp1 x2) c1)]\\r\\n      \:defualt         \\r\\n      (let [x (/ (- c2 c1) (- slp1 slp2))]\\r\\n       [x (+ (* slp2 x) c2) c2 slp2 x]))))\\r\\n\\r\\n(defn line-intersect? [start-x end-x start-y end-y x-int y-int]\\r\\n  (and (axis-intersect? start-x end-x x-int)\\r\\n       (axis-intersect? start-y end-y y-int)))" "(defn is-intersect [path-1 path-2]\\r\\n  (let [max-width (tgaa.struct.image/image-width (shared/image-ref))\\r\\n        max-height (tgaa.struct.image/image-height (shared/image-ref))\\r\\n        [start-x-1 start-y-1] (tgaa.struct.ant/ant-start-point path-1)\\r\\n        [end-x-1 end-y-1] (tgaa.struct.ant/ant-end-point path-1)\\r\\n        intercept (find-intercept path-1 path-2)\\r\\n        [x-int y-int] intercept]\\r\\n    (cond \\r\\n      (\= \\"none\\" intercept)\\r\\n      false\\r\\n      (\= \\"par\\" intercept)\\r\\n      \\"not done yet\\"\\r\\n      (and (line-intersect? start-x-1 end-x-1 start-y-1 end-y-1 x-int y-int)\\r\\n           (line-intersect? start-x-2 end-x-2 start-y-2 end-y-2 x-int y-int))\\r\\n           true\\r\\n           false)))" "(defn is-intersect [path-1 path-2]\\r\\n  (let [max-width (tgaa.struct.image/image-width (shared/image-ref))\\r\\n        max-height (tgaa.struct.image/image-height (shared/image-ref))\\r\\n        [start-x-1 start-y-1] (tgaa.struct.ant/ant-start-point path-1)\\r\\n        [end-x-1 end-y-1] (tgaa.struct.ant/ant-end-point path-1)\\n        [start-x-2 start-y-2] (tgaa.struct.ant/ant-start-point path-2)\\r\\n        [end-x-2 end-y-2] (tgaa.struct.ant/ant-end-point path-2)\\r\\n        intercept (find-intercept path-1 path-2)\\r\\n        [x-int y-int] intercept]\\r\\n    (cond \\r\\n      (\= \\"none\\" intercept)\\r\\n      false\\r\\n      (\= \\"par\\" intercept)\\r\\n      \\"not done yet\\"\\r\\n      (and (line-intersect? start-x-1 end-x-1 start-y-1 end-y-1 x-int y-int)\\r\\n           (line-intersect? start-x-2 end-x-2 start-y-2 end-y-2 x-int y-int))\\r\\n           true\\r\\n           false)))" "(defn is-intersect [path-1 path-2]\\r\\n  (let [max-width (tgaa.struct.image/image-width (shared/image-ref))\\r\\n        max-height (tgaa.struct.image/image-height (shared/image-ref))\\r\\n        [start-x-1 start-y-1] (tgaa.struct.ant/ant-start-point path-1)\\r\\n        [end-x-1 end-y-1] (tgaa.struct.ant/ant-end-point path-1)\\n        [start-x-2 start-y-2] (tgaa.struct.ant/ant-start-point path-2)\\r\\n        [end-x-2 end-y-2] (tgaa.struct.ant/ant-end-point path-2)\\r\\n        intercept (find-intercept path-1 path-2)\\r\\n        [x-int y-int] intercept]\\r\\n    (cond \\r\\n      (\= \\"none\\" intercept)\\r\\n      false\\r\\n      (\= \\"par\\" intercept)\\r\\n      \\"not done yet\\"\\r\\n      (and (line-intersect? start-x-1 end-x-1 start-y-1 end-y-1 x-int y-int)\\r\\n           (line-intersect? start-x-2 end-x-2 start-y-2 end-y-2 x-int y-int))\\r\\n           true\\r\\n      \:default     false)))" "(defn is-par-overlap [path-1 path-2]\\n  (let [[start-x-1 start-y-1] (tgaa.struct.ant/ant-start-point path-1)\\r\\n        [end-x-1 end-y-1] (tgaa.struct.ant/ant-end-point path-1)\\r\\n        [start-x-2 start-y-2] (tgaa.struct.ant/ant-start-point path-2)\\r\\n        [end-x-2 end-y-2] (tgaa.struct.ant/ant-end-point path-2)]\\n    (range" "(range 1 100)" "(range 1 1)" "(shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(def d (phase/trapping))" "(def d (phase/evaluation))" "(viz/animate-algo)" "(shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(last (phase/trapping) )" "(last (phase/evaluation))" "(viz/animate-algo)" "(viz/show-salient-paths 1)" "(viz/show-salient-paths 0)" "(count (shared/salient-results))" "(phase/evaluation)" "(tgaa.algo.analysis/salient-regions)" "(first (phase/evaluation))" "(viz/show-salient-paths 0)" "(viz/show-salient-paths 01)" "(viz/show-salient-paths 1)" "(viz/animate-algo)" "(first (phase/evaluation))" "(viz/show-salient-paths 0)" "(viz/show-salient-paths 1)" "(first (shared/salient-ids))" "(viz/show-salient-paths 4)" "(count (shared/salient-ids))" "(count (shared/salient-results))" "(first (shared/salient-results))" "(shared/salient-results)" "(viz/show-salient-paths 3)" "(viz/show-salient-paths 4)" "(viz/show-salient-paths 0)" "(shared/salient-results)" "(viz/show-salient-paths 0)" "(viz/show-salient-paths 4)" "(shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(first (phase/trapping) )" "(phase/trapping)" "(first (phase/evaluation))" "(viz/animate-algo)" "(shared/salient-results)" "(viz/show-salient-paths 2)" "(viz/show-salient-paths 1\\n                        )" "(viz/show-cann-path)" "(viz/show-eval-paths)" "(viz/show-salient-paths)" "(tgaa.algo.analysis/is-intersect (nth (shared/eval-paths) 1)(nth (shared/eval-paths) 2))" "(tgaa.algo.analysis/is-intersect (nth (shared/eval-paths) 1)(nth (shared/eval-paths) 3))" "(tgaa.algo.analysis/is-intersect (nth (shared/eval-paths) 1)(nth (shared/eval-paths) 4))" "(tgaa.algo.analysis/is-intersect (nth (shared/eval-paths) 1)(nth (shared/eval-paths) 6))" "(first (shared/salient-results))" "(first (shared/salient-ids))" "(shared/salient-results)" "(def g3 (map \#(\= (\:group %) 3) (shared/salient-ids)))" "(first g3)" "(def g3 (filter \#((\= (\:group %)) (shared/salient-ids)))" "(def g3 (filter \#((\= (\:group %)) (shared/salient-ids))))" "(first g3)" "(def g3 (filter \#(\= (\:group %)) (shared/salient-ids)))" "(first g3)" "(tgaa.algo.analysis/is-intersect (nth g3 2) (nth g3 4))(" "(tgaa.algo.analysis/is-intersect (nth g3 2) (nth g3 4))" "(viz/show-salient-paths 2)" "(viz/show-salient-paths 4)" "(shared/salient-results)" "(viz/show-salient-paths 1)" "(viz/show-salient-paths )" "(viz/show-cann-path )" "(first (phase/evaluation))" "(shared/salient-results)" "(first (phase/evaluation))" "(shared/salient-results)" "(viz/show-salient-paths 1)" "(first (phase/evaluation))" "(shared/salient-results)" "(first (phase/evaluation))" "(shared/salient-results)" "(viz/show-salient-paths 1)" "(first (phase/evaluation))" "(shared/salient-results)" "(viz/show-salient-paths 6)" "(viz/show-salient-paths 1)" "(first (phase/evaluation))" "(shared/salient-results)" "(viz/show-salient-paths 1)" "(viz/show-salient-paths 37)" "(viz/show-salient-paths 6)" "(process-all-mri)" "(run-processor)" "(process-all-mri)" "(run-processor)" "(get-out-dir)" "(str (get-out-dir))" "(concat [\\"one\\"] \\"two\\")" "(run-processor)" "(shared/init-trail-state)" "(in-ns tgaa.algo.core)" "(in-ns '\\n        tgaa.algo.core)" "(shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(phase/evaluation)" "(viz/animate-algo)" "(import 'java.awt.Color)" "(viz/animate-algo)" "(in-ns 'tgaa.util.mri-converter)" "(sh \\"dcm2jpg.exe\\")" "(print (sh \\"dcm2jpg.exe\\"))" "(in-ns '\\n        tgaa.algo.core)" "(shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(phase/evaluation)" "(viz/animate-algo)" "(shared/init-trail-state)" "(phase/bootstrap)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(phase/evaluation)" "(viz/animate-algo)" "(shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(phase/evaluation)" "(viz/animate-algo)" "(shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(phase/evaluation)" "(viz/animate-algo)" "(shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(phase/evaluation)" "(viz/animate-algo)" "(shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(phase/evaluation)" "(viz/animate-algo)" "(shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(phase/evaluation)" "(viz/animate-algo)" "(shared/init-trail-state)" "(phase/load-image)" "(phase/bootstrap)" "(phase/trapping)" "(phase/evaluation)" "(viz/animate-algo)" "(get-dir \\"Test\\")" "(get-dir \\"Test\\" \:file\\n         )" "(in-ns 'tgaa.algo.core)" "(shared/image-ref)" "(shared/image-loc)" "(shared/image-loc \\"test\\")" "(shared/image-loc)" "(shared/image-loc \\"test\\")" "(shared/image-loc)" "(shared/image-loc \\"test\\")" "(shared/image-loc)" "(process-image)" "(import 'java.awt.Color)" "(process-image)" "(+ 1 1)" "(use 'java.awt.Color)" "(use java.awt.Color)" "(use [java.awt.Color])" "(use [java.awt Color])" "(process-image)" "(clojure.asm.ClassReader.)" "(clojure.asm.ClassReader. \\"java.awt.Color\\")" "(-> clojure.asm.ClassReader. (.-b \\"java.awt.Color\\"))" "(. clojure.asm.ClassReader. -b \\"java.awt.Color\\")" "(require '(java.awt.Color)" "(require 'java.awt.Color)" "(import 'java.awt.Color)" "(process-image)" "(macroexpand (import 'java.awt.Color'))" "(macroexpand (import 'java.awt.Color))" "(macroexpand '(import 'java.awt.Color))" "(process-image)" "(tgaa.struct.image/load-import)" "(process-image)" "(JFrame. \\"Hello Frame\\")" "(in-ns 'tgaa.util.gui)" "(JFrame. \\"Hello Frame\\")" "(import 'javax.swing.JFrame)\\r\\n(def frame (JFrame. \\"Hello Frame\\"))\\r\\n(.setSize frame 200 200)\\r\\n(.setVisible frame true)" "(import JOptionPane)" "(import javax.swing.JOptionPane)" "(. JOptionPane showOptionDialog (JFrame. \\"Hello Frame\\") \\"test\\" 1 2)" "(. (JOptionPane.) showOptionDialog (JFrame. \\"Hello Frame\\") \\"test\\" 1 2)" "(. (new JOptionPane) showOptionDialog (JFrame. \\"Hello Frame\\") \\"test\\" 1 2)" "(. (new JOptionPane) showOptionDialog (JFrame. \\"Hello Frame\\") \\"test\\" \\"test\\"\\n  JOptionPane.YES_NO_CANCEL_OPTION JOptionPane.QUESTION_MESSAGE\\n  nil nil nil)" "(. (new JOptionPane) showOptionDialog (JFrame. \\"Hello Frame\\") \\"test\\" \\"test\\"\\n  JOptionPane/YES_NO_CANCEL_OPTION JOptionPane/QUESTION_MESSAGE\\n  nil nil nil)" "(JOptionPane/showOptionDialog (JFrame. \\"Hello Frame\\") \\"test\\" \\"test\\"\\n  JOptionPane/YES_NO_CANCEL_OPTION JOptionPane/QUESTION_MESSAGE\\n  nil nil nil)" "(defn showOptionDialog [question]\\n(JOptionPane/showOptionDialog (JFrame. \\"Hello Frame\\") \\"test\\" \\"test\\"\\n  JOptionPane/YES_NO_CANCEL_OPTION JOptionPane/QUESTION_MESSAGE\\n  nil nil nil))" "(defn showOptionDialog [question]\\n  (JOptionPane/showOptionDialog (JFrame. \\"Hello Frame\\") \\"test\\" \\"test\\"\\n                                JOptionPane/YES_NO_CANCEL_OPTION JOptionPane/QUESTION_MESSAGE\\n                                nil nil nil))" "(showOptionDialog \\"test?\\")" "(defn option-dialog [question]\\n  (JOptionPane/showOptionDialog (JFrame. \\"Hello Frame\\") question \\"test\\"\\n                                JOptionPane/YES_NO_CANCEL_OPTION JOptionPane/QUESTION_MESSAGE\\n                                nil nil nil))" "(option-dialog \\"test?\\")" "(defn option-dialog [question]\\n  (JOptionPane/showOptionDialog (JFrame.) question \\"Select an option.\\"\\n                                JOptionPane/YES_NO_CANCEL_OPTION JOptionPane/QUESTION_MESSAGE\\n                                nil nil nil))" "(option-dialog \\"test?\\")" "(defn option-dialog [question & buttons]\\n  (let [[yes-desc no-desc cancel-desc] buttons]\\n  (JOptionPane/showOptionDialog (JFrame. \\"Hello Frame\\") question \\"test\\"\\n                                JOptionPane/YES_NO_CANCEL_OPTION JOptionPane/QUESTION_MESSAGE\\n                                [yes-desc no-desc cancel-desc] nil nil))" "(defn option-dialog [question & buttons]\\n  (let [[yes-desc no-desc cancel-desc] buttons]\\n  (JOptionPane/showOptionDialog (JFrame. \\"Hello Frame\\") question \\"test\\"\\n                                JOptionPane/YES_NO_CANCEL_OPTION JOptionPane/QUESTION_MESSAGE\\n                                [yes-desc no-desc cancel-desc] nil nil)))" "(option-dialog \\"test?\\")" "(defn option-dialog [question & buttons]\\n  (let [[yes-desc no-desc cancel-desc] buttons]\\n  (JOptionPane/showOptionDialog (JFrame. \\"Hello Frame\\") question \\"test\\"\\n                                JOptionPane/YES_NO_CANCEL_OPTION JOptionPane/QUESTION_MESSAGE\\n                                 nil [yes-desc no-desc cancel-desc] nil)))" "(option-dialog \\"test?\\")" "(defn option-dialog [question & buttons]\\n  (let [[yes-desc no-desc cancel-desc] buttons]\\n  (JOptionPane/showOptionDialog (JFrame. \\"Hello Frame\\") question \\"test\\"\\n                                JOptionPane/YES_NO_CANCEL_OPTION JOptionPane/QUESTION_MESSAGE\\n                                 nil [yes-desc no-desc cancel-desc] nil)))" "(let [[x y] nil] x)" "(defn option-dialog [question & buttons]\\n  (let [[yes-desc no-desc cancel-desc] buttons]\\n  (JOptionPane/showOptionDialog (JFrame. \\"Hello Frame\\") question \\"test\\"\\n                                JOptionPane/YES_NO_CANCEL_OPTION JOptionPane/QUESTION_MESSAGE\\n                                 nil nil nil)))" "(let [[x y] nil] x)" "(option-dialog \\"test?\\")" "(defn option-dialog [question & buttons]\\n  (let [buttons (if (nil? buttons)\\n                  [\\"Yes\\" \\"No\\" \\"Cancel\\"]\\n                  buttons)]\\n  (JOptionPane/showOptionDialog (JFrame. \\"Hello Frame\\") question \\"test\\"\\n                                JOptionPane/YES_NO_CANCEL_OPTION JOptionPane/QUESTION_MESSAGE\\n                                 nil buttons nil)))" "(option-dialog \\"test?\\")" "(defn option-dialog [question & buttons]\\n  (let [buttons (if (nil? buttons)\\n                  [\\"Yes\\" \\"No\\" \\"Cancel\\"]\\n                  buttons)]\\n  (JOptionPane/showOptionDialog (JFrame. \\"Hello Frame\\") question \\"test\\"\\n                                JOptionPane/YES_NO_CANCEL_OPTION JOptionPane/QUESTION_MESSAGE\\n                                 nil buttons nil)))" "(Object.)" "(Object. \\"yes\\")" "(class (list \\"test\\"))" "(cast Object (list \\"test\\"))" "(cast Object (list \\"test\\" \\"test\\"))" "(defn option-dialog [question & buttons]\\n  (let [buttons (if (nil? buttons)\\n                  (cast Object (list \\"Yes\\" \\"No\\" \\"Cancel\\")\\n                  (cast Object buttons)))]\\n  (JOptionPane/showOptionDialog (JFrame. \\"Hello Frame\\") question \\"test\\"\\n                                JOptionPane/YES_NO_CANCEL_OPTION JOptionPane/QUESTION_MESSAGE\\n                                 nil buttons nil)))" "(option-dialog \\"test?\\")" "(defn option-dialog [question & buttons]\\n  (let [buttons (if (nil? buttons)\\n                  (cast Object (list \\"Yes\\" \\"No\\" \\"Cancel\\")\\n                  (cast Object (list buttons))))]\\n  (JOptionPane/showOptionDialog (JFrame. \\"Hello Frame\\") question \\"test\\"\\n                                JOptionPane/YES_NO_CANCEL_OPTION JOptionPane/QUESTION_MESSAGE\\n                                 nil buttons nil)))" "(option-dialog \\"test?\\")" "(defn option-dialog [question & buttons]\\n  (let [buttons (if (nil? buttons)\\n                  (cast Object (list \\"Yes\\" \\"No\\" \\"Cancel\\"))\\n                  (cast Object  buttons))]\\n  (JOptionPane/showOptionDialog (JFrame. \\"Hello Frame\\") question \\"test\\"\\n                                JOptionPane/YES_NO_CANCEL_OPTION JOptionPane/QUESTION_MESSAGE\\n                                 nil buttons nil)))" "(option-dialog \\"test?\\")" "(cast Object (list \\"test\\" \\"test\\"))" "(defn option-dialog [question & buttons]\\n  (let [buttons (if (nil? buttons)\\n                  (cast Object (list \\"Yes\\" \\"No\\" \\"Cancel\\"))\\n                  (cast Object  (list buttons)))]\\n  (JOptionPane/showOptionDialog (JFrame. \\"Hello Frame\\") question \\"test\\"\\n                                JOptionPane/YES_NO_CANCEL_OPTION JOptionPane/QUESTION_MESSAGE\\n                                 nil buttons nil)))" "(cast Object (list \\"test\\" \\"test\\"))" "(option-dialog \\"test?\\")" "(defn option-dialog [question & buttons]\\n  (let [buttons  (cast Object (list \\"Yes\\" \\"No\\" \\"Cancel\\"))]\\n  (JOptionPane/showOptionDialog (JFrame. \\"Hello Frame\\") question \\"test\\"\\n                                JOptionPane/YES_NO_CANCEL_OPTION JOptionPane/QUESTION_MESSAGE\\n                                 nil buttons nil)))" "(option-dialog \\"test?\\")" "(defn option-dialog [question ]\\n  (JOptionPane/showOptionDialog (JFrame. \\"Hello Frame\\") question \\"test\\"\\n                                JOptionPane/YES_NO_CANCEL_OPTION JOptionPane/QUESTION_MESSAGE\\n                                 nil nil nil))" "(defn option-dialog [question ]\\n  (JOptionPane/showOptionDialog (JFrame. \\"Hello Frame\\") question \\"test\\"\\n                                JOptionPane/YES_NO_CANCEL_OPTION JOptionPane/QUESTION_MESSAGE\\n                                nil nil nil))" "(option-dialog \\"test?\\")" "(defn option-dialog [question ]\\n  (JOptionPane/showOptionDialog (JFrame.) question \\"Select an Option.\\"\\n                                JOptionPane/YES_NO_CANCEL_OPTION JOptionPane/QUESTION_MESSAGE\\n                                nil nil nil))" "(option-dialog \\"test?\\")" "(in-ns 'tgaa.algo.core)" "(run-as-app)" "(option-dialog \\"test?\\")" "(run-as-app)" " (gui/option-dialog \\"Process another image?\\")" "(run-as-app)" " (gui/option-dialog \\"Process another image?\\")" "(run-as-app)" "(+ 1 1)" "(run-animation)" "(run-as-app)"]
eclipse.preferences.version=1
